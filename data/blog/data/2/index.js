export default (api) => {
    const {book, text} = api;
    const {code, a, h} = text;
    return book`
Изначально для построения сайта я использовал нативные es6 модули.


Они позволяют внутри js файлов использовать конструкции ${code('export')} и ${code('import')}, и браузер подгрузит все зависимости.
В теге script в html необходимо также указать, что скрипт используется в качестве модуля ${code('<srcipt src="example.js" type="module"></script>')}.


Такой подход был идеален для старта, потому что не требовал никаких настроек, всё делал браузер, не нужны сборщики кода.
Но в итоге минусы перевесили плюсы.


Среди минусов:


— Кэширование ресурсов, файлы js не обновятся, пока вручную не будет сброшен кэш браузера.
Это можно решить заголовком ETag и соответствующей настройкой сервера.
Но так как сайт хостится на Github Pages, то настроить сервер не представляется возможным.


— Каждый файл порождает запрос.
Много мелких файлов — много запросов.
Так как я использую компонентный подход, то для каждого js файла есть css(less) файл, и он тоже грузится отдельно.


— Использование css препроцессоров.
Я решил использовать ${a.href('https://lesscss.org')('Less')}, так как он обладает минимумом нужных функций(мне нужен только nesting и переменные).
Less можно использовать в рантайме, что я изначально и делал.
Для каждого модуля я добавлял стили специально написанной функцией ${code('css(import.meta.url, \'./Example.less\')')}.
Эта функция создавала элемент ${code('<link>')}, его уже подхватывал скрипт less и генерировал стили.
В результате стили грузились после отрисовки контента и верстка "скакала".


${h(3)('Сборка')}
Стал использовать ${a.href('https://parceljs.org')('Parcel')} из-за того, что он многое поддерживает из коробки и практически не требует настроек.
Есть горячая замена — пересборка запускается при каждом изменении файлов.
Так как для хостинга нужно, чтобы в корне лежал index.html, собираются только js и css ресурсы, а html обновляется отдельно nodejs скриптом.
Файлам даются уникальные имена относительно версии проекта.


Сборка и dev режим запускаются с помощью npm скриптов.


build: ${code('rm -Rf build;parcel build index.js --out-dir build --out-file index.${npm_package_version}.js; node html-gen.js ${npm_package_version}')}


dev: ${code('parcel watch index.js --out-dir build --out-file index.${npm_package_version}.js')}


Для разработки использую расширение ${a.href('https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer')('Live Server')} для VSCode.
`;
}

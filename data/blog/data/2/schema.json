[
  "\nИзначально для построения сайта я использовал нативные es6 модули.\n\n\nОни позволяют внутри js файлов использовать конструкции ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "export"
    ]
  },
  " и ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "import"
    ]
  },
  ", и браузер подгрузит все зависимости.\nВ теге script в html необходимо также указать, что скрипт используется в качестве модуля ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "&lt;srcipt src=\"example.js\" type=\"module\"></script>"
    ]
  },
  ".\n\n\nТакой подход был идеален для старта, потому что не требовал никаких настроек, всё делал браузер, не нужны сборщики кода.\nНо в итоге минусы перевесили плюсы.\n\n\nСреди минусов:\n\n\n— Кэширование ресурсов, файлы js не обновятся, пока вручную не будет сброшен кэш браузера.\nЭто можно решить заголовком ETag и соответствующей настройкой сервера.\nНо так как сайт хостится на Github Pages, то настроить сервер не представляется возможным.\n\n\n— Каждый файл порождает запрос.\nМного мелких файлов — много запросов.\nТак как я использую компонентный подход, то для каждого js файла есть css(less) файл, и он тоже грузится отдельно.\n\n\n— Использование css препроцессоров.\nЯ решил использовать ",
  {
    "name": "link",
    "props": {
      "href": "https://lesscss.org"
    },
    "children": [
      "Less"
    ]
  },
  ", так как он обладает минимумом нужных функций(мне нужен только nesting и переменные).\nLess можно использовать в рантайме, что я изначально и делал.\nДля каждого модуля я добавлял стили специально написанной функцией\n\n",
  {
    "name": "code",
    "props": {
      "lang": "javascript"
    },
    "children": [
      "css(import.meta.url, './Example.less')"
    ]
  },
  "\n\nЭта функция создавала элемент ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "<link>"
    ]
  },
  ", его уже подхватывал скрипт less и генерировал стили.\nВ результате стили грузились после отрисовки контента и верстка \"скакала\".\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Сборка"
    ]
  },
  "\nСтал использовать ",
  {
    "name": "link",
    "props": {
      "href": "https://parceljs.org"
    },
    "children": [
      "Parcel"
    ]
  },
  " из-за того, что он многое поддерживает из коробки и практически не требует настроек.\nЕсть горячая замена — пересборка запускается при каждом изменении файлов.\nТак как для хостинга нужно, чтобы в корне лежал index.html, собираются только js и css ресурсы, а html обновляется отдельно nodejs скриптом.\nФайлам даются уникальные имена относительно версии проекта.\n\n\nСборка и dev режим запускаются с помощью npm скриптов.\n\n\nbuild: ",
  {
    "name": "code",
    "props": {},
    "children": [
      "rm -Rf build;parcel build index.js --out-dir build --out-file index.${npm_package_version}.js; node html-gen.js ${npm_package_version}"
    ]
  },
  "\n\n\ndev: ",
  {
    "name": "code",
    "props": {},
    "children": [
      "parcel watch index.js --out-dir build --out-file index.${npm_package_version}.js"
    ]
  },
  "\n\n\nДля разработки использую расширение ",
  {
    "name": "link",
    "props": {
      "href": "https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer"
    },
    "children": [
      "Live Server"
    ]
  },
  " для VSCode.\n"
]
import { BookApi } from '@bookbox/preset-web';

export default (_: BookApi) => _.book.root`
${_.header.level(3)`Что это?`}
Давно хотел сделать красивый интерфейс для быстрого исследования двухаргументных функций с эволюцией во времени.


Посмотреть можно на странице нового проекта ${_.link.href(
    '/?/projects/color-function'
)`Цветная функция`}.

${_.image
    .height(0.5)
    .src(
        '/data/blog/data/23/color-fn.png'
    )`Интерфейс: настройки и область функции`}


Визуально можно быстро находить:
${_.list`
${_.item`Минимумы и максимумы`}
${_.item`Линии перегиба, то есть минимумы и максимумы производных`}
${_.item`Паттерны: периодичность, структуру, слишком быстрый рост`}
`}

Какие функции можно рассматривать:
${_.list`
${_.item`Функция от 2-х аргументов без эволюции`}
${_.item`Функция от 2-х аргументов с эволюцией во времени`}
${_.item`Функция более чем от 2-х аргументов, где аргументы фиксируются либо один из них становится временем`}
${_.item`Даже функция от одного аргумента, если использовать в качестве линии резкий перепад значений (пример ниже)`}
`}

${_.header.level(3)`Описание настроек`}
Я хотел дать максимум свободы в настройках, поэтому настройки достаточно близки с коду вычисления.


Самая главная настройка — вычисляемая функция. Она в своём тексте неявно полагается на следующие соглашения:
${_.list`
${_.item`буквы ${_.format.pre.inline(
    true
)`x`} и ${_.format.pre.inline()`y`} это аргументы`}
${_.item`буква ${_.format.pre.inline()`t`} определяет переменную для времени`}
${_.item`можно использовать всё, что есть в ${_.format.pre.inline()`Math`} — ${_.format.pre.inline()`sin`}, ${_.format.pre.inline()`cos`}, ${_.format.pre.inline()`PI`} без префикса ${_.format.pre.inline()`Math.`}. То есть запись ${_.format.pre.inline()`sin(x)`} в коде превратится в ${_.format.pre.inline()`Math.sin(x)`}`}
${_.item`на самом деле после вышеописанных преобразований текст евалится прямо в функцию, так что можно использовать тернарки, свои глобальные переменные и т.д.`}
`}


Далее следуют настройки размеров:
${_.list`
${_.item`Ширина и высота графика`}
${_.item`Минимумы и максимумы для x, y (область определения) и результата функции (влияет на цвет, он не уходит дальше пределов, даже если уходит само значение)`}
${_.item`Разрешение графика, то есть точность вычисления. Выглядит как ползунок, можно двигать в диапазоне от 1 до 200. Чем меньше разрешение, тем очевидно быстрее идут вычисления, особенно если запускать эволюцию`}
`}


Блок эволюции:
${_.list`
${_.item`Настройки периода в секундах и шага временной переменной, шаг будет добавлятся в requestAnimationFrame`}
${_.item`Кнопка запуска эволюции, сразу под ней текущее состояние, а именно пройденное время и прогресс бар`}
`}

Чем больше разрешение, тем тяжелее вычисления, и тем меньше кадров будет убираться в выбранный период. Рекомендую сначал выставить период в несколько секунд, а затем подкручивать разрешение до тех пор, пока анимация не станет плавной (но не слишком его опускать, так как быстрее текущего fps сделать всё равно не выйдет).


И наконец, можно сохранять выбранные настройки как пресеты. Пресеты имеют имена и хранятся в localStorage. Их можно добавлять, удалять, и менять (сохранив пресет под тем же именем). При применении пресета его настройки будут скопированы в рабочую область.


${_.header.level(3)`Примеры`}
Из тривиального можем просто перемножить x и y

${_.image
    .height(0.5)
    .src('/data/blog/data/23/color-fn-example-mult.png')`x * y`}

Так как мы ограничили минимум и максимум, то в области плавного перетекания цветов сразу видно гиперболу. Чтобы вывести график от одной переменной, можно действовать более прямо (ниже пример с синусом).


Чтобы сделать решётку, достаточно сложить 2 волны, то есть 2 синуса

${_.image
    .height(0.5)
    .src('/data/blog/data/23/color-fn-example-sin.png')`Решётка из синусов`}


Теперь заставим эту решётку мигать. Как? Просто добавим синус по времени. Так как все три синусы одинаковы, то синус временной переменной никогда полностью не перекроет минимум или максимум функции. Что визуально будет выглядеть как мигание

${_.video
    .height(0.5)
    .src(
        '/data/blog/data/23/color-fn-example-pulse.mov'
    )`Мигание решётки на синусах`}


Ну и напоследок, рецепт построения функций от одного аргумента. Возьмём тот же синус например. Представим, что у нас обычная функция — ${_.math.inline(
    true
)`y = sin(x)`}. Покажем её график так: выше функции цвет будет красным, а ниже зелёным. Сама линия графика будет выглядеть как граница между областями. Секрет в том, чтобы сравнить y с целевой функцией. Действительно, если бы мы решали неравенства, то получили бы 2 области. Но если вычесть прямую, то вместо резкого перехода мы получим плавное перетекание.


Явное условие через тернарку будет выглядеть так:
${_.image
    .height(0.5)
    .src('/data/blog/data/23/color-fn-example-simple-wave.png')`Чёткий синус`}


Теперь добавим ему плавности и анимацию. Вместо тернарки просто вычтем выражения
${_.video
    .height(0.5)
    .src('/data/blog/data/23/color-fn-example-wave.mov')`Бегущая волна`}

`;

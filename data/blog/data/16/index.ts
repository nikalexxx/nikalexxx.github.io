import { BookApi } from "@bookbox/preset-web";

export default (api: BookApi) => {
    const {book, format, header, link, code} = api;
    const {pre, b} = format;
    return book`
${header.level(3)`Для чего?`}
Хотя современные браузеры умеют переводить сайты прямо на лету, более старые версии делать этого не умеют.
Но это не главная причина.
Личный сайт это не интернет-магазин и не промо-страница, здесь я пробую писать что-то сам.
Главная причина — попробовать написать что-то новое.
Поэтому я не беру готовые библиотеки класса ${pre`i18n`}.


${header.level(3)`Как всё работает`}
Есть хранилище токенов, где для каждого токена помещаются значения для нужных языков.


Хранилище имеет вид:
${code.lang('typescript')`
Map<string, string>
`}

Каждый ключ в хранилище склеивается из языка и имени токена, например для токена ${pre`title`} и языка ${pre`ru`} ключ — ${pre`ru/title`}


Пока поддерживается всего два языка — русский и английский
${code.lang('typescript')`
type Lang = 'ru' | 'en'
`}


По дефолту выбран русский язык
${code.lang('typescript')`
export const defaultLang: Lang = 'ru';
`}

Для создания токенов используется функция ${pre`addToken`}
${code.lang('typescript')`
export function addToken(
    name: string,
    value: Partial<Record<Lang, string>>
) {
    for (const lang of Object.keys(value)) {
        map.set(\`\${lang}/\${name}\`, value[lang]);
    }
}
`}

А для использования реализована функция ${pre`token`}, которая в зависимости от текущего языка возвращает значение токена, либо если для текущего языка значений нет, берёт дефолтный язык.
${code.lang('typescript')`
export const token = (name: string) => {
    return (
        map.get(\`\${currentLang}/\${name}\`) ?? map.get(\`\${defaultLang}/\${name}\`)
    );
};
`}

Текущий язык хранится в замыкании и мутируется выделенной функцией ${pre`setLang`}
${code.lang('typescript')`
let currentLang: Lang = defaultLang;

/**
 * первый раз вызывать перед первым применением функции token
 */
export const setLang = (lang: Lang) => (currentLang = lang);
`}

Это всё.
Пока никакой шаблонизации самих строк.
Все переводы хранятся в коде в качестве аргументов при вызове функции ${pre`addToken`}


${header.level(3)`Поддержка рендера и смены языка`}
Смена языка представлена обычным селектом в шапке справа от переключения темы.

Так как текущий язык хранится в замыкании модуля переводов, то при его смене новое значение токена появится только при следующем вызове функции ${pre`token`}.
Так как в текущем движке пока нет аналога контекста, чтобы пробрасывать вниз по дереву компонентов данные, минуя все промежуточные узлы, я задействовал встроенную в браузер систему событий.
При каждой смене языка я генерирую кастомное событие, и компонент, который отображает токены, обрабатывает событие и обновляется.


Подробнее про сам компонент обертку.
Так как каждый токен представляет из себя строку, а в интерфейсе требуется часто показать больше, чем просто текст, то помимо собственно имени токена в свойствах компонента можно задать кастомное отображение ${pre`view`} для рендера.


Например, на ${link.href`/?/design`('странице дизайна')} плитка раздела ${b`Цвета`} раскрашивала каждую букву в свой цвет.
Чтобы сделать это независимо от языка, я задаю рендер специального вида
${code.lang('typescript')`
Lang.token\`tile/colors\`.view(value =>
    E.span(value
        .split('')
        .map((char, i) =>
            E.span.style(
                \`color: \${colorList[i % colorList.length]}\`
            )(char)
        )
    )
)
`}

Где просто по кругу для каждой буквы беру значения из списка цветов
${code.lang('typescript')`
const colorList = [
    'var(--color-red)',
    'var(--color-green-light)',
    'var(--color-blue-sky)',
    'var(--color-violet-light)',
    'var(--color-orange-light)',
];
`}

${header.level(3)`Что дальше?`}
Не все разделы сайта я перевёл, да и системы для сбора всех переводов у меня нет.
Буду итеративно переводить все страницы, по крайней мере интерфейс.
Может добавлю итальянский язык (как наиболее знакомый, а не популярный).
`};

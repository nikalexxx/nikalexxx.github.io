export default api => {
    const {book, text} = api;
    const {h, a, code} = text;
    return book`
Для облегчения работы с ${code`typescript`} решил написать библиотеку для манипуляции типами.


Встречайте ${a.href('https://github.com/nikalexxx/ts-pro')`ts-pro`} !

По ссылке репозиторий на гитхабе, там описана установка (стандартный npm пакет) и возможности.


Не буду повторять здесь информацию из README, расскажу, почему не удовлетворился существующими решениями.

Есть простая обертка над типами ${a.href('https://github.com/piotrwitek/utility-types')`utility-types`}, но все типы оттуда слишком низкоуровневые.
С другой стороны есть ${a.href('https://gcanti.github.io/fp-ts')`fp-ts`}, но концепции там явно используют инструментарий теории категорий и в целом намечены на функциональное программирование.
Из-за отсутствия дженериков высоких порядков их приходится эмулировать именами и подстановкой по месту использования.
Я хоть и большой поклонник ФП, но хотелось бы чего-то более простого, для использования в существующем коде.


Поэтому и родилась идея ${code`ts-pro`}.


${h(3)`Работа со списками`}
Большую часть занимает именно она.
Учитывается, что список может быть как массивом в терминах typescript (${code`T[]`}), так и кортежем, то есть списком фиксированной длины с известными типами элементов (${code`[A, B, C, ...]`}).

Сначала получаем голову списка и хвост, и на их основе строим все остальные функции (${code`Map, Filter, FilterMap, Find, Every`}) с помощью рекурсии.
Общая механика проста — проверяем условие для головы и в зависимости от результата применяем рекурсивно тип к хвосту списка либо возвращаем некий терминальный тип (например когда дошли до конца списка).


${h(3)`Остальные типы`}
Остальные типы тоже под капотом используют функционал списков и рекурсию, например, ${code`P_Options`} выбирает первый не ${code`never`} тип.


${h(3)`Развитие`}
Следующим логичным шагом будет поддержка типизации для деревьев.
Присоединяйтесь к разработке с предложением новых идей и указанием потребностей.
`};

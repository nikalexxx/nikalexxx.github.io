import { BookApi } from "@bookbox/preset-web";

export default (api: BookApi) => {
    const {book, format, header, link, code} = api;
    const {pre} = format;
    return book`
${header.level(3)`Зачем мне иконки сайтов?`}
В разделе ${link.href('/?/catalog')`Каталог`} я собираю разные полезные ссылки.
Чтобы быстро по ним ориентироваться, с самого начала я добавил к каждой ссылке иконку соответствующего сайта.


Но с иконками возникли проблемы.
Не на каждом сайте была иконка ${pre`favicon.ico`}, некоторые были доступны только по прямой ссылке href из ${pre`<link rel="icon" href="..." />`}.
Часто эта ссылка в имени содержала хэш в результате работы сборщика.
Для таких сайтов я искал исходные картинки и сохранял себе.
Не очень красиво, да и следить приходиться за актуальностью иконок, вдруг поменяют (как Яндекс недавно).


${header.level(3)`Автоматическое обновление иконок`}
Конечно, хочется автоматизировать ручной процесс поиска иконки для каждого сайта.
Нам нужно рассмотреть в том числе такие случаи, когда ссылка на иконку присутсвует только внутри ${pre`<head>`} сайта.
Средствами внутри браузера это сделать не получиться, так как доступ к ${pre`DOM`} стороннего сайта запрещён.
Кроссдоменные запросы через ${pre`XHR`} или ${pre`fetch`} будут блокироваться политиками безопасности, а если воспользоваться ${pre`iframe`}, доступ к его содержимому также будет закрыт для стороннего домена.


Поэтому все необходимые ссылки получим заранее, до этапа сборки.
Я буду использовать ${pre`ruby`} и библиотеку ${pre`nokogiri`} для парсинга html.


Далее опишу основной алгоритм, детали реализации можно посмотреть в исходниках.


Для каждого адреса ${pre`url`} получим дерево html.
${code.lang('ruby')`
response = Net::HTTP.get_response(URI(url))
doc = Nokogiri::HTML(response.body)
`}


Смотрим все ссылки, в которых описаны иконки
${code.lang('ruby')`
doc.css('head link[rel~=icon]').each do |link|
    ...
end
`}

Если попалась svg иконка, то нам повезло, берём её и уходим
${code.lang('ruby')`
if link['type'].to_s.start_with?('image/svg')
    href = link['href']
    break
end
`}


Из оставшихся выбираем иконку максимального размера
${code.lang('ruby')`
sizes = link['sizes'] || '1x1'
size = sizes.split('x')[0].to_i
if size > max_size
    href = link['href']
    max_size = size
end
`}


Если ни одна ссылка не была найдена, возьмём дефолтную
${code.lang('ruby')`
if href == ''
    href = '/favicon.ico'
end
`}


${header.level(3)`Использование`}
Запишем наши результаты в js файл и сразу экспортируем как переменную.
Это будет простой объект, где ключ это адрес сайта, а значение — адрес иконки.
${code.lang('javascript')`
export const icons = {/* ... */} // Record<string, string>
`}

Теперь можно импортировать этот объект в нужные компоненты стандартным способом.
`};

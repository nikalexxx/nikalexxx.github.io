[
  "\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Второй подход к книжному формату"
    ]
  },
  "\nТеперь это больше тулкит, чем формат.\nОн обзавёлся сайтом ",
  {
    "name": "link",
    "props": {
      "href": "https://bookbox-format.github.io"
    },
    "children": []
  },
  ", где можно почитать документацию или просто посмотреть быстрый старт и начать использовать.\n\n\nЦелый год я постепенно работал над ним, чтобы наконец выкатить в опенсорс.\nНа гитхабе можно посмотреть исходники — ",
  {
    "name": "link",
    "props": {
      "href": "https://github.com/bookbox-format"
    },
    "children": []
  },
  "\n\n\nТакже я обновил книгу ",
  {
    "name": "link",
    "props": {
      "href": "/?/books/vereshagin-shen-sets"
    },
    "children": [
      "Начала теории множеств"
    ]
  },
  " и все статьи в этом блоге.\n\n\nЧто же я делал целый год?\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Пакеты в npm"
    ]
  },
  "\nНужна была хорошая структура пакетов, которую можно будет безболезненно расширять в будущем.\n\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "link",
            "props": {
              "href": "https://www.npmjs.com/package/@bookbox/core"
            },
            "children": [
              "@bookbox/core"
            ]
          },
          " — ядро, там описание элементов и построение дерева.\nДерево получает для каждого своего узла локально уникальный ключ.\nВычисляются счётчики.\nОбрабатываются ресурсы (картинки/видео/...), они совмещаются с внешним конфигом ресурсов.\nПроизводится разбивка на страницы, точнее их внедрение в книгу.\nЗаполняется хранилище элементов по ключу.\nЗаполняется мета-информация (оглавление, медиа).\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "link",
            "props": {
              "href": "https://www.npmjs.com/package/@bookbox/generator-js"
            },
            "children": [
              "@bookbox/generator-js"
            ]
          },
          " — генератор книги на typescript, и соответственно на javascript.\nГенератор это исходный код, из которого можно получить схему в виде json или yaml.\nМожно сразу манипулировать AST, не сохраняя схему в файл.\nНо так как схему можно получить лишь один раз, а читать много, то лучше этапы генерации и использования разделять.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "link",
            "props": {
              "href": "https://www.npmjs.com/package/@bookbox/view-html"
            },
            "children": [
              "@bookbox/view-html"
            ]
          },
          " — представление в виде html.\nПревращает схему в строку html.\nРаботает в браузере и на сервере.\nНа сервере можно генерировать html документ.\nВ браузере можно встроить книгу, используя esm модули с любым современным сборщиком модулей или нативно.\nПоддерживает цветовую схему на css переменных, можно адаптировать к любому сайту.\nЕсть поддержка светлой и тёмной темы, оглавления и медиа.\nПри прокрутке в урле запоминается страница, текущее положение в книге запоминается после перезагрузки страницы.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "link",
            "props": {
              "href": "https://www.npmjs.com/package/@bookbox/preset-web"
            },
            "children": [
              "@bookbox/preset-web"
            ]
          },
          " — все три пакета выше в одном.\nМожно установить один пакет и не следить за тремя версиями.\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Алгоритм формирования страниц"
    ]
  },
  "\nЧтобы вклинить страницы в дерево, надо сначала понять, как будет выглядеть дерево элементов на странице.\nА будут они выглядеть как плоский список текста.\nПоэтому надо пробежаться по листьям дерева в том порядке, в каком они будут идти и через каждые N (сейчас 500) символов вставлять новый узел.\nТо есть прикреплять к родительскому узлу.\nПри этом длинные блоки сплошного текста необходимо разрезать в местах появления страниц и заменять старые листья в дереве на новые.\n\n\nДля этого надо было связать узлы дерева.\nВо-первых, связать узел с родителем.\nВо-вторых, с соседними узлами.\nВ-третьих, узлы листья с соседними листьями.\n\n\nСначала мы имеем простое дерево.\n\n\n",
  {
    "name": "image",
    "props": {
      "height": 0.5,
      "src": "/data/blog/data/21/tree.svg"
    },
    "children": [
      "Дерево до преобразования"
    ]
  },
  "\n\n\nЗатем провязываем все узлы связями.\nЗелёные стрелки связывают листья, листья тоже выделены зелёным.\nБольшие зелёные стрелки показывают путь обхода листьев — так мы видим книгу на странице.\n\n\n",
  {
    "name": "image",
    "props": {
      "height": 0.5,
      "src": "/data/blog/data/21/linked-tree.svg"
    },
    "children": [
      "Дерево после преобразования"
    ]
  },
  "\n\n\nТеперь добавим по пути обхода страницы.\nНулевая страница идёт перед всем остальным, просто вставляем.\nПотом отсчитываем 500 символов и попадаем в середину блока текста.\nРазрезаем блок на две части и вклиниваем посередине нашу страницу под номером 1.\n\n\n",
  {
    "name": "image",
    "props": {
      "height": 0.5,
      "src": "/data/blog/data/21/page-tree.svg"
    },
    "children": [
      "Дерево после вставки страниц"
    ]
  },
  "\n\n\nПродолжаем так, пока листья не кончатся.\nПотом уже работаем с новым деревом, где появились страницы в нужных местах.\n\n\nТакая структура может служить не только для вставки страниц, но и для других вещей, когда важно узнать о соседних узлах в дереве.\nНапример, можно будет для выделенного слова заглянуть на 10 слов назад и вперёд, чтобы показать слово в окружении текста и сформировать предметный указатель по книге.\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Поддержка подсветки синтаксиса"
    ]
  },
  "\nТак как блоки кода не редактируемы, мощные инструменты, такие как monaco-editor, не нужны.\nДосточно разбить код на токены, и каждому токену через css присвоить цвет.\nТак работают большинство библиотек подсветки синтаксиса.\n\n\nЯ выбрал ",
  {
    "name": "link",
    "props": {
      "href": "https://github.com/highlightjs/highlight.js"
    },
    "children": [
      "highlight.js"
    ]
  },
  " в первую очередь потому, что она одинаково хорошо работает для браузера и сервера с одним и тем же апи.\n\nБуквально в пару строк я получил подсветку синтаксиса\n",
  {
    "name": "code",
    "props": {
      "lang": "javascript"
    },
    "children": [
      "\nimport hljs from 'highlight.js';\n\nconst {value: colorHtml} = hljs.highlight(text, {language});\n"
    ]
  },
  "\n\nЯ решил сделать темы, приближенные к темам ",
  {
    "name": "link",
    "props": {
      "href": "https://github.com/Binaryify/OneDark-Pro"
    },
    "children": [
      "One Dark Pro"
    ]
  },
  ".\nТемная тема очень похожа на неё.\nСветлая почти такая же, но некоторые цвета темнее для контрастности.\nНапример строки в светлой теме имеют более темный зеленый цвет, а функции более темный синий.\n\n\nСами цвета как и все остальные цвета задаются через css переменные.\n\nСначала определяется список именованных цветов, они составляют палитру.\n\n\n",
  {
    "name": "image",
    "props": {
      "height": 0.7,
      "src": "/data/blog/data/21/css-example.png"
    },
    "children": [
      "Все цвета имеют имена"
    ]
  },
  "\n\n\nА цвета для кода уже используют именованные цвета\n\n",
  {
    "name": "code",
    "props": {
      "lang": "css"
    },
    "children": [
      "\n--book-box-color-code-string: var(--book-box-color-name-green-herbal);\n--book-box-color-code-number: var(--book-box-color-name-orange-light);\n--book-box-color-code-boolean: var(--book-box-color-name-orange-light);\n--book-box-color-code-literal: var(--book-box-color-name-orange-light);\n--book-box-color-code-regexp: var(--book-box-color-name-red);\n"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Типизация"
    ]
  },
  "\n@bookbox/generator-js написан на typescript c хорошей поддержкой типов.\n\n\n",
  {
    "name": "image",
    "props": {
      "width": 1,
      "src": "/data/blog/data/21/ts-example.png"
    },
    "children": [
      "Вывод типов для элемента заголовка"
    ]
  },
  "\n\nТипы свойств элементов выводятся автоматически из ядра и преобразуются в типы для объектов.\nОбъекты также являются функциями, который принимают в качестве аргументов поддерево книги.\nСвойства тоже функции, они принимают как аргумент свои значения и возвращают исходный объект-функцию, обогащённую свойством.\n\n",
  {
    "name": "code",
    "props": {},
    "children": [
      "\nвариант 1: element + .property(value) + ... + (children)\nвариант 2: element + .property(value) + ... + `child text`\n\nпример: image.width(1).src('/data/blog/data/21/ts-example.png')`Вывод типов для элемента заголовка`\n"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Минимум javascript для html представления"
    ]
  },
  "\nВсплывающие панели реализованы на css.\n\nЛогика открытия/скрытия панели реализована с помощью input checkbox.\nСам input невидимый, к нему привязан видимый label.\n\n\n",
  {
    "name": "image",
    "props": {
      "width": 1,
      "src": "/data/blog/data/21/panel-example-1.png"
    },
    "children": [
      "В потоке книги виден только label"
    ]
  },
  "\n\nКонтент панели становится видимым, если галочка поставлена.\nЭто можно проверить в css c помощью псевдокласса :checked, а также возможности указывать в правиле подряд идущие элементы.\n\n\n",
  {
    "name": "image",
    "props": {
      "width": 1,
      "src": "/data/blog/data/21/panel-example-2.png"
    },
    "children": [
      "display меняется с none на grid при активации правила"
    ]
  },
  "\n\n\nАналогично сделано в табах, только там состояние переключается между N элементами (не более 9).\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Навигация по страницам"
    ]
  },
  "\nТекущий номер страницы сохраняется в url в качестве якоря.\nПри перезагрузке книга промотается к нужному месту.\n\nТакже книга отслеживает текущий раздел и помечает активный заголовок в оглавлении.\n\n\nОбе эти возможности реализованы с помощью ",
  {
    "name": "link",
    "props": {
      "href": "https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"
    },
    "children": [
      "IntersectionObserver"
    ]
  },
  ".\nIntersectionObserver позволяет следить за элементами на странице, точнее за тем, как они пересекают видимую область просмотра в браузере.\nЭто гораздо эффективнее, чем проверять положение элементов после каждого события скролла.\n\n\nСлучаи со страницами и заголовками похожи.\nЕсть список элементов, и на странице видна лишь часть списка.\nПри прокрутке некоторые элементы появляются или изчезают сверху или снизу, в зависимости от направления прокрутки.\n\nВсегда есть некий \"текущий\" элемент, который мы обновляем при прокрутке.\nЯ отслеживаю верхний из видимых, но это может быть наоборот нижний из видимых или тот, кто ближе с середине страницы по вертикали.\n\n\nВыбор верхнего элемента важен в моём случае, так как если все элементы исчезли из области видимости, текущий элемент не сбрасывается.\nЭто значит, что в случае с главами достаточно отслеживать только их заголовок, ведь он всегда идёт перед текстом самой главы.\n\n\nВ случае со страницами это также удобно.\nВ зоне видимости обычно (почти всегда в сплошном тексте, реже для блоков картинок) бывает по крайней мере одна страница, поэтому аргумент про сохранение не так важен.\nНо при перезагрузке удобно прокручивать к нужной странице, чтобы она оказалась на самом верху видимого пространства.\nПоэтому если мы отслеживаем самую верхнюю видимую страницу, после перезагрузки она лишь немного сдвинется по вертикали.\n\n\nПримерно так могла бы выглядеть функция определения верхнего элемента (чем меньше индекс, тем выше элемент)\n",
  {
    "name": "code",
    "props": {
      "lang": "typescript"
    },
    "children": [
      "\nfunction getCurrentItemIndex(\n    listMap: Map<string, number>; // отображение data-key -> index\n    current: { index: number | null; visible: Set<number> }; // текущий индекс и остальные видимые\n    entries: IntersectionObserverEntry[]; // события\n) {\n    let overTopMaximum: number = -Infinity;\n    let overBottomMinimum: number = Infinity;\n    for (const entry of entries) {\n        const {\n            isIntersecting, // элемент стал виден?\n            target, // dom узел элемента\n            boundingClientRect: {top}, // верхняя граница элемента\n            intersectionRect: {top: itop} // верхняя граница пересечения\n        } = entry;\n        // я отслеживаю элементы по data-key, но это не обязательно должно быть так\n        const i = listMap.get((target as HTMLElement).dataset.key ?? '') ?? 0;\n        if (isIntersecting) {\n            current.visible.add(i);\n            continue;\n        }\n        current.visible.delete(i);\n        if ((top ^ 0) === (itop ^ 0)) {\n            // исчезание сверху\n            if (i > overTopMaximum) overTopMaximum = i;\n        } else if (i < overBottomMinimum) {\n            // исчезание снизу\n            overBottomMinimum = i;\n        }\n    }\n\n    if (current.visible.size > 0) return Math.min(...current.visible);\n\n    const vars = [];\n    if (current.index !== null) vars.push(current.index);\n    if (overBottomMinimum !== Infinity) vars.push(overBottomMinimum - 1);\n    if (overTopMaximum !== -Infinity) vars.push(overTopMaximum);\n\n    return Math.max(0, Math.min(...vars));\n}\n"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Полноценный сайт"
    ]
  },
  "\nСайт ",
  {
    "name": "link",
    "props": {
      "href": "https://bookbox-format.github.io"
    },
    "children": []
  },
  " написан на ",
  {
    "name": "link",
    "props": {
      "href": "https://www.solidjs.com"
    },
    "children": [
      "solid-js"
    ]
  },
  ".\n\n\nСтраницы документации и быстрого старта написаны на bookbox.\nОбертка для solid была небольшой.\n\n\nВот собственно и она\n\n\n",
  {
    "name": "code",
    "props": {
      "lang": "tsx"
    },
    "children": [
      "\nimport { Component, onMount } from 'solid-js';\nimport { browserInit, render, RenderOptions } from '@bookbox/preset-web';\n\nbrowserInit();\n\nexport const Bookbox: Component<Omit<RenderOptions, 'element'>> = ({ bookData, settingsOptions, layoutOptions }) => {\n    let docsRef: HTMLDivElement;\n\n    onMount(() => {\n        render({ element: docsRef, bookData, settingsOptions, layoutOptions });\n    });\n\n    return <div ref={docsRef!}></div>;\n};\n"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      "Планы"
    ]
  },
  "\nСейчас мне нужно научится в автоматическом или полуавтоматическом режиме переводить документы tex.\nНачала теории множеств я набивал вручную.\nВ идеале это должен быть онлайн конвертер, хочу любую теховскую статью из arxiv переводить на лету.\n\n\nПараллельно с этим нужно искать лучший генератор.\nЯ пробовал mdx, но там слишком много багов в официальных реализациях.\nВозможно, на первом этапе будет достаточно jsx, присматриваюсь к шаблонам astro.\n\n\nИ наконец нужно развивать html представление, добавить листание страниц, настройку размера текста и другие настройки.\nПомимо html, очевидно нужен markdown и tex в качестве форматов просмотра.\nДля конвертации туда-обратно рассматриваю pandoc.\n\n\n"
]
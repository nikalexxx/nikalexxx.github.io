import { BookApi } from '@bookbox/preset-web';
import { getCustomElements } from '../../elements.js';

export default (api: BookApi) => {
    const { format, area, start, end, math, label } = api;
    const { i, b } = format;

    const {paragraph, theorem, problem, proof, A, B, X, printNote} = getCustomElements(api);

    return api.book`
${paragraph.key('founded-sets')`Фундированные множества`}
Принцип математической индукции в одной из возможных форм звучит так:


${i`
Пусть ${math`A(n)`} — некоторое свойство натурального числа ${math`n`}.
Пусть нам удалось доказать ${math`A(n)`} в предположении, что ${math`A(m)`} верно для всех ${math`m`}, меньших ${math`n`}.
Тогда свойство ${math`A(n)`} верно для всех натуральных чисел ${math`n`}.
`}


(Заметим, что по условию доказательство ${math`A(0)`} возможно без всяких предположений, поскольку меньших чисел нет.)


Для каких частично упорядоченных множеств верен аналогичный принцип?
Ответ даётся следующей простой теоремой:


${theorem.key('founded-set')`
Следующие три свойства частично упорядоченного множества ${X} равносильны:

${start(area.key('theorem_founded-set-list'))}
${start(area.key('theorem_founded-set-а'))}
(${b`а`}) любое непустое подмножество ${X} имеет минимальный элемент;
${end(area)}
${start(area.key('theorem_founded-set-б'))}
(${b`б`}) не существует бесконечной строго убывающей последовательности ${math`x_0 > x_1 > x_2 > \\ldots`} элементов множества ${X};
${end(area)}
${start(area.key('theorem_founded-set-в'))}
(${b`в`}) для множества ${X} верен принцип индукции в следующей форме: если (при каждом ${math`x \\in X`}) из истинности ${math`A(y)`} для всех ${math`y < x`} следует истинность ${math`A(x)`}, то свойство ${math`A(x)`} верно при всех ${math`x`}.
Формально это записывают так:
${math.block()`
\\forall x (\\forall y ((y < x) \\lrArr A(y)) \\lrArr A(x)) \\lrArr \\forall x A(x).
`}
${end(area)}
${end(area)}
`}

${proof.start}
Сначала докажем эквивалентность первых двух свойств.
Если ${math`x_0 > x_1 > x_2 > \\ldots`} — бесконечная убывающая последовательность, то, очевидно, множество её значений не имеет минимального элемента (для каждого элемента следующий ещё меньше).
Поэтому из ${label.ref('theorem_founded-set-а')`(а)`} следует ${label.ref('theorem_founded-set-б')`(б)`}.
Напротив, если ${B} — непустое множество, не имеющее минимального элемента, то бесконечную убывающую последовательность можно построить так.
Возьмём произвольный элемент ${math`b_0 \\in B`}.
По предположению он не является минимальным, так что можно найти ${math`b_1 \\in B`}, для которого ${math`b_0 > b_1`}.
По тем же причинам можно найти ${math`b_2 \\in B`}, для которого ${math`b_1 > b_2`} и т.д.
Получается бесконечная убывающая последовательность.


Теперь выведем принцип индукции из существования минимального элемента в любом подмножестве.
Пусть ${math`A(x)`} — произвольное свойство элементов множества ${X}, верное не для всех элементов ${math`x`}.
Рассмотрим непустое множество ${B} тех элементов, для которых свойство ${A} неверно.
Пусть ${math`x`} — минимальный элемент множества ${B}.
По условию меньших элементов в множестве ${B} нет, поэтому для всех ${math`y < x`} свойство ${math`A(y)`} выполнено.
Но тогда по предположению должно быть выполнено и ${math`A(x)`} — противоречие.


Осталось доказать существование минимального элемента в любом непустом подмножестве, исходя из принципа индукции.
Пусть ${B} — подмножество без минимальных элементов.
Докажем по индукции, что ${B} пусто; другими словами, в качестве ${math`A(x)`} возьмём свойство ${math`x \\not \\in B`}.
В самом деле, если ${math`A(y)`} верно для всех ${math`y < x`}, то никакой элемент, меньший ${math`x`}, не лежит в ${B}.
Если бы ${math`x`} лежал в ${B}, то он был бы там минимальным, а таких нет.
${proof.end}


Множества, обладающие свойствами ${label.ref('theorem_founded-set-list')`(а) – (в)`}, называются ${i`фундированными`}.
Какие есть примеры фундированных множеств?
Прежде всего, наш исходный пример — множество натуральных чисел.


Другой пример — множество ${math`\\N \\times \\N`} пар натуральных чисел
(меньше та пара, у которой второй член меньше; в случае равенства сравниваем первые).
В самом деле, проверим условие ${label.ref('theorem_founded-set-б')`(б)`}.
Нам будет удобно сформулировать его так: всякая последовательность ${math`u_0 \\geqslant u_1 \\geqslant u_2 \\geqslant \\ldots`} элементов множества рано или поздно стабилизируется (все члены, начиная с некоторого, равны);
очевидно, что это эквивалентная формулировка.


Пусть дана произвольная последовательность пар
${math.block()`
\\lang x_0, y_0 \\rang \\geqslant \\lang x_1, y_1 \\rang \\geqslant \\lang x_2, y_2 \\rang \\geqslant \\dots
`}
По определению порядка (сначала сравниваются вторые члены) ${math`y_0 \\geqslant y_1 \\geqslant y_2 \\geqslant \\dots`} и потому последовательность натуральных чисел ${math`y_i`} с какого-то места не меняется.
После этого уже ${math`x_i`} должны убывать — и тоже стабилизируются.
Что и требовалось.


То же самое рассуждение пригодно и в более общей ситуации.


${theorem.key('founded-mult')`
Пусть ${A} и ${B} — два фундированных частично упорядоченных множества.
Тогда их произведение ${math`A \\times B`}, в котором
${math.block()`
\\lang a_1, b_1 \\rang \\leqslant \\lang a_2, b_2 \\rang \\lrArr [(b_1 < b_2) \\ \\text{или} \\ (b_1 = b_2 \\ \\text{и} \\ a_1 \\leqslant a_2)],
`}
является фундированным.
`}

${proof.start}
В последовательности ${math`\\lang a_0, b_0 \\rang \\geqslant \\lang a_1, b_1 \\rang \\geqslant \\dots`} стабилизируются сначала вторые, а затем и первые члены.
${proof.end}


Отсюда вытекает аналогичное утверждение для ${math`\\N \\times \\N \\times \\N`}, для ${math`\\N^k`} или вообще для произведения конечного числа фундированных множеств.


Ещё проще доказать, что сумма ${math`A + B`} двух фундированных множеств ${A} и ${B} фундирована: последовательность ${math`x_0 \\geqslant x_1 \\geqslant x_2 \\geqslant \\dots`} либо целиком содержится в ${B} (и мы ссылаемся на фундированность ${B}), либо содержит элемент из ${A}.
В последнем случае все следующие элементы также принадлежат ${A}, и мы используем фундированность ${A}.


Часто в программировании (или в олимпиадных задачах) нам нужно доказать, что некоторый процесс не может продолжаться бесконечно долго.
Например, написав цикл, мы должны убедиться, что рано или поздно из него выйдем.
Это можно сделать так: ввести какой-то натуральный параметр и убедиться, что на каждом шаге цикла этот параметр уменьшается.
Тогда, если сейчас этот параметр равен ${math`N`}, то можно гарантировать, что не позже чем через ${math`N`} шагов цикл закончится.


Однако бывают ситуации, в которых число шагов заранее оценить нельзя, но тем не менее гарантировать завершение цикла можно, поскольку есть параметр, принимающий значения в фундированном множестве и убывающий на каждом шаге цикла.


Вот пример олимпиадной задачи, где по существу такое рассуждение и используется.


Бизнесмен заключил с чёртом сделку: каждый день он даёт чёрту одну монету, и в обмен получает любой набор монет по своему выбору, но все эти монеты меньшего достоинства (видов монет конечное число).
Менять (или получать) деньги в другом месте бизнесмен не может.
Когда монет больше не останется, бизнесмен проигрывает.
Докажите, что рано или поздно чёрт выиграет, каков бы ни был начальный набор монет у бизнесмена.


Решение: пусть имеется ${math`k`} видов монет.
Искомый параметр определим так: посчитаем, сколько монет каждого вида есть у бизнесмена
(${math`n_1`} — число монет минимального достоинства, ${math`n_2`} — число следующих, и так далее до ${math`n_k`}).
Заметим, что в результате встречи с чёртом набор ${math`\\lang n_1, \\dots , n_k \\rang`} уменьшается (в смысле введённого нами порядка, когда мы сравниваем сначала последние члены, затем предпоследние и т. д.).
Поскольку множество ${math`\\N^k`} фундировано, этот процесс должен оборваться.


${problem`
Имеется конечная последовательность нулей и единиц.
За один шаг разрешается сделать такое действие: найти в ней группу ${math`01`} и заменить на ${math`100 \\dots 00`}
(при этом можно написать сколько угодно нулей).
Докажите, что такие шаги нельзя выполнять бесконечно много раз.
`}


${problem`
Рассмотрим множество всех слов русского алфавита
(точнее, всех конечных последовательностей русских букв, независимо от смысла)
с ${label.ref('lexical-order')`лексикографическим порядком`} ${printNote`(см. с. 44)`}.
Будет ли это множество фундировано?
`}


${problem`
Рассмотрим множество невозрастающих последовательностей натуральных чисел, в которых все члены, начиная с некоторого, равны нулю.
Введём в нём порядок так: сначала сравниваем первые члены, при равенстве первых вторые и т. д.
Докажите, что это (линейно) упорядоченное множество фундировано.
`}


${problem`
Рассмотрим множество всех многочленов от одной переменной ${math`x`}, коэффициенты которых — натуральные числа.
Упорядочим его так: многочлен ${math`P`} больше многочлена ${math`Q`}, если ${math`P(x) > Q(x)`} для всех достаточно больших ${math`x`}.
Покажите, что это определение задаёт линейный порядок и что получающееся упорядоченное множество фундировано.
`}
`;
};

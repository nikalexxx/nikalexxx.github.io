import { BookApi } from '@bookbox/preset-web';
import { getCustomElements } from '../../elements.js';

export default (api: BookApi) => {
    const { format, start, end, math, label, link, list, item } = api;
    const { i,  } = format;

    const {
        paragraph,
        theorem,
        problem,
        proof,
        A,
        B,
        X,
        n,
        printNote,
    } = getCustomElements(api);

    return api.book`
${paragraph`Трансфинитная индукция`}
Термины «индукция» и «рекурсия» часто употребляются вперемежку.
Например, определение факториала ${math`n! = 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot n`} как функции ${math`f(n)`}, для которой ${math`f(n) = n \\cdot f(n - 1)`} при ${math`n > 0`} и ${math`f(0) = 1`}, называют и «индуктивным», и «рекурсивным».
Мы будем стараться разграничивать эти слова так: если речь идёт о доказательстве чего-то сначала для ${math`n = 0`}, затем для ${math`n = 1, 2, \\dots`}, причём каждое утверждение опирается на предыдущее, то это ${i`индукция`}.
Если же мы определяем что-то сначала для ${math`n = 0`}, потом для ${math`n = 1, 2, \\dots`}, причём определение каждого нового значения использует ранее определённые, то это ${i`рекурсия`}.


Наша цель — научиться проводить индуктивные доказательства и давать рекурсивные определения не только для натуральных чисел, но и для других вполне упорядоченных множеств (эту технику иногда называют «трансфинитной индукцией»).


Доказательства по индукции мы уже обсуждали, говоря о фундированных множествах (см. раздел ${link.ref(
        'paragraph_founded-sets'
    )`${n.paragraph(
        'founded-sets'
    )}`}), и сейчас ограничимся только одним примером.
${theorem.key('f(x)>x')`
Пусть множество ${A} вполне упорядочено, а отображение ${math`f: A \\to A`} возрастает
(то есть ${math`f(x) < f(y)`} при ${math`x < y`}).
Тогда ${math`f(x) > x`} для всех ${math`x \\in A`}.
`}


${proof.start}
Согласно принципу индукции (${label.ref(
        'theorem_founded-set'
    )`теорема ${n.theorem(
        'founded-set'
    )}`}) достаточно доказать неравенство ${math`f(x) > x`}, предполагая, что ${math`f(y) > y`} при всех ${math`y < x`}.
Пусть это не так и ${math`f(x) < x`}.
Тогда по монотонности ${math`f(f(x)) < f(x)`}.
Но, с другой стороны, элемент ${math`y = f(x)`} меньше ${math`x`}, и потому по предположению индукции ${math`f(y) > y`}, то есть ${math`f(f(x)) > f(x)`}.


Если угодно, можно в явном виде воспользоваться существованием наименьшего элемента и изложить это же рассуждение так.
Пусть утверждение теоремы неверно.
Возьмём наименьшее ${math`x`}, для которого ${math`f(x) < x`}.
Но тогда ${math`f(f(x)) < f(x)`} по монотонности и потому ${math`x`} не является наименьшим вопреки предположению.


Наконец, это рассуждение можно пересказать и так: если ${math`x > f(x)`}, то по монотонности
${math.block()`
x > f(x) > f(f(x)) > f(f(f(x))) > \\dots ,
`}
но бесконечных убывающих последовательностей в фундированном множестве быть не может.
${proof.end}


Теперь перейдём к рекурсии.
В определении факториала ${math`f(n)`} выражалось через ${math`f(n - 1)`}.
В общей ситуации значение ${math`f(n)`} может использовать не только одно предыдущее значение функции, но и все значения на меньших аргументах.
Например, можно определить функцию ${math`f: \\N \\to \\N`}, сказав, что ${math`f(n)`} на единицу больше суммы всех предыдущих значений, то есть ${math`f(n) = f(0) + f(1) + \\ldots + f(n - 1) + 1`};
это вполне законное рекурсивное определение
(надо только пояснить, что пустая сумма считается равной нулю, так что ${math`f(0) = 1`}).


${problem`Какую функцию ${math`f`} задаёт такое определение?`}


Как обобщить эту схему на произвольные вполне упорядоченные множества вместо натурального ряда?
Пусть ${A} вполне упорядочено.
Мы хотим дать рекурсивное определение функции ${math`f: A \\to B`} (где ${B} — некоторое множество).
Такое определение должно связывать значение ${math`f(x)`} на некотором элементе ${math`x \\in A`} со значениями ${math`f(y)`} при всех ${math`y < x`}.
Другими словами, рекурсивное определение указывает ${math`f(x)`}, предполагая известным ограничение функции ${math`f`} на начальный отрезок ${math`[0, x)`}.
Вот точная формулировка:


${theorem.key(
    'transfinite-recursion'
)`Пусть ${A} — вполне упорядоченное множество.
Пусть ${B} — произвольное множество.
Пусть имеется некоторое рекурсивное правило, то есть отображение ${math`F`}, которое ставит в соответствие элементу ${math`x \\in A`} и функции ${math`g: [0, x) \\to B`} некоторый элемент множества ${B}.
Тогда существует и единственна функция ${math`f: A \\to B`}, для которой
${math.block()`
f(x) = F(x, f | _{[0,x)})
`}
при всех ${math`x \\in A`}.
(Здесь ${math`f | _{[0,x)}`} обозначает ограничение функции ${math`f`} на начальный отрезок ${math`[0, x)`} — мы отбрасываем все значения функции на элементах, больших или равных ${math`x`}.)
`}


${proof.start}
Неформально можно рассуждать так: значение ${math`f`} на минимальном элементе определено однозначно, так как предыдущих значений нет (сужение ${math`f | _{[0,0)}`} пусто).
Тогда и на следующем элементе значение функции ${math`f`} определено однозначно, поскольку на предыдущих (точнее, единственном предыдущем) функция ${math`f`} уже задана, и т.д.


Конечно, это надо аккуратно выразить формально.
Вот как это делается.
Докажем по индукции такое утверждение о произвольном элементе ${math`a \\in A`}:


${i`
существует и единственно отображение ${math`f`} отрезка ${math`[0, a]`} в множество ${B}, для которого рекурсивное определение (равенство, приведённое в условии) выполнено при всех ${math`x \\in [0, a]`}.
`}


Будем называть отображение ${math`f: [0, a] \\to B`}, обладающее указанным свойством, ${i`корректным`}.
Таким образом, мы хотим доказать, что для каждого ${math`a \\in A`} есть единственное корректное отображение отрезка ${math`[0, a]`} в ${B}.


Поскольку мы рассуждаем по индукции, можно предполагать, что для всех ${math`c < a`} это утверждение выполнено, то есть существует и единственно корректное отображение ${math`f_c: [0, c] \\to B`}.
(Корректность ${math`f_c`} означает, что при всех ${math`d \\leqslant c`} значение ${math`f_c(d)`} совпадает с предписанным по рекурсивному правилу.)


Рассмотрим отображения ${math`f_{c_1}`} и ${math`f_{c_2}`} для двух различных ${math`c_1`} и ${math`c_2`}.
Пусть, например, ${math`c_1 < c_2`}.
Отображение ${math`f_{c_2}`} определено на большем отрезке ${math`[0, c_2]`}.
Если ограничить ${math`f_{c_2}`} на меньший отрезок ${math`[0, c_1]`}, то оно совпадёт с ${math`f_{c_1}`}, поскольку ограничение корректного отображения на меньший отрезок корректно (это очевидно), а мы предполагали единственность на отрезке ${math`[0, c_1]`}.


Таким образом, все отображения ${math`f_c`} согласованы друг с другом, то есть принимают одинаковое значение, если определены одновременно.
Объединив их, мы получаем некоторое единое отображение ${math`h`}, определённое на ${math`[0, a)`}.
Применив к ${math`a`} и ${math`h`} рекурсивное правило, получим некоторое значение ${math`b \\in B`}.
Доопределим ${math`h`} в точке ${math`a`}, положив ${math`h(a) = b`}.
Получится отображение ${math`h: [0, a] \\to B`}; легко понять, что оно корректно.


Чтобы завершить индуктивный переход, надо проверить, что на отрезке ${math`[0, a]`} корректное отображение единственно.
В самом деле, его ограничения на отрезки ${math`[0, c]`} при ${math`c < a`} должны совпадать с ${math`f_c`}, поэтому осталось проверить однозначность в точке ${math`a`} — что гарантируется рекурсивным определением
(выражающим значение в точке ${math`a`} через предыдущие).
На этом индуктивное доказательство заканчивается.


Осталось лишь заметить, что для разных ${math`a`} корректные отображения отрезков ${math`[0, a]`} согласованы друг с другом
(сужение корректного отображения на меньший отрезок корректно, применяем единственность)
и потому вместе задают некоторую функцию ${math`f: A \\to B`}, удовлетворяющую рекурсивному определению.


Существование доказано;
единственность тоже понятна, так как ограничение этой функции на любой отрезок ${math`[0, a]`} корректно и потому однозначно определено, как мы видели.
${proof.end}


Прежде чем применить эту теорему и доказать, что из двух вполне упорядоченных множеств одно является отрезком другого, нам потребуется её немного усовершенствовать.
Нам надо предусмотреть ситуацию, когда рекурсивное правило не всюду определено.
Пусть, например, мы определяем последовательность действительных чисел соотношением ${math`x_n = \\tg x_{n-1}`} и начальным условием ${math`x_0 = a`}.
При некоторых значениях ${math`a`} может оказаться, что построение последовательности обрывается, поскольку тангенс не определён для соответствующего аргумента.


${problem`Докажите, что множество всех таких «исключительных» ${math`a`} (когда последовательность конечна) счётно.`}


Аналогичная ситуация возможна и для общего случая.


${theorem.key(
    'recursive-rule'
)`Пусть отображение ${math`F`}, о котором шла речь в ${label.ref(
    'theorem_transfinite-recursion'
)`теореме ${n.theorem('transfinite-recursion')}`}, является частичным
(для некоторых элементов ${math`x`} и функций ${math`g: [0, x) \\to B`} оно может быть не определено).
Тогда существует функция ${math`f`}, которая
${start(list)}
${item`
либо определена на всём ${A} и согласована с рекурсивным определением;
`}
${item`
либо определена на некотором начальном отрезке ${math`[0, a)`} и на нём согласована с рекурсивным определением, причём для точки ${math`a`} и функции ${math`f`} рекурсивное правило неприменимо (отображение ${math`F`} не определено).
`}
${end(list)}
`}


${proof.start}
Это утверждение является обобщением, но одновременно и следствием предыдущей ${label.ref(
        'theorem_transfinite-recursion'
    )`теоремы ${n.theorem('transfinite-recursion')}`}.
В самом деле, добавим к множеству ${B} специальный элемент ${math`\\bot`} («неопределённость») и модифицируем рекурсивное правило: новое правило даёт значение ${math`\\bot`}, когда старое было не определено.
(Если среди значений функции на предыдущих аргументах уже встречалось ${math`\\bot`}, новое рекурсивное правило тоже даёт ${math`\\bot`}.)


Применив ${label.ref('theorem_transfinite-recursion')`теорему ${n.theorem(
        'transfinite-recursion'
    )}`} к модифицированному правилу, получим некоторую функцию ${math`f'`}.
Если эта функция нигде не принимает значения ${math`\\bot`}, то реализуется первая из двух возможностей, указанных в теореме (при ${math`f = f'`}).
Если же функция ${math`f'`} принимает значение ${math`\\bot`} в какой-то точке, то она имеет то же значение ${math`\\bot`} и во всех больших точках.
Заменив значение ${math`\\bot`} на неопределённость, мы получаем из функции ${math`f'`} функцию ${math`f`}.
Область определения функции ${math`f`} есть некоторый начальный отрезок ${math`[0, a)`} и реализуется вторая возможность, указанная в формулировке теоремы.
${proof.end}


${problem`Сформулируйте и докажите утверждение об однозначности функции, заданной частичным рекурсивным правилом.`}


Теперь у нас всё готово для доказательства теоремы о сравнении вполне упорядоченных множеств.


${theorem.key('A<>B')`
Пусть ${A} и ${B} — два вполне упорядоченных множества.
Тогда либо ${A} изоморфно некоторому начальному отрезку множества ${B}, либо ${B} изоморфно некоторому начальному отрезку множества ${A}.
`}


${proof.start}
Отметим прежде всего, что начальный отрезок может совпадать со всем множеством, так что случай изоморфных множеств ${A} и ${B} также покрывается этой теоремой.


Определим отображение ${math`f`} из ${A} в ${B} таким рекурсивным правилом: для любого ${math`a \\in A`}


${i`
${math`f(a)`} есть наименьший элемент множества ${B}, который не встречается среди ${math`f(a')`} при ${math`a' < a`}.
`}


Это правило не определено в том случае, когда значения ${math`f(a')`} при ${math`a' < a`} покрывают всё ${B}.
Применяя ${label.ref('theorem_recursive-rule')`теорему ${n.theorem(
        'recursive-rule'
    )}`}, мы получаем функцию ${math`f`}, согласованную с этим правилом.
Теперь рассмотрим два случая:
${start(list)}
${start(item)}
Функция ${math`f`} определена на всём ${A}.
Заметим, что рекурсивное определение гарантирует монотонность, поскольку ${math`f(a)`} определяется как минимальный ещё не использованный элемент;
чем больше ${math`a`}, тем меньше остаётся неиспользованных элементов и потому минимальный элемент может только возрасти
(из определения следует также, что одинаковых значений быть не может).
Остаётся лишь проверить, что множество значений функции ${math`f`}, то есть ${math`f(A)`}, будет начальным отрезком.
В самом деле, пусть ${math`b < f(a)`} для некоторого ${math`a \\in A`};
надо проверить, что ${math`b`} также является значением функции ${math`f`}.
Действительно, согласно рекурсивному определению ${math`f(a)`} является наименьшим неиспользованным значением, следовательно, ${math`b`} уже использовано, то есть встречается среди ${math`f(a')`} при ${math`a' < a`}.
${end(item)}
${start(item)}
Функция ${math`f`} определена лишь на некотором начальном отрезке ${math`[0, a)`}.
В этом случае этот начальный отрезок изоморфен ${B}, и функция ${math`f`} является искомым изоморфизмом.
В самом деле, раз ${math`f(a)`} не определено, то среди значений функции ${math`f`} встречаются все элементы множества ${B}.
С другой стороны, ${math`f`} сохраняет порядок в силу рекурсивного определения.
${end(item)}
${end(list)}
Таким образом, в обоих случаях утверждение теоремы верно.
${proof.end}


Может ли быть так, что ${A} изоморфно начальному отрезку ${B}, а ${B} изоморфно начальному отрезку ${A}?
Нет — за исключением тривиального случая, когда начальные отрезки представляют собой сами множества ${A} и ${B}.
Это вытекает из такого утверждения:


${theorem`Никакое вполне упорядоченное множество не изоморфно своему начальному отрезку (не совпадающему со всем множеством).`}


${proof.start}
Пусть вполне упорядоченное множество ${A} изоморфно своему начальному отрезку, не совпадающему со всем множеством.
Как мы видели ${label.ref(
        '[0,x)'
    )`ранее`} ${printNote`на с. 58`}, этот отрезок имеет вид ${math`[0, a)`} для некоторого элемента ${math`a \\in A`}.
Пусть ${math`f: A \\to [0, a)`} — изоморфизм.
Тогда ${math`f`} строго возрастает, и по ${label.ref(
        'theorem_f(x)>x'
    )`теореме ${n.theorem(
        'f(x)>x'
    )}`} имеет место неравенство ${math`f(a) > a`}, что противоречит тому, что множество значений функции ${math`f`} есть ${math`[0, a)`}.
${proof.end}


Если множество ${A} изоморфно начальному отрезку множества ${B}, а множество ${B} изоморфно начальному отрезку множества ${A}, то композиция этих изоморфизмов даёт изоморфизм между множеством ${A} и его начальным отрезком
(начальный отрезок начального отрезка есть начальный отрезок).
Этот начальный отрезок обязан совпадать со всем множеством ${A}, так что это возможно лишь если ${A} и ${B} изоморфны.


Сказанное позволяет сравнивать вполне упорядоченные множества.
Если ${A} изоморфно начальному отрезку множества ${B}, не совпадающему со всем ${B}, то говорят, что ${i`порядковый тип множества ${A} меньше порядкового типа множества ${B}`}.
Если множества ${A} и ${B} изоморфны, то говорят, что у них ${i`одинаковые порядковые типы`}.
Наконец, если ${B} изоморфно начальному отрезку множества ${A}, то говорят, что ${i`порядковый тип множества ${A} больше порядкового типа множества ${B}`}.
Мы только что доказали такое утверждение:


${theorem.key(
    'set-size'
)`Для любых вполне упорядоченных множеств ${A} и ${B} имеет место ровно один из указанных трёх случаев.`}


${problem.key('subset-init')`
Пусть ${A} — вполне упорядоченное множество, а ${B} — его подмножество с индуцированным порядком
(и, тем самым, тоже вполне упорядоченное множество).
Покажите, что ${B} изоморфно начальному отрезку ${A}.
Приведите пример, когда этот начальный отрезок совпадает со всем множеством ${A}, хотя ${math`B \\not = A`}.
(Указание. Если ${A} изоморфно собственному начальному отрезку множества ${B}, нарушается ${label.ref(
    'theorem_f(x)>x'
)`теорема ${n.theorem('f(x)>x')}`}.)
`}


Если временно забыть о проблемах оснований теории множеств и определить порядковый тип упорядоченного множества как класс изоморфных ему упорядоченных множеств, то можно сказать, что мы определили линейный порядок на порядковых типах вполне упорядоченных множеств (на ${i`ординалах`}, как говорят).
Этот порядок будет полным.
Мы переформулируем это утверждение так, чтобы избегать упоминания классов.


${theorem.key(
    'min-set'
)`Всякое непустое семейство вполне упорядоченных множеств имеет «наименьший элемент» — множество, изоморфное начальным отрезкам всех остальных множеств.`}


${proof.start}
Возьмём какое-то множество ${X} семейства.
Если оно наименьшее, то всё доказано.
Если нет, рассмотрим все множества семейства, которые меньше его, то есть изоморфны его начальным отрезкам вида ${math`[0, x)`}.
Среди всех таких элементов ${math`x`} выберем наименьший.
Тогда соответствующее ему множество и будет наименьшим.
${proof.end}


${problem`
Покажите, что для любого вполне упорядоченного множества ${A} существует равномощное ему вполне упорядоченное множество ${B} с таким свойством: любой начальный отрезок ${B} (кроме всего ${B}) имеет меньшую мощность, чем ${B}.
(Множества с этим свойством — точнее, их порядковые типы — называют ${i`кардиналами`}.)
`}


Из ${label.ref('theorem_set-size')`теоремы ${n.theorem(
        'set-size'
    )}`} следует, что любые два вполне упорядоченных множества сравнимы по мощности (одно равномощно подмножеству другого).
Сейчас мы увидим, что всякое множество может быть вполне упорядочено (${label.ref(
        'theorem_set-order'
    )`теорема Цермело`}), и, следовательно, любые два множества сравнимы по мощности.
`;
};

import { BookApi } from '@bookbox/preset-web';
import { getCustomElements } from '../../elements.js';

export default (api: BookApi) => {
    const { math, area, list, item, start, end, label, link } = api;

    const {paragraph, problem, A, B, n} = getCustomElements(api);

    return api.book`
${paragraph`Арифметика ординалов`}
Мы определили сумму и произведение линейно упорядоченных множеств в разделе ${link.ref('paragraph_equivalence-order')`${n.paragraph('equivalence-order')}`}.
(Напомним, что в ${math`A + B`} элементы ${A} предшествуют элементам ${B}, а в ${math`A \\times B`} мы сначала сравниваем ${B}-компоненты пар, а в случае их равенства — ${A}-компоненты.)


Легко проверить следующие свойства сложения:
${start(list)}
${item`
Сложение ассоциативно: ${math`\\alpha + (\\beta + \\gamma) = (\\alpha + \\beta) + \\gamma`}.
`}
${item`
Сложение не коммутативно: например, ${math`1 + \\omega = \\omega`}, но ${math`\\omega + 1 \\not = \\omega`}.
`}
${item`
Очевидно, ${math`\\alpha + 0 = 0 + \\alpha = \\alpha`}.
`}
${item`
Сумма возрастает при росте второго аргумента: если ${math`\\beta_1 < \\beta_2`}, то ${math`\\alpha + \\beta_1 < \\alpha + \\beta_2`}.
(В самом деле, пусть ${math`\\beta_1`} изоморфно начальному отрезку в ${math`\\beta_2`}, отличному от всего ${math`\\beta_2`}.
Добавим к этому изоморфизму тождественное отображение на ${math`\\alpha`} и получим изоморфизм между ${math`\\alpha + \\beta_1`} и начальным отрезком в ${math`\\alpha + \\beta_2`}, отличным от ${math`\\alpha + \\beta_2`}.)
`}
${item`
Сумма неубывает при росте первого аргумента: если ${math`\\alpha_1 < \\alpha_2`}, то ${math`\\alpha_1 + \\beta \\leqslant \\alpha_2 + \\beta`}.
(В самом деле, ${math`\\alpha_1 + \\beta`} изоморфно подмножеству в ${math`\\alpha_2 +\\beta`}.
Это подмножество не является начальным отрезком, но мы можем воспользоваться ${label.ref('theorem_subset-ordinal')`теоремой ${n.theorem('subset-ordinal')}`}.)
`}
${item`
Определение суммы согласовано с обозначением ${math`\\alpha + 1`} для следующего за ${math`\\alpha`} ординала.
(Здесь ${math`1`} — порядковый тип одноэлементного множества.)
Следующим за ${math`\\alpha + 1`} ординалом будет ординал ${math`(\\alpha + 1) + 1 = \\alpha + (1 + 1) = \\alpha + 2`} и т.д.
`}
${item`
Если ${math`\\alpha \\geqslant \\beta`}, то существует единственный ординал ${math`\\gamma`}, для которого ${math`\\beta + \\gamma = \\alpha`}.
(В самом деле, ${math`\\beta`} изоморфно начальному отрезку в ${math`\\alpha`}; оставшаяся часть ${math`\\alpha`} и будет искомым ординалом ${math`\\gamma`}.
Единственность следует из монотонности сложения по второму аргументу.)
Заметим, что эту операцию можно называть «вычитанием слева».
`}
${item`
«Вычитание справа», напротив, возможно не всегда.
Пусть ${math`\\alpha`} — некоторый ординал.
Тогда уравнение ${math`\\beta + 1 = \\alpha`} (относительно ${math`\\beta`}) имеет решение тогда и только тогда, когда ${math`\\alpha`} — непредельный ординал, (т.е. когда ${math`\\alpha`} имеет наибольший элемент).
`}
${end(list)}
Определение суммы двух ординалов в силу ассоциативности можно распространить на любое конечное число ординалов.
Можно определить и сумму ${math`\\alpha_1 + \\alpha_2 + \\dots`} счётной последовательности ординалов (элементы ${math`\\alpha_i`} предшествуют элементам ${math`\\alpha_j`} при ${math`i < j`}; внутри каждого ${math`\\alpha_i`} порядок прежний).
Как легко проверить, это множество действительно будет вполне упорядоченным: чтобы найти минимальный элемент в его подмножестве, рассмотрим компоненты, которые это подмножество задевает, выберем из них компоненту с наименьшим номером и воспользуемся её полной упорядоченностью.


В этом построении можно заменить натуральные числа на элементы произвольного вполне упорядоченного множества ${math`I`} и определить сумму ${math`\\sum A_i`} семейства вполне упорядоченных множеств ${math`A_i`}, индексированного элементами ${math`I`}, как порядковый тип множества всех пар вида ${math`\\lang a, i \\rang`}, для которых ${math`a \\in A_i`}.
При сравнении пар сравниваются вторые компоненты, а в случае равенства и первые (в соответствующем ${math`A_i`}).
Если все ${math`A_i`} изоморфны одному и тому же множеству ${A}, получаем уже известное нам определение произведения ${math`A \\times I`}.


Теперь перейдём к умножению ординалов.
${start(list)}
${item`
Умножение ассоциативно: ${math`(\\alpha\\beta)\\gamma = \\alpha(\\beta\\gamma)`}.
(В самом деле, в обоих случаях по существу получается множество троек; тройки сравниваются справа налево, пока не обнаружится различие.)
`}
${item`
Умножение не коммутативно: например, ${math`2 \\cdot \\omega = \\omega`}, в то время как ${math`\\omega \\cdot 2 \\not = \\omega`}.
`}
${item`
Очевидно, ${math`\\alpha \\cdot 0 = 0 \\cdot \\alpha = 0`} и ${math`\\alpha \\cdot 1 = 1 \\cdot \\alpha = \\alpha`}.
`}
${item`
Выполняется одно из свойств дистрибутивности: ${math`\\alpha(\\beta + \\gamma) = \\alpha\\beta + \\alpha\\gamma`} (непосредственно следует из определения).
Симметричное свойство выполнено не всегда: ${math`(1 + 1) \\cdot \\omega = \\omega \\not= \\omega + \\omega`}.
`}
${item`
Произведение строго возрастает при увеличении второго множителя, если первый не равен ${math`0`}.
(Для разнообразия выведем это из ранее доказанных свойств: если ${math`\\beta_2 > \\beta_1`}, то ${math`\\beta_2 = \\beta_1 + \\delta`}, так что ${math`\\alpha\\beta_2 = \\alpha(\\beta_1 + \\delta) = \\alpha\\beta_1 + \\alpha\\delta > \\alpha\\beta_1`}.)
`}
${item`
Произведение не убывает при возрастании первого множителя.
(В самом деле, если ${math`\\alpha_1 < \\alpha_2`}, то ${math`\\alpha_1\\beta`} изоморфно подмножеству ${math`\\alpha_2\\beta`}.
Это подмножество не является начальным отрезком, но можно сослаться на ${label.ref('theorem_subset-ordinal')`теорему ${n.theorem('subset-ordinal')}`}.)
`}
${item`
${start(area.key('ord_lin-sum'))}
Любой ординал, меньший ${math`\\alpha\\beta`}, однозначно представим в виде ${math`\\alpha\\beta' + \\alpha'`}, где ${math`\\beta' < \\beta`} и ${math`\\alpha' < \\alpha`}.
${end(area)}


(В самом деле, пусть множества ${A} и ${B} упорядочены по типам ${math`\\alpha`} и ${math`\\beta`}.
Тогда ${math`A \\times B`} упорядочено по типу ${math`\\alpha\\beta`}.
Всякий ординал, меньший ${math`\\alpha\\beta`}, есть начальный отрезок в ${math`A \\times B`}, ограниченный некоторым элементом ${math`\\lang a, b \\rang`}.
Начальный отрезок ${math`[0, \\lang a, b \\rang)`} состоит из пар, у которых второй член меньше ${math`b`}, а также из пар, у которых второй член равен ${math`b`}, а первый меньше ${math`a`}.
Отсюда следует, что этот начальный отрезок изоморфен ${math`A \\times [0, b) + [0, a)`}, так что остаётся положить ${math`\\beta' = [0, b)`} и ${math`\\alpha' = [0, a)`}.
Теперь проверим однозначность.
Пусть ${math`\\alpha\\beta' +\\alpha' = \\alpha\\beta'' +\\alpha''`}.
Если ${math`\\beta' = \\beta''`}, то можно воспользоваться однозначностью левого вычитания и получить, что ${math`\\alpha' = \\alpha''`}.
Остаётся проверить, что ${math`\\beta'`} не может быть, скажем, меньше ${math`\\beta''`}.
В этом случае ${math`\\beta'' = \\beta' + \\delta`}, и сокращая ${math`\\alpha\\beta'`} слева, получим, что ${math`\\alpha' = \\alpha\\delta + \\alpha''`}, что невозможно, так как левая часть меньше ${math`\\alpha`}, а правая часть больше или равна ${math`\\alpha`}.)
`}
${item`
Аналогичное «деление с остатком» возможно и для любых ординалов.
Пусть ${math`\\alpha > 0`}.
Тогда любой ординал ${math`\\gamma`} можно разделить с остатком на ${math`\\alpha`}, то есть представить в виде ${math`\\alpha\\tau + \\rho`}, где ${math`\\rho < \\alpha`}, и притом единственным образом.


(В самом деле, существование следует из предыдущего утверждения, надо только взять достаточно большое ${math`\\beta`}, чтобы ${math`\\alpha\\beta`} было больше ${math`\\gamma`}, скажем, ${math`\\beta = \\gamma + 1`}.
Единственность доказывается так же, как и в предыдущем пункте.)
`}
${item`
${area.key('ordinal-position')`Повторяя деление с остатком на ${math`\\alpha > 0`}, можно построить позиционную систему счисления для ординалов: всякий ординал, меньший ${math`\\alpha^{k+1}`} (здесь ${math`k`} — натуральное число), можно однозначно представить в виде ${math`\\alpha^k\\beta_k + \\alpha^{k-1}\\beta_{k-1} + \\ldots + \\alpha\\beta_1 + \\beta_0`}, где «цифры» ${math`\\beta_k, \\ldots , \\beta_1, \\beta_0`} — ординалы, меньшие ${math`\\alpha`}.`}
`}
${end(list)}

${problem`Для каких ординалов ${math`1 + \\alpha = \\alpha`}?`}


${problem`Для каких ординалов ${math`2 \\cdot \\alpha = \\alpha`}?`}


${problem`Какие ординалы представимы в виде ${math`\\omega \\cdot \\alpha`}?`}


${problem`
Докажите, что ${math`\\alpha + \\beta = \\beta`} тогда и только тогда, когда ${math`\\alpha\\omega \\leqslant \\beta`}
(здесь ${math`\\alpha`} и ${math`\\beta`} — ординалы).
`}


${problem`
Докажите, что если ${math`\\alpha + \\beta = \\beta + \\alpha`} для некоторых ординалов ${math`\\alpha`} и ${math`\\beta`}, то найдётся такой ординал ${math`\\gamma`} и такие натуральные числа ${math`m`} и ${math`n`}, что ${math`\\alpha = \\gamma m`} и ${math`\\beta = \\gamma n`}.
`}


${problem`
Определим операцию «замены основания» с ${math`k > 1`} на ${math`l > k`}.
Чтобы применить эту операцию к натуральному числу ${math`n`}, надо записать ${math`n`} в ${math`k`}-ичной системе счисления, а затем прочесть эту запись в ${math`l`}-ичной системе.
(Очевидно, число при этом возрастёт, если оно было больше или равно ${math`k`}.)
Возьмём произвольное число ${math`n`} и будет выполнять над ним такие операции: замена основания с ${math`2`} на ${math`3`} – вычитание единицы – замена основания с ${math`3`} на ${math`4`} – вычитание единицы – замена основания с ${math`4`} на ${math`5`} – вычитание единицы – ${math`\\dots`}
Докажите, что рано или поздно мы получим нуль и вычесть единицу не удастся.
(Указание: замените все основания на ординал ${math`\\omega`}; получится убывающая последовательность ординалов.)
`}
`;
};

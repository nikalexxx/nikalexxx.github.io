[
  "\n\nЛЕКЦИИ ПО МАТЕМАТИЧЕСКОЙ ЛОГИКЕ И ТЕОРИИ АЛГОРИТМОВ\n\n\n",
  {
    "name": "authors",
    "props": {},
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "http://lpcs.math.msu.su/~ver/"
        },
        "children": [
          "Н. К. Верещагин"
        ]
      },
      ",\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Шень,_Александр_Ханиевич"
        },
        "children": [
          "А.Шень"
        ]
      },
      "\n"
    ]
  },
  "\n",
  {
    "name": "title",
    "props": {},
    "children": [
      "Начала теории множеств"
    ]
  },
  "\n\n\n",
  "\n",
  "\n            ",
  {
    "name": "area",
    "props": {},
    "children": [
      "\n            ",
      {
        "name": "header",
        "props": {
          "level": 2
        },
        "children": [
          "Предисловие к электронному изданию"
        ]
      },
      "\n            "
    ]
  },
  "\n            ",
  "\nИздание от 10.02.2021. Основано на ",
  {
    "name": "link",
    "props": {
      "href": "https://www.mccme.ru/shen/logic/sets/part1-6ed.pdf"
    },
    "children": [
      "шестом издании"
    ]
  },
  " печатной версии 2020 года.\n\n\nВ электронном издании в силу особенностей формата отсутствует жёсткая нумерация страниц.\nПоэтому в тех местах, где в печатном издании указывается страница\n(например для указания места данного раннего определения и т.д.),\nпо клику показывается предупреждение об отсутствии страниц, причем рядом есть ссылка на нужное место по другому слову.\nИногда для таких целей добавляется слово «ранее».\nЕсли номер страницы был рядом с другой сущностью(теоремой или разделом), которая позволяет однозначно определить место, номер страницы опускается.\nВ остальном текст передан без изменений.\n\n\nВ текущем издании также отсутствует предметный указатель.\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Николаичев А.С."
    ]
  },
  "\n",
  "\n\n\n",
  "\n",
  "\n            ",
  {
    "name": "area",
    "props": {},
    "children": [
      "\n            ",
      {
        "name": "header",
        "props": {
          "level": 2
        },
        "children": [
          "Предисловие"
        ]
      },
      "\n            "
    ]
  },
  "\n            ",
  "\nПредлагаемая вашему вниманию книга написана по материалам лекций для младшекурсников, которые читались авторами в разные годы на механико-математическом факультете МГУ.\n(В эту же серию входят книги «Языки и исчисления» и «Вычислимые функции».)\n\n\nОсновные понятия теории множеств (мощности, трансфинитная индукция, ординалы) входят в число вещей, которые хорошо бы знать любому грамотному математику (даже если он не является математическим логиком или общим топологом).\nОбычно про них коротко пишут в первых главах учебников анализа, алгебры или топологии, спеша перейти к основной теме книги.\nА жаль — предмет достаточно интересен, важен и прост, чтобы рассказать о нём не торопясь.\n\n\nИменно такой популярный рассказ мы пытались написать, имея в виду самых разных читателей: от подготовленного школьника (захотевшего перейти от побед на олимпиадах к чему-то более осмысленному) до профессионального математика (решившего прочитать по дороге на отдых, что же такое трансфинитная индукция, которую всегда заменяют леммой Цорна).\nДля более подробного знакомства с теорией множеств читатель может обратиться к другим книгам (некоторые из них перечислены в ",
  {
    "name": "link",
    "props": {
      "ref": "lib"
    },
    "children": [
      "списке литературы"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "с. 105"
    ]
  },
  ").\n\n\nАвторы пользуются случаем поблагодарить своего учителя, Владимира Андреевича Успенского, лекции, тексты и высказывания которого повлияли на них (и на содержание этой книги), вероятно, даже в большей степени, чем авторы это осознают.\n\n\nПри подготовке текста использованы записи А. Евфимьевского и А. Ромащенко (который также прочёл предварительный вариант книги и нашёл там немало ошибок).\n\n\n",
  "Оригинал-макет книги был подготовлен В. В.Шуваловым; без его настойчивости (вплоть до готовности разделить ответственность за ошибки) оригинал-макет вряд ли появился бы к какому-либо сроку.",
  "\n\n\nАвторы признательны Ecole Normale Supe´rieure de Lyon (Франция) за поддержку и гостеприимство во время написания этой книги.\n\n\nПервое издание книги стало возможным благодаря Российскому фонду фундаментальных исследований, а также И. В. Ященко, который уговорил авторов подать туда заявку.\n\n\nНаконец, мы благодарим сотрудников, аспирантов и студентов кафедры математической логики мехмата МГУ, а также всех участников наших лекций и семинаров и читателей предварительных вариантов этой книги.\n\n\nПросим сообщать о всех ошибках и опечатках авторам (электронные адреса ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "ver"
    ]
  },
  " at ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "mccme"
    ]
  },
  " dot ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "ru"
    ]
  },
  ", ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "nikolay"
    ]
  },
  " dot ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "vereshchagin"
    ]
  },
  " at ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "gmail"
    ]
  },
  " dot ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "com"
    ]
  },
  "; ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "sasha"
    ]
  },
  " dot ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "shen"
    ]
  },
  " at ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "gmail"
    ]
  },
  " dot ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "com"
    ]
  },
  ", ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "alexander"
    ]
  },
  " dot ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "shen"
    ]
  },
  " at ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "lirmm"
    ]
  },
  " dot ",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "fr"
    ]
  },
  "; почтовый адрес: Москва, 119002, Большой Власьевский пер., 11, Московский центр непрерывного математического образования).\n\n\nВо втором издании исправлено несколько ошибок и добавлено несколько новых задач.\nВ третьем издании был дополнен именной указатель и восстановлен предметный указатель. пропущенный во втором издании по вине авторов.\nВ четвёртом издании (помимо изменения формата вёрстки и использования шрифтов LH) сделаны небольшие добавления, в основном связанные с аксиомой выбора.\nПятое издание печатается без существенных изменений.\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "Н. К. Верещагин, А.Шень"
    ]
  },
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "chapter_sets",
      "meta": {
        "n": 1,
        "longN": "1"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 2
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1"
            ]
          },
          ". ",
          "Множества и мощности",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_1",
      "meta": {
        "n": 1,
        "longN": "1.1"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.1"
            ]
          },
          ". ",
          "Множества",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nОсновные понятия и обозначения, связанные с множествами и операциями над ними:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Множества"
            ]
          },
          " состоят из ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "элементов"
            ]
          },
          ". Запись ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\in M"
            ]
          },
          " означает, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " является элементом множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "M"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nГоворят, что множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " является ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "подмножеством"
            ]
          },
          " множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " (запись: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\sub B"
            ]
          },
          "), если все элементы ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " являются элементами ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "равны"
            ]
          },
          " (запись: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A = B"
            ]
          },
          "), если они содержат\nодни и те же элементы (другими словами, если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\sub B"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B \\sub A"
            ]
          },
          ").\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " — подмножество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", не равное всему ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " называют\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "собственным"
            ]
          },
          " подмножеством ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " (запись: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\subsetneq B"
            ]
          },
          ").\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Пустое"
            ]
          },
          " множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\varnothing"
            ]
          },
          " не содержит ни одного элемента и является подмножеством любого множества.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Пересечение"
            ]
          },
          " ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\cap B"
            ]
          },
          " двух множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " состоит из элементов, которые принадлежат обоим множествам ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ".\nЭто записывают так:\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "A \\cap B = \\{x\\, | \\, x \\in A \\, \\text{и} \\, x \\in B\\}"
            ]
          },
          "\n(читается: множество таких ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ", что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\dots"
            ]
          },
          ").\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Объединение"
            ]
          },
          " ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\cup B"
            ]
          },
          " состоит из элементов, которые принадлежат\nхотя бы одному из множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ":\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "A \\cup B = \\{x\\, | \\, x \\in A \\, \\text{или} \\, x \\in B\\}"
            ]
          },
          "\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Разность"
            ]
          },
          " ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\setminus B"
            ]
          },
          " состоит из элементов, которые принадлежат ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ",\nно не принадлежат ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ":\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "A \\setminus B = \\{x\\, | \\, x \\in A \\, \\text{и} \\, x \\notin B\\}"
            ]
          },
          "\nЕсли множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " является подмножеством множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", разность ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\setminus B"
            ]
          },
          " называют также ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "дополнением"
            ]
          },
          " ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " до ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Симметрическая разность"
            ]
          },
          " ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\vartriangle B"
            ]
          },
          " состоит из элементов, которые принадлежат ровно одному из множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ":\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "A \\vartriangle B = (A \\setminus B) \\cup (B \\setminus A) = (A \\cup B) \\setminus (A \\cap B)."
            ]
          },
          "\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЧерез ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{a, b, c\\}"
            ]
          },
          " обозначается множество, которое содержит элементы ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a, b, c"
            ]
          },
          " и не содержит других.\nЕсли среди ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a, b, c"
            ]
          },
          " есть равные, оно может содержать один или два элемента.\nПодобное обозначение используется и в менее формальных ситуациях: множество членов последовательности ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a_0, a_1, \\dots"
            ]
          },
          " обозначается ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{a_0, a_1, \\dots\\}"
            ]
          },
          " или даже ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{a_i\\}"
            ]
          },
          ".\nБолее аккуратная запись для того же множества такова: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{a_i\\, | \\,i \\in \\N\\}"
            ]
          },
          ", где\n",
          {
            "name": "area",
            "props": {
              "key": "set.N",
              "inline": true
            },
            "children": [
              "\n",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\N"
                ]
              },
              " — множество натуральных чисел ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\{0, 1, 2, \\dots\\}"
                ]
              },
              "\n"
            ]
          },
          "\n.\n"
        ]
      },
      "\n"
    ]
  },
  "\n\nПонятие множества появилось в математике сравнительно недавно, в конце 19-го века, в связи с работами ",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Кантора"
    ]
  },
  " (сравнение мощностей множеств), о которых пойдёт речь дальше (раздел ",
  {
    "name": "link",
    "props": {
      "ref": "paragraph_equivalence-order"
    },
    "children": [
      "",
      {
        "name": "use",
        "props": {
          "ref": "paragraph_equivalence-order",
          "path": "longN"
        },
        "children": []
      },
      ""
    ]
  },
  " и следующие).\nНекоторое время назад этот язык пытались внедрить в школьное преподавание, объясняя ученикам, что у уравнения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x^2 + 1 = 0"
    ]
  },
  " есть множество решений (впрочем, пустое), что множество решений системы уравнений есть пересечение множеств решений каждого из них (а для «совокупности» уравнений — объединение),\nчто в множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{2, 2, 3\\}"
    ]
  },
  " не три элемента, а два,\nи оно равно множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{2, 3\\}"
    ]
  },
  ", что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "",
      "\\varnothing",
      ""
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{",
      "\\varnothing",
      "\\}"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{",
      "\\varnothing",
      ", \\{",
      "\\varnothing",
      "\\}\\}"
    ]
  },
  " — это три совершенно разных множества и т. д.\nНо всё равно большинство школьников так и не поняло, почему множество решений уравнения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x^2 = 4"
    ]
  },
  " можно записывать как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{-2, 2\\}"
    ]
  },
  ", а множество решений уравнения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x^2 = -4"
    ]
  },
  " нельзя записывать как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{",
      "\\varnothing",
      "\\}"
    ]
  },
  " (а надо писать ",
  {
    "name": "math",
    "props": {},
    "children": [
      "",
      "\\varnothing",
      ""
    ]
  },
  ").\nОтметим кстати ещё два расхождения: в школе натуральные числа начинаются с единицы, а в некоторых книжках — с нуля (мы тоже будем называть нуль натуральным числом).\nКроме того, иногда вместо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sub"
    ]
  },
  " пишут ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sube"
    ]
  },
  ", используя ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sub"
    ]
  },
  " для собственных подмножеств (вместо нашего ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\subsetneq"
    ]
  },
  ").\n\n\nМы предполагаем, что перечисленные выше основные понятия теории множеств более или менее вам знакомы, и будем достаточно свободно ими пользоваться.\nВот несколько задач для самоконтроля;\nнадеемся, что большинство из них не представит для вас большого труда.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_1",
      "meta": {
        "n": 1
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1"
            ]
          },
          ". ",
          "\nСтарейший математик среди шахматистов и старейший шахматист среди математиков — это один или тот же человек или (возможно) разные?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_2",
      "meta": {
        "n": 2
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2"
            ]
          },
          ". ",
          "\nЛучший математик среди шахматистов и лучший шахматист среди математиков — это один или тот же человек или (возможно) разные?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_3",
      "meta": {
        "n": 3
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "3"
            ]
          },
          ". ",
          "\nКаждый десятый математик — шахматист, а каждый шестой шахматист — математик. Кого больше — математиков или шахматистов — и во сколько раз?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_4",
      "meta": {
        "n": 4
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "4"
            ]
          },
          ". ",
          "\nСуществуют ли такие множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ", что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\cap B \\not = ",
              "\\varnothing",
              ""
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\cap C = ",
              "\\varnothing",
              ""
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(A \\cap B) \\setminus C = ",
              "\\varnothing",
              ""
            ]
          },
          "?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_5",
      "meta": {
        "n": 5
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "5"
            ]
          },
          ". ",
          "\nКакие из равенств\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "а"
            ]
          },
          ") ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(A \\cap B) \\cup C = (A \\cup C) \\cap (B \\cup C)"
            ]
          },
          ";\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "б"
            ]
          },
          ") ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(A \\cup B) \\cap C = (A \\cap C) \\cup (B \\cap C)"
            ]
          },
          ";\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "в"
            ]
          },
          ") ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(A \\cup B) \\setminus C = (A \\setminus C) \\cup B"
            ]
          },
          ";\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "г"
            ]
          },
          ") ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(A \\cap B) \\setminus C = (A \\setminus C) \\cap B"
            ]
          },
          ";\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "д"
            ]
          },
          ") ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\setminus (B \\cup C) = (A \\setminus B) \\cap (A \\setminus C)"
            ]
          },
          ";\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "е"
            ]
          },
          ") ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\setminus (B \\cap C) = (A \\setminus B) \\cup (A \\setminus C)"
            ]
          },
          " верны для любых множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          "?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_6",
      "meta": {
        "n": 6
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "6"
            ]
          },
          ". ",
          "\nПроведите подробное доказательство верных равенств предыдущей задачи, исходя из определений.\n(Докажем, что множества в левой и правой частях равны. Пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " — любой элемент левой части равенства.\nТогда ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\dots"
            ]
          },
          "\nПоэтому ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " входит в правую часть.\nОбратно, пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\dots"
            ]
          },
          " )\nПриведите контрпримеры к неверным равенствам.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_7",
      "meta": {
        "n": 7
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "7"
            ]
          },
          ". ",
          "\nДокажите, что операция «симметрическая разность» ассоциативна: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A ",
              "\\vartriangle",
              " (B ",
              "\\vartriangle",
              " C) = (A ",
              "\\vartriangle",
              " B) ",
              "\\vartriangle",
              " C"
            ]
          },
          " для любых ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ".\n(Указание: сложение по модулю 2 ассоциативно.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_8",
      "meta": {
        "n": 8
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "8"
            ]
          },
          ". ",
          "\nДокажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(A_1 \\cap \\dots \\cap A_n) ",
              "\\vartriangle",
              " (B_1 \\cap \\dots \\cap B_n) \\in (A_1 ",
              "\\vartriangle",
              " B_1) \\cup \\dots \\cup (A_n ",
              "\\vartriangle",
              " B_n)"
            ]
          },
          " для любых множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A_1, \\dots\\ , A_n"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B_1, \\dots\\ , B_n"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_9",
      "meta": {
        "n": 9
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "9"
            ]
          },
          ". ",
          "\nДокажите, что если какое-то равенство (содержащее переменные для множеств и операции ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\cap , \\cup , \\setminus"
            ]
          },
          ") неверно, то можно найти контрпример к нему, в котором множества пусты или состоят из одного элемента.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_10",
      "meta": {
        "n": 10
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "10"
            ]
          },
          ". ",
          "\nСколько различных выражений для множеств можно составить из переменных ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " с помощью (многократно используемых) операций пересечения, объединения и разности?\n(Два выражения считаются одинаковыми, если они равны при любых значениях переменных.)\nТот же вопрос для трёх множеств и для ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " множеств.\n(Ответ в общем случае: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2^{2^n - 1}"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_11",
      "meta": {
        "n": 11
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "11"
            ]
          },
          ". ",
          "\nТот же вопрос, если используются только операции ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\cup"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\cap"
            ]
          },
          ".\n(Для двух и трёх переменных это число несложно подсчитать, но общей формулы для ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " переменных не известно.\nЭту задачу называют также задачей о числе монотонных булевых функций от ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " аргументов.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_12",
      "meta": {
        "n": 12
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "12"
            ]
          },
          ". ",
          "Сколько существует подмножеств у ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          "-элементного множества?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_13",
      "meta": {
        "n": 13
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "13"
            ]
          },
          ". ",
          "\nПусть множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " содержит ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " элементов, а его подмножество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " содержит ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          " элементов.\nСколько существует множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ", для которых ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B \\sub C \\sub A"
            ]
          },
          "?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_max-sub-size",
      "meta": {
        "n": 14
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "14"
            ]
          },
          ". ",
          "\nМножество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          " содержит ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2n"
            ]
          },
          " элементов.\nВ нём выделено ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          " подмножеств, причём ни одно из них не является подмножеством другого.\nКаково может быть максимальное значение числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "?\n(Указание. Максимум достигается, когда все подмножества имеют по ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " элементов.\nВ самом деле, представим себе, что мы начинаем с пустого множества и добавляем по одному элементу, пока не получится множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          ".\nВ ходе такого процесса может появиться не более одного выделенного множества;\nс другой стороны, можно подсчитать математическое ожидание числа выделенных множеств по линейности; вероятность пройти через данное множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Z \\sub U"
            ]
          },
          " минимальна, когда ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Z"
            ]
          },
          " содержит ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " элементов, поскольку все множества данного размера равновероятны.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_2",
      "meta": {
        "n": 2,
        "longN": "1.2"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.2"
            ]
          },
          ". ",
          "Число элементов",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nЧисло элементов в конечном множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " называют также его мощностью и обозначают ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A|"
    ]
  },
  " (а также ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\#A"
    ]
  },
  ").\n(Вскоре мы будем говорить о мощностях и для бесконечных множеств.)\nСледующая формула позволяет найти мощность объединения нескольких множеств, если известны мощности каждого из них, а также мощности всех пересечений.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_set_and_or",
      "meta": {
        "n": 1
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 1 (Формула включений и исключений)"
        ]
      },
      ". ",
      "\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{aligned}\n|A \\cup B| &= |A| + |B| - |A \\cap B|; \\\\\n|A \\cup B \\cup C| &= |A| + |B| + |C| - \\\\\n&- |A \\cap B| - |A \\cap C| - |B \\cap C| + \\\\\n&+ |A \\cap B \\cap C|;\n\\end{aligned}\n"
        ]
      },
      "\n\nвообще ",
      {
        "name": "math",
        "props": {},
        "children": [
          "|A_1 \\cup \\dots \\cup A_n|"
        ]
      },
      " равно\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\sum_{i} |A_i| - \\sum_{i<j} |A_i \\cap A_j| + \\sum_{i<j<k} |A_i \\cap A_j \\cap A_k| - \\dots\n"
        ]
      },
      "\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nЭто утверждение несложно доказать индукцией по ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  ", но мы приведём другое доказательство.\nФиксируем произвольное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  ", подмножествами которого являются множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1, \\dots , A_n"
    ]
  },
  ".\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "Характеристической функцией"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X \\sub U"
    ]
  },
  " называют функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\chi_X"
    ]
  },
  ", которая равна ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1"
    ]
  },
  " на элементах ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  " на остальных элементах ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  ".\nОперации над подмножествами множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  " соответствуют операциям с их характеристическими функциями.\nВ частности, пересечению множеств соответствует произведение характеристических функций: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\chi_{A \\cap B}(u) = \\chi_A(u)\\chi_B(u)"
    ]
  },
  ".\nДополнению (до ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  ") соответствует функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1 - \\chi"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\chi"
    ]
  },
  " — характеристическая\nфункция исходного множества.\n\n\nЧисло элементов множества можно записать как сумму значений его характеристической функции:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "|X| = \\sum_u \\chi_X(u)."
    ]
  },
  "\nОбъединение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1 \\cup \\dots \\cup A_N"
    ]
  },
  " можно записать как дополнение к пересечению дополнений множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  ";\nв терминах характеристических функций имеем\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\chi_{A_1 \\cup \\ldots \\cup A_n} = 1 - (1 - \\chi_{A_1}) \\dots (1 - \\chi_{A_n}).\n"
    ]
  },
  "\nРаскрыв скобки в правой части, мы получим\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\sum_i \\chi_{A_i} - \\sum_{i<j} \\chi_{A_i}\\chi_{A_j} + \\sum_{i<j<k} \\chi_{A_i} \\chi_{A_j} \\chi_{A_k} - \\dots\n"
    ]
  },
  "\nи просуммировав левую и правую часть по всем элементам ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  " (обе они есть функции на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  "), получим формулу включений и исключений.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_15",
      "meta": {
        "n": 15
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "15"
            ]
          },
          ". ",
          "\nДокажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "|A_1 ",
              "\\vartriangle",
              " \\dots ",
              "\\vartriangle",
              " A_n|"
            ]
          },
          " равно\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n\\sum_{i} |A_i| - 2 \\sum_{i<j} |A_i \\cap A_j| + 4 \\sum_{i<j<k} |A_i \\cap A_j \\cap A_k| - \\dots\n"
            ]
          },
          "\n(коэффициенты — последовательные степени двойки).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nПодсчёт количеств элементов в конечных множествах относят к ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "комбинаторике"
    ]
  },
  ".\nНекоторые начальные сведения из комбинаторики приведены дальше в качестве задач.\nСейчас нас в первую очередь интересует следующий принцип:\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "если между двумя множествами можно установить взаимно однозначное соответствие, то в них одинаковое число элементов."
    ]
  },
  "\n\n\n(Взаимная однозначность требует, чтобы каждому элементу первого множества соответствовал ровно один элемент второго и наоборот.)\n\n\nВот несколько примеров использования этого принципа.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_16",
      "meta": {
        "n": 16
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "16"
            ]
          },
          ". ",
          "\nНа окружности выбраны 1000 белых точек и одна чёрная.\nЧего больше — треугольников с вершинами в белых точках или четырёхугольников, у которых одна вершина чёрная, а остальные три белые?\n(Решение: их поровну, поскольку каждому четырёхугольнику соответствует треугольник, образованный тремя его белыми вершинами.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_17",
      "meta": {
        "n": 17
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "17"
            ]
          },
          ". ",
          "\nКаких подмножеств больше у 100-элементного множества: мощности 57 или мощности 43?\n(Указание: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "57 + 43 = 100"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_18",
      "meta": {
        "n": 18
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "18"
            ]
          },
          ". ",
          "\nДокажите, что последовательностей длины ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          ", составленных из нулей и единиц, столько же, сколько подмножеств у множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{1, 2, \\dots , n\\}"
            ]
          },
          ".\n(Указание: каждому подмножеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X \\sub \\{1, 2, \\dots , n\\}"
            ]
          },
          " соответствует «характеристическая последовательность», на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "i"
            ]
          },
          "-м месте которой стоит единица, если и только если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "i \\in X"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_19",
      "meta": {
        "n": 19
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "19"
            ]
          },
          ". ",
          "\nДокажите, что последовательностей нулей и единиц длины ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          ", в которых число единиц равно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          ", равно числу ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "-элементных подмножеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          "-элементного множества.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЭто число называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "числом сочетаний из ",
      {
        "name": "math",
        "props": {},
        "children": [
          "n"
        ]
      },
      " по ",
      {
        "name": "math",
        "props": {},
        "children": [
          "k"
        ]
      },
      ""
    ]
  },
  " и обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C^k_n"
    ]
  },
  " в русских книжках;\nв иностранных обычно используется обозначение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\binom{n}{k}"
    ]
  },
  "\n\u0001\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_20",
      "meta": {
        "n": 20
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "20"
            ]
          },
          ". ",
          "Докажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C^k_n = C^{n-k}_n"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_21",
      "meta": {
        "n": 21
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "21"
            ]
          },
          ". ",
          "Докажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C^0_n + C^1_n + \\ldots + C^n_n = 2^n"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_22",
      "meta": {
        "n": 22
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "22"
            ]
          },
          ". ",
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          " — непустое конечное множество.\nДокажите, что подмножеств множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          ", имеющих чётную мощность, столько же, сколько имеющих нечётную мощность.\n(Указание: фиксируем элемент ",
          {
            "name": "math",
            "props": {},
            "children": [
              "u \\in U"
            ]
          },
          " и объединим в пары подмножества, отличающиеся только в точке ",
          {
            "name": "math",
            "props": {},
            "children": [
              "u"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_23",
      "meta": {
        "n": 23
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "23"
            ]
          },
          ". ",
          "\nДокажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C^0_n - C^1_n + C^2_n - \\ldots + (-1)^n C^n_n = 0"
            ]
          },
          ".\n(Указание: как это связано с предыдущей задачей?)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_24",
      "meta": {
        "n": 24
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "24"
            ]
          },
          ". ",
          "Докажите формулу ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "бинома ",
              {
                "name": "label",
                "props": {
                  "ref": "name_newton"
                },
                "children": [
                  "Ньютона"
                ]
              },
              ""
            ]
          },
          "\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n(a + b)^n = C^0_n a^n + C^1_n a^{n - 1} b + \\ldots + C^k_n a^{n - k} b^k + \\ldots + C^n_n b^n .\n"
            ]
          },
          "\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_25",
      "meta": {
        "n": 25
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "25"
            ]
          },
          ". ",
          "Докажите, что способов расстановки скобок (указывающих порядок действий) в неассоциативном произведении из ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " элементов столько же, сколько способов разбить выпуклый ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(n + 1)"
            ]
          },
          "-угольник на треугольники непересекающимися диагоналями.\n(Для произведения трёх множителей есть два варианта ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(ab)c"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a(bc)"
            ]
          },
          ";\nс другой стороны, есть два способа разрезать четырёхугольник на два треугольника, проведя диагональ.\nДля произведения четырёх сомножителей и для пятиугольника имеется по 5 вариантов.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_equal-sets",
      "meta": {
        "n": 3,
        "longN": "1.3"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.3"
            ]
          },
          ". ",
          "Равномощные множества",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nДва множества называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "равномощными"
    ]
  },
  ", если между ними можно установить взаимно однозначное соответствие, при котором каждому элементу одного множества соответствует ровно один элемент другого.\n\n\nДля конечных множеств это означает, что в них одинаковое число элементов, но определение имеет смысл и для бесконечных множеств.\nНапример, отрезки ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, 1]"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, 2]"
    ]
  },
  " равномощны, поскольку отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\mapsto 2x"
    ]
  },
  " осуществляет искомое соответствие.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_26",
      "meta": {
        "n": 26
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "26"
            ]
          },
          ". ",
          "Докажите, что любые два интервала ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(a, b)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(c, d)"
            ]
          },
          " на прямой равномощны.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_27",
      "meta": {
        "n": 27
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "27"
            ]
          },
          ". ",
          "\nДокажите, что любые две окружности на плоскости равномощны.\nДокажите, что любые два круга на плоскости равномощны.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_28",
      "meta": {
        "n": 28
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "28"
            ]
          },
          ". ",
          "Докажите, что полуинтервал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, 1)"
            ]
          },
          " равномощен полуинтервалу ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(0, 1]"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nНесколько более сложна такая задача: доказать, что интервал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, 1)"
    ]
  },
  " и луч ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, +\\infin)"
    ]
  },
  " равномощны.\nЭто делается так.\nЗаметим, что отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\mapsto 1/x"
    ]
  },
  " является взаимно однозначным соответствием между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, 1)"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(1, +\\infin)"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\mapsto (x - 1)"
    ]
  },
  " — взаимно однозначным соответствием между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(1, +\\infin)"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, +\\infin)"
    ]
  },
  ", поэтому их композиция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\mapsto (1/x) - 1"
    ]
  },
  " является искомым взаимно однозначным соответствием между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, 1)"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, +\\infin)"
    ]
  },
  ".\n\n\nВообще, как говорят, отношение равномощности есть ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "отношение эквивалентности"
    ]
  },
  ".\nЭто означает, что оно ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "рефлексивно"
    ]
  },
  " (каждое множество равномощно самому себе),\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "симметрично"
    ]
  },
  " (если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", то и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ") и ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "транзитивно"
    ]
  },
  " (если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  ").\nСвойством транзитивности мы только что воспользовались, взяв луч ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(1, +\\infin)"
    ]
  },
  " в качестве промежуточного множества.\n\n\nЕщё несколько примеров:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество бесконечных последовательностей нулей и единиц равномощно множеству всех подмножеств натурального ряда.\n(В самом деле, сопоставим с каждой последовательностью множество номеров мест, на которых стоят единицы: например, последовательность из одних нулей соответствует пустому множеству, из одних единиц — натуральному ряду, а последовательность ",
          {
            "name": "math",
            "props": {},
            "children": [
              "10101010\\dots"
            ]
          },
          " — множеству чётных чисел.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество бесконечных последовательностей цифр 0, 1, 2, 3 равномощно множеству бесконечных последовательностей нулей и единиц.\n(В самом деле, можно закодировать цифры 0, 1, 2, 3 группами 00, 01, 10, 11.\nОбратное преобразование разбивает последовательность нулей и единиц на пары, после чего каждая пара заменяется на цифру от 0 до 3.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество бесконечных последовательностей цифр 0, 1, 2 равномощно множеству бесконечных последовательностей цифр 0 и 1.\n(Можно было бы пытаться рассуждать так: это множество заключено между двумя множествами одной и той же мощности, и потому равномощно каждому из них.\nЭтот ход мыслей правилен, как показывает ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_<>="
            },
            "children": [
              "теорема Кантора–Бернштейна"
            ]
          },
          ".\nНо здесь можно обойтись и без этой теоремы, если закодировать цифры 0, 1 и 2 последовательностями 0, 10 и 11: легко сообразить, что всякая последовательность нулей и единиц однозначно разбивается на такие блоки слева направо.\nТакой способ кодирования называют «префиксным кодом».)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "key": "2^U-01"
            },
            "children": [
              "\nПример с последовательностями нулей и единиц можно обобщить: множество подмножеств любого множества ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "U"
                ]
              },
              "\n(оно обычно обозначается ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "P(U)"
                ]
              },
              " и по-английски называется power set)\nравномощно множеству всех функций, которые ставят в соответствие каждому элементу ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x \\in U"
                ]
              },
              " одно из чисел 0 и 1 (множество таких функций обычно обозначают ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "2^U"
                ]
              },
              ").\n(В самом деле, каждому множеству ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "X \\sub U"
                ]
              },
              " соответствует его характеристическая функция.)\n"
            ]
          },
          "\n"
        ]
      },
      "\n"
    ]
  },
  "\nМы продолжим этот список, но сначала докажем несколько простых фактов о счётных множествах (равномощных множеству натуральных чисел).\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_4",
      "meta": {
        "n": 4,
        "longN": "1.4"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.4"
            ]
          },
          ". ",
          "Счётные множества",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nМножество называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "счётным"
    ]
  },
  ", если оно равномощно множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N"
    ]
  },
  " натуральных чисел, то есть если его можно представить в виде ",
  {
    "name": "math",
    "props": {},
    "children": [
      "{x_0, x_1, x_2, \\dots }"
    ]
  },
  "\n(здесь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_i"
    ]
  },
  " — элемент, соответствующий числу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ";\nсоответствие взаимно однозначно, так что все ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_i"
    ]
  },
  " различны).\n\n\nНапример, множество целых чисел ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Z"
    ]
  },
  " счётно, так как целые числа можно расположить в последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0, 1, -1, 2, -2, 3, -3, \\dots"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_n-sets",
      "meta": {
        "n": 2
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 2"
        ]
      },
      ". ",
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ") ",
      {
        "name": "area",
        "props": {
          "inline": true,
          "key": "theorem_n-sets.а"
        },
        "children": [
          "Подмножество счётного множества конечно или счётно."
        ]
      },
      "\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ") ",
      {
        "name": "area",
        "props": {
          "inline": true,
          "key": "theorem_n-sets.б"
        },
        "children": [
          "Всякое бесконечное множество содержит счётное подмножество."
        ]
      },
      "\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "в"
        ]
      },
      ") ",
      {
        "name": "area",
        "props": {
          "inline": true,
          "key": "theorem_n-sets.в"
        },
        "children": [
          "Объединение конечного или счётного числа конечных или счётных множеств конечно или счётно."
        ]
      },
      "\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\n(",
  {
    "name": "label",
    "props": {
      "ref": "theorem_n-sets.а"
    },
    "children": [
      "а"
    ]
  },
  ") Пусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — подмножество счётного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nПредставим множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "{a_0, a_1, a_2, \\dots }"
    ]
  },
  ".\nВыбросим из последовательности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_0, a_1, \\dots"
    ]
  },
  " те члены, которые не принадлежат ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " (сохраняя порядок оставшихся).\nТогда оставшиеся члены образуют либо конечную последовательность (и тогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " конечно), либо бесконечную (и тогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " счётно).\n\n\n(",
  {
    "name": "label",
    "props": {
      "ref": "theorem_n-sets.б"
    },
    "children": [
      "б"
    ]
  },
  ") Пусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " бесконечно.\nТогда оно непусто и содержит некоторый элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_0"
    ]
  },
  ".\nБудучи бесконечным, множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " не исчерпывается элементом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_0"
    ]
  },
  " — возьмём какой-нибудь другой элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1"
    ]
  },
  ", и т. д.\nПолучится последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_0, b_1, \\dots"
    ]
  },
  ";\nпостроение не прервётся ни на каком шаге, поскольку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " бесконечно.\nТеперь множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B = \\{b_0, b_1, \\dots \\}"
    ]
  },
  " и будет искомым счётным подмножеством.\n(Заметим, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " вовсе не обязано совпадать с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", даже если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " счётно.)\n\n\n(",
  {
    "name": "label",
    "props": {
      "ref": "theorem_n-sets.в"
    },
    "children": [
      "в"
    ]
  },
  ") Пусть имеется счётное число счётных множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1, A_2, \\dots"
    ]
  },
  "\nРасположив элементы каждого из них слева направо в последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(A_i = \\{a_{i0}, a_{i1}, \\dots \\})"
    ]
  },
  " и поместив эти последовательности друг под другом, получим таблицу\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{matrix}\na_{00} & a_{01} & a_{02} & a_{03} & \\dots \\\\\na_{10} & a_{11} & a_{12} & a_{13} & \\dots \\\\\na_{20} & a_{21} & a_{22} & a_{23} & \\dots \\\\\na_{30} & a_{31} & a_{32} & a_{33} & \\dots\n\\\\\n\n\\dots & \\dots & \\dots & \\dots & \\dots\n\\end{matrix}\n"
    ]
  },
  "\n\nТеперь эту таблицу можно развернуть в последовательность, например, проходя по очереди диагонали:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\na_{00}, a_{01}, a_{10}, a_{02}, a_{11}, a_{20}, a_{03}, a_{12}, a_{21}, a_{30}, \\dots\n"
    ]
  },
  "\nЕсли множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  " не пересекались, то мы получили искомое представление для их объединения.\nЕсли пересекались, то из построенной последовательности надо выбросить повторения.\n\n\nЕсли множеств конечное число или какие-то из множеств конечны, то в этой конструкции части членов не будет — и останется либо конечное, либо счётное множество.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_29",
      "meta": {
        "n": 29
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "29"
            ]
          },
          ". ",
          "\nОписанный проход по диагоналям задаёт взаимно однозначное соответствие между множеством всех пар натуральных чисел (которое обозначается ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N \\times \\N"
            ]
          },
          ") и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N"
            ]
          },
          ".\nЛюбопытно, что это соответствие задаётся простой формулой (многочленом второй степени с рациональными коэффициентами).\nУкажите этот многочлен.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "choice-axiom"
    },
    "children": [
      "\n",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Замечание"
        ]
      },
      " В доказательстве утверждения (",
      {
        "name": "label",
        "props": {
          "ref": "theorem_n-sets.б"
        },
        "children": [
          "б"
        ]
      },
      ") ",
      {
        "name": "label",
        "props": {
          "ref": "theorem_n-sets"
        },
        "children": [
          "теоремы ",
          {
            "name": "use",
            "props": {
              "ref": "theorem_n-sets",
              "path": "n"
            },
            "children": []
          },
          ""
        ]
      },
      " есть тонкий момент: на каждом шаге мы должны выбрать один из оставшихся элементов множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ";\nтакие элементы есть, но у нас нет никакого правила, позволяющего такой выбор описать.\nПри более формальном построении теории множеств тут нужно сослаться на специальную аксиому, называемую ",
      {
        "name": "format.i",
        "props": {},
        "children": [
          "аксиомой выбора"
        ]
      },
      ".\n"
    ]
  },
  "\nЗаконность этой аксиомы вызывала большие споры в начале 20-го века, но постепенно к ней привыкли, и эти споры сейчас почти не воспринимаются.\n(К некоторым парадоксальным примерам, связанным с аксиомой выбора, мы ещё вернёмся.)\nВ середине века великий логик ",
  {
    "name": "label",
    "props": {
      "ref": "name_godel"
    },
    "children": [
      "Курт Гёдель"
    ]
  },
  " доказал, что аксиому выбора нельзя опровергнуть, пользуясь остальными аксиомами теории множеств, а в 1960-е годы американский математик ",
  {
    "name": "label",
    "props": {
      "ref": "name_cohen"
    },
    "children": [
      "Пол Дж. Коэн"
    ]
  },
  " доказал, что её нельзя и вывести из остальных аксиом.\n(Конечно, понимание этих утверждений требует подробного изложения теории множеств как аксиоматической теории.)\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_30",
      "meta": {
        "n": 30
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "30"
            ]
          },
          ". ",
          "\nТакой же тонкий момент (хотя и менее очевидный) есть и в доказательстве утверждения (",
          {
            "name": "label",
            "props": {
              "ref": "theorem_n-sets.в"
            },
            "children": [
              "в"
            ]
          },
          ").\nМожете ли вы догадаться, где он?\n(Ответ: мы знаем, что множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A_i"
            ]
          },
          " счётны, то есть что для каждого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "i"
            ]
          },
          " существует взаимно однозначное соответствие между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A_i"
            ]
          },
          ".\nНо нужно выбрать и фиксировать эти соответствия, прежде чем удастся построить соответствие между объединением всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A_i"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЕщё несколько примеров счётных множеств:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q}"
            ]
          },
          " рациональных чисел счётно.\nВ самом деле, рациональные числа представляются несократимыми дробями с целым числителем и знаменателем.\nМножество дробей с данным знаменателем счётно, поэтому ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q}"
            ]
          },
          " представимо в виде объединения счётного числа счётных множеств.\nЗабегая вперёд, отметим, что множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\reals"
            ]
          },
          " всех действительных чисел ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_01..."
            },
            "children": [
              "несчётно"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^k"
            ]
          },
          ", элементами которого являются наборы из ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          " натуральных чисел, счётно.\nЭто легко доказать индукцией по ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          ".\nПри ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k = 2"
            ]
          },
          " множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^2 = \\N \\times \\N"
            ]
          },
          " пар натуральных чисел разбивается на счётное число счётных множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{0\\} \\times \\N, \\{1\\} \\times \\N, \\dots"
            ]
          },
          "\n(элементами ",
          {
            "name": "math",
            "props": {},
            "children": [
              "i"
            ]
          },
          "-го множества будут пары, первый член которых равен ",
          {
            "name": "math",
            "props": {},
            "children": [
              "i"
            ]
          },
          ").\nПоэтому ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^2"
            ]
          },
          " счётно.\nАналогичным образом множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^3"
            ]
          },
          " троек натуральных чисел разбивается на счётное число множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{i\\} \\times \\N \\times \\N"
            ]
          },
          ".\nКаждое из них состоит из троек, первый член которых фиксирован и потому равномощно множеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^2"
            ]
          },
          ", которое счётно.\nТочно так же можно перейти от счётности множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^k"
            ]
          },
          " к счётности множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^{k+1}"
            ]
          },
          ".\n\n\nПо тем же причинам произведение двух счётных множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\times B"
            ]
          },
          " и вообще конечного числа счётных множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A_1 \\times \\ldots \\times A_k"
            ]
          },
          " (элементами этого множества являются наборы ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\lang a_1, \\dots , a_k \\rang"
            ]
          },
          ", составленные из элементов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a_1 \\in A_1, \\dots , a_k \\in A_k"
            ]
          },
          ") счётно.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество всех конечных последовательностей натуральных чисел счётно.\nВ самом деле, множество всех последовательностей данной длины счётно (как мы только что видели), так что интересующее нас множество разбивается на счётное число счётных множеств.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nВ предыдущем примере не обязательно говорить о натуральных числах — можно взять любое счётное (или конечное) множество.\nНапример, множество всех текстов, использующих русский алфавит (такой текст можно считать конечной последовательностью букв, пробелов, знаков препинания и т. п.), счётно;\nто же самое можно сказать о множестве (всех мыслимых) компьютерных программ и т. д.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЧисло называют ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "алгебраическим"
            ]
          },
          ", если оно является корнем ненулевого многочлена с целыми коэффициентами.\nМножество алгебраических чисел счётно, так как многочленов счётное число (многочлен задаётся конечной последовательностью целых чисел — его коэффициентов), а каждый многочлен имеет конечное число корней (не более ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " для многочленов степени ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          ").\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество периодических дробей счётно.\nВ самом деле, такая дробь может быть записана как конечная последовательность символов из конечного множества (запятая, цифры, скобки);\nнапример, дробь 0,16666... можно записать как 0,1(6).\nА таких последовательностей счётное множество.\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_31",
      "meta": {
        "n": 31
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "31"
            ]
          },
          ". ",
          "\nДокажите, что любое семейство непересекающихся интервалов на прямой конечно или счётно.\n(Указание: в каждом интервале найдётся рациональная точка.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_32",
      "meta": {
        "n": 32
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "32"
            ]
          },
          ". ",
          "\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "а"
            ]
          },
          ") Докажите, что любое множество непересекающихся восьмёрок\nна плоскости конечно или счётно.\n(Восьмёрка — объединение двух касающихся окружностей любых размеров.)\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "б"
            ]
          },
          ") Сформулируйте и докажите аналогичное утверждение для букв «",
          {
            "name": "code",
            "props": {
              "inline": true
            },
            "children": [
              "T"
            ]
          },
          "».\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_33",
      "meta": {
        "n": 33
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "33"
            ]
          },
          ". ",
          "Докажите, что множество точек строгого локального максимума любой функции действительного аргумента конечно или счётно.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_34",
      "meta": {
        "n": 34
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "34"
            ]
          },
          ". ",
          "Докажите, что множество точек разрыва неубывающей функции действительного аргумента конечно или счётно.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_or-n-set",
      "meta": {
        "n": 3
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 3"
        ]
      },
      ". ",
      "Если множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " бесконечно, а множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " конечно или счётно, то объединение ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A \\cup B"
        ]
      },
      " равномощно ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ".",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nМожно считать, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " не пересекается с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " (пересечение можно выбросить из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", останется по-прежнему конечное или счётное множество).\n\n\nВыделим в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " счётное подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P"
    ]
  },
  "; остаток обозначим через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Q"
    ]
  },
  ".\nТогда нам надо доказать, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B + P + Q"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P + Q"
    ]
  },
  "\n(знак ",
  {
    "name": "math",
    "props": {},
    "children": [
      "+"
    ]
  },
  " символизирует объединение непересекающихся множеств).\nПоскольку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B + P"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P"
    ]
  },
  " оба счётны, между ними существует взаимно однозначное соответствие.\nЕго легко продолжить до соответствия между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B + P + Q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P + Q"
    ]
  },
  "\n(каждый элемент множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Q"
    ]
  },
  " соответствует сам себе).\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_35",
      "meta": {
        "n": 35
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "35"
            ]
          },
          ". ",
          "Примените эту конструкцию и явно укажите соответствие между отрезком ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, 1]"
            ]
          },
          " и полуинтервалом ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, 1)"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_36",
      "meta": {
        "n": 36
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "36"
            ]
          },
          ". ",
          "\n",
          {
            "name": "label",
            "props": {
              "ref": "theorem_or-n-set"
            },
            "children": [
              "Теорема ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_or-n-set",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          " показывает, что добавление счётного множества к бесконечному не меняет его мощности.\nМожно ли сказать то же самое про удаление?\nДокажите, что если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " бесконечно и не является счётным, а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " конечно или счётно, то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\setminus B"
            ]
          },
          " равномощно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_37",
      "meta": {
        "n": 37
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "37"
            ]
          },
          ". ",
          "\nНемецкий математик ",
          {
            "name": "label",
            "props": {
              "ref": "name_dedekind"
            },
            "children": [
              "Р. Дедекинд"
            ]
          },
          " предложил такое определение бесконечного множества: множество бесконечно, если оно равномощно некоторому своему подмножеству, не совпадающему со всем множеством.\nПокажите, что указанное Дедекиндом свойство действительно определяет бесконечные множества.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nДобавляя конечные или счётные множества, легко понять, что прямая, все промежутки на прямой (отрезки, интервалы, полуинтервалы), лучи, их конечные или счётные объединения и т. п. равномощны друг другу.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_38",
      "meta": {
        "n": 38
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "38"
            ]
          },
          ". ",
          "Укажите взаимно однозначное соответствие между множеством ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, 1] \\cup [2, 3] \\cup [4, 5] \\cup \\dots"
            ]
          },
          " и отрезком ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, 1]"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_39",
      "meta": {
        "n": 39
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "39"
            ]
          },
          ". ",
          "\nДокажите, что множество всех прямых на плоскости равномощно множеству всех точек на плоскости.\n(Указание: и точки, и прямые задаются парами чисел — за небольшими исключениями.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_40",
      "meta": {
        "n": 40
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "40"
            ]
          },
          ". ",
          "\nДокажите, что полуплоскость (точки плоскости, лежащие по одну сторону от некоторой прямой) равномощна плоскости.\n(Это верно независимо от того, включаем мы граничную прямую в полуплоскость или нет.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_[0,1]",
      "meta": {
        "n": 4
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 4"
        ]
      },
      ". ",
      "Отрезок ",
      {
        "name": "math",
        "props": {},
        "children": [
          "[0, 1]"
        ]
      },
      " равномощен множеству всех бесконечных последовательностей нулей и единиц.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВ самом деле, каждое число ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in [0, 1]"
    ]
  },
  " записывается в виде бесконечной двоичной дроби.\nПервый знак этой дроби равен 0 или 1 в зависимости от того, попадает ли число ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " в левую или правую половину отрезка.\nЧтобы определить следующий знак, надо выбранную половину поделить снова пополам и посмотреть, куда попадёт ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", и т. д.\n\n\nЭто же соответствие можно описать в другую сторону: последовательности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0 x_1 x_2 \\dots"
    ]
  },
  " соответствует число, являющееся суммой ряда\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\frac{x_0}{2} + \\frac{x_1}{4} + \\frac{x_2}{8} + ",
      "\\mathellipsis",
      "\n"
    ]
  },
  "\n(В этом построении мы используем некоторые факты из математического анализа, что не удивительно — нас интересуют свойства действительных чисел.)\n\n\nОписанное соответствие пока что не совсем взаимно однозначно: двоично-рациональные числа (дроби вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "m/2^n"
    ]
  },
  ") имеют два представления.\nНапример, число 3/8 можно записать как в виде 0,011000... , так и в виде 0,010111...\nСоответствие станет взаимно однозначным, если отбросить дроби с единицей в периоде (кроме дроби 0,1111... , которую надо оставить).\nНо таких дробей счётное число, поэтому на мощность это не повлияет (",
  {
    "name": "label",
    "props": {
      "ref": "theorem_or-n-set"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_or-n-set",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ").\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_41",
      "meta": {
        "n": 41
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "41"
            ]
          },
          ". ",
          "Какая двоичная дробь соответствует числу 1/3?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВ этом доказательстве можно было бы использовать более привычные десятичные дроби вместо двоичных.\nПолучилось бы, что отрезок ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, 1]"
    ]
  },
  " равномощен множеству всех бесконечных последовательностей цифр ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0, 1, ",
      "\\mathellipsis",
      " , 9"
    ]
  },
  ".\nЧтобы перейти отсюда к последовательностям нулей и единиц, можно воспользоваться ",
  {
    "name": "label",
    "props": {
      "ref": "2^U-01"
    },
    "children": [
      "приёмом"
    ]
  },
  ", описанным ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "на с. 12"
    ]
  },
  ".\n\n\nТеперь всё готово для доказательства удивительного факта:\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_square=line",
      "meta": {
        "n": 5
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 5"
        ]
      },
      ". ",
      "Квадрат (со внутренностью) равномощен отрезку.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nКвадрат равномощен множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, 1] \\times [0, 1]"
    ]
  },
  " пар действительных чисел, каждое из которых лежит на отрезке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, 1]"
    ]
  },
  " (метод координат).\nМы уже знаем (",
  {
    "name": "label",
    "props": {
      "ref": "theorem_[0,1]"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_[0,1]",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  "), что вместо чисел можно говорить о последовательностях нулей и единиц.\nОсталось заметить, что паре последовательностей нулей и единиц ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x_0 x_1 x_2 ",
      "\\mathellipsis",
      " , y_0 y_1 y_2 ",
      "\\mathellipsis",
      "\\rang"
    ]
  },
  " можно поставить в соответствие последовательность-смесь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0 y_0 x_1 y_1 x_2 y_2 ",
      "\\mathellipsis",
      ""
    ]
  },
  " и что это соответствие будет взаимно однозначным.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nЭтот результат был получен в 1877 году немецким математиком ",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Георгом Ка´нтором"
    ]
  },
  " и удивил его самого, поскольку противоречил интуитивному ощущению «размерности» (квадрат двумерен, поэтому вроде бы должен содержать больше точек, чем одномерный отрезок).\nВот что ",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Кантор"
    ]
  },
  " писал ",
  {
    "name": "label",
    "props": {
      "ref": "name_dedekind"
    },
    "children": [
      "Дедекинду"
    ]
  },
  " (20 июня 1877 года), обсуждая вопрос о равномощности пространств разного числа измерений: «Как мне кажется, на этот вопрос следует ответить утвердительно, хотя на протяжении ряда лет я придерживался противоположного мнения».\n\n\nВ одном из ответных писем Дедекинд отмечает, что результат Кантора не лишает смысла понятие размерности, поскольку можно рассматривать лишь непрерывные в обе стороны соответствия, и тогда пространства разной размерности можно будет различить.\nЭта гипотеза оказалось верной, хотя не такой простой; первые попытки её доказать, в том числе одна из статей Кантора, содержали ошибки, и только спустя тридцать лет голландский математик ",
  {
    "name": "label",
    "props": {
      "ref": "name_brouwer"
    },
    "children": [
      "Л. Брауэр"
    ]
  },
  " дал правильное доказательство.\n\n\nВпрочем, отсутствие непрерывного в обе стороны соответствия между отрезком и квадратом доказать несложно; трудности начинаются в бо´льших размерностях.\n(Заметим также, что существует непрерывное отображение отрезка в квадрат, которое проходит через любую точку квадрата.\nОно называется «кривой ",
  {
    "name": "label",
    "props": {
      "ref": "name_peano"
    },
    "children": [
      "Пеано"
    ]
  },
  "».)\n\n\nИз ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_square=line"
    },
    "children": [
      "теоремы ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_square=line",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " легко получить много других утверждений про равномощность геометрических объектов: круг равномощен окружности, прямая равномощна плоскости и т. п.\n\n\nМожно также заметить, что пространство (точки которого задаются тремя координатами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x, y, z \\rang"
    ]
  },
  ") равномощно плоскости (надо закодировать пару ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x, y \\rang"
    ]
  },
  " одним числом), и, следовательно, прямой.\nТо же самое можно проделать и для пространств большей размерности.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_42",
      "meta": {
        "n": 42
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "42"
            ]
          },
          ". ",
          "\nДокажите, что множество всех конечных последовательностей действительных чисел равномощно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\R"
            ]
          },
          "\n(множеству всех действительных чисел).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_43",
      "meta": {
        "n": 43
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "43"
            ]
          },
          ". ",
          "Докажите, что множество всех бесконечных последовательностей действительных чисел равномощно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\R"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nОтметим, что мы пока не умеем доказывать, что множество действительных чисел\n(или множество бесконечных последовательностей нулей и единиц) ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_01..."
    },
    "children": [
      "несчётно"
    ]
  },
  ".\n\n\nМощность множества действительных чисел называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "мощностью континуума"
    ]
  },
  " (от латинского слова, означающего «непрерывный»; имеется в виду, что точка на отрезке может непрерывно двигаться от одного конца к другому).\n",
  "\n\n\n",
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/1/5/img1.svg",
      "src": "/data/books/data/vereshagin-shen-sets/1/5/img1.svg"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/1/5/img2.svg",
      "src": "/data/books/data/vereshagin-shen-sets/1/5/img2.svg"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/1/5/img3.svg",
      "src": "/data/books/data/vereshagin-shen-sets/1/5/img3.svg"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/1/5/img4.svg",
      "src": "/data/books/data/vereshagin-shen-sets/1/5/img4.svg"
    },
    "children": []
  },
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_5",
      "meta": {
        "n": 5,
        "longN": "1.5"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.5"
            ]
          },
          ". ",
          "Теорема Кантора–Бернштейна",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nОпределение равномощности уточняет интуитивную идею о множествах «одинакового размера».\nА как формально определить, когда одно множество «больше» другого?\n\n\nГоворят, что множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " по мощности не больше множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ",\nесли оно равномощно некоторому подмножеству множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " (возможно, самому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ").\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_44",
      "meta": {
        "n": 44
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "44"
            ]
          },
          ". ",
          "\nНекто предложил такое определение: множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет строго меньшую мощность, чем множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", если оно равномощно некоторой части множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", не совпадающей со всем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ".\nПочему это определение неудачно?\n(Указание. Популярные рассказы о теории множеств часто начинаются с такого парадокса, восходящего к ",
          {
            "name": "label",
            "props": {
              "ref": "name_galilei"
            },
            "children": [
              "Галилею"
            ]
          },
          ".\nКаких чисел больше — всех натуральных чисел или точных квадратов?\nС одной стороны, точные квадраты составляют лишь небольшую часть натуральных чисел;\nс другой стороны их можно поставить во взаимно однозначное соответствие со всеми натуральными числами.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nОтношение «иметь не большую мощность» обладает многими естественными свойствами:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " равномощны, то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ". (Очевидно.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ".\n(Тоже несложно.\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " находится во взаимно однозначном соответствии с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B' \\sub B"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " находится во взаимно однозначном соответствии с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C' \\sub C"
            ]
          },
          ".\nТогда при втором соответствии ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B'"
            ]
          },
          " соответствует некоторому множеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C'' \\sub C' \\sub C"
            ]
          },
          ", как показано на ",
          {
            "name": "label",
            "props": {
              "ref": "img_1"
            },
            "children": [
              "рис. 1"
            ]
          },
          ", и потому ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " равномощно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C''"
            ]
          },
          ".)\n\n",
          {
            "name": "area",
            "props": {
              "key": "img_1"
            },
            "children": [
              "\n",
              {
                "name": "image",
                "props": {
                  "src": "/1/5/img1.svg",
                  "height": "50%"
                },
                "children": [
                  "Рис. 1. Транзитивность сравнения мощностей"
                ]
              },
              "\n"
            ]
          },
          "\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", то они равномощны.\n(Это вовсе не очевидное утверждение составляет содержание теоремы ",
          {
            "name": "label",
            "props": {
              "ref": "name_cantor"
            },
            "children": [
              "Кантора"
            ]
          },
          "–",
          {
            "name": "label",
            "props": {
              "ref": "name_bernstein"
            },
            "children": [
              "Бернштейна"
            ]
          },
          ", которую мы сейчас докажем.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nДля любых двух множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " верно (хотя бы) одно из двух: либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " имеет не большую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\n(Доказательство этого факта требует так называемой «трансфинитной индукции»; ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_set=subset"
            },
            "children": [
              "см. теорема ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_set=subset",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          ".)\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_<>=",
      "meta": {
        "n": 6
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 6 (Кантора–Бернштейна)"
        ]
      },
      ". ",
      "\nЕсли множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " равномощно некоторому подмножеству множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ", а ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " равномощно некоторому подмножеству множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ", то множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " равномощны.\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "img_2"
    },
    "children": [
      "\n",
      {
        "name": "image",
        "props": {
          "src": "/1/5/img2.svg",
          "height": "50%"
        },
        "children": [
          "Рис. 2."
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " равномощно подмножеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_1"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " равномощно подмножеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " (см. ",
  {
    "name": "label",
    "props": {
      "ref": "img_2"
    },
    "children": [
      "рис. 2"
    ]
  },
  ").\nПри взаимно однозначном соответствии между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1"
    ]
  },
  " подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_1 \\sub B"
    ]
  },
  " переходит в некоторое подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_2 \\sub A_1"
    ]
  },
  ".\nПри этом все три множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_2"
    ]
  },
  " равномощны, — и нужно доказать, что они равномощны множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", или, что то же самое, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1"
    ]
  },
  ".\n\n\nТеперь мы можем забыть про множество B и его подмножества\nи доказывать такой факт:\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "\nесли ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A_2 \\sub A_1 \\sub A_0"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A_2"
        ]
      },
      " равномощно ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A_0"
        ]
      },
      ", то все три множества равномощны.\n"
    ]
  },
  "\n\n\n(Для единообразия мы пишем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0"
    ]
  },
  " вместо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".)\n\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " — функция, осуществляющая взаимно однозначное соответствие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0 \\to A_2"
    ]
  },
  " (элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in A_0"
    ]
  },
  " соответствует элементу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x) \\in A_2"
    ]
  },
  ").\nКогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0"
    ]
  },
  " переходит в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_2"
    ]
  },
  ", меньшее множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1"
    ]
  },
  " переходит в какое-то множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_3 \\sub A_2"
    ]
  },
  " (см. ",
  {
    "name": "label",
    "props": {
      "ref": "img_3"
    },
    "children": [
      "рис. 3"
    ]
  },
  ").\nАналогичным образом само ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_2"
    ]
  },
  " переходит в некоторое множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_4 \\sub A_2"
    ]
  },
  ".\nПри этом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_4 \\sub A_3"
    ]
  },
  ", так как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_2 \\sub A_1"
    ]
  },
  ".\n\n",
  {
    "name": "area",
    "props": {
      "key": "img_3"
    },
    "children": [
      "\n",
      {
        "name": "image",
        "props": {
          "src": "/1/5/img3.svg",
          "height": "50%"
        },
        "children": [
          "Рис. 3."
        ]
      },
      "\n"
    ]
  },
  "\n\nПродолжая эту конструкцию, мы получаем убывающую последовательность множеств\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nA_0 \\supset A_1 \\supset A_2 \\supset A_3 \\supset A_4 \\supset \\dots\n"
    ]
  },
  "\nи взаимно однозначное соответствие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A_0 \\to A_2"
    ]
  },
  ", при котором ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  " соответствует ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_{i+2}"
    ]
  },
  "\n(иногда это записывают так: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(A_i) = A_{i+2}"
    ]
  },
  ").\nФормально можно описать ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_{2n}"
    ]
  },
  " как множество тех элементов, которые получаются из какого-то элемента множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0"
    ]
  },
  " после ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  "-кратного применения функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ".\nАналогичным образом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_{2n+1}"
    ]
  },
  " состоит из тех и только тех элементов, которые получаются из какого-то элемента множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1"
    ]
  },
  " после ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  "-кратного применения функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ".\n\n\nЗаметим, что пересечение всех множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  " вполне может быть непусто: оно состоит из тех элементов, у которых можно сколько угодно раз брать ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  "-прообраз.\nТеперь можно сказать так: множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0"
    ]
  },
  " мы разбили на непересекающиеся слои ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C_i = A_i\\ \\backslash \\ A_{i+1}"
    ]
  },
  " и на сердцевину ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C = \\bigcap_i A_i"
    ]
  },
  ".\n\n\nСлои ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C_0, C_2, C_4, \\dots"
    ]
  },
  " равномощны (функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " осуществляет взаимно однозначное соответствие между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C_0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C_2"
    ]
  },
  ", между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C_2"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C_4"
    ]
  },
  " и т. д.):\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nC_0 \\xrightarrow{f} C_2 \\xrightarrow{f} C_4 \\xrightarrow{f} \\dots\n"
    ]
  },
  "\nТо же самое можно сказать про слои с нечётными номерами:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nC_1 \\xrightarrow{f} C_3 \\xrightarrow{f} C_5 \\xrightarrow{f} \\dots\n"
    ]
  },
  "\nМожно ещё отметить (что, впрочем, не понадобится), что функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " на множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  " осуществляет его перестановку (взаимно однозначное соответствие с самим собой).\n\n\nТеперь легко понять, как построить взаимно однозначное соответствие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g"
    ]
  },
  " между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1"
    ]
  },
  ".\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in A_0"
    ]
  },
  ".\nТогда соответствующий ему элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g(x)"
    ]
  },
  " строится так: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g(x) = f(x)"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in C_{2k}"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g(x) = x"
    ]
  },
  "\nпри ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in C_{2k+1}"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in C"
    ]
  },
  " (см. ",
  {
    "name": "label",
    "props": {
      "ref": "img_4"
    },
    "children": [
      "рис. 4"
    ]
  },
  ").\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "img_4"
    },
    "children": [
      "\n",
      {
        "name": "image",
        "props": {
          "src": "/1/5/img4.svg",
          "height": "50%"
        },
        "children": [
          "Рис. 4."
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      "\nИстория этой теоремы (называемой также теоремой Шрёдера—Бернштейна) такова.\nКантор формулирует её без доказательства в 1883 году, обещая:\n«К этому я ещё вернусь в одной более поздней работе и тогда выявлю своеобразный интерес этой общей теоремы».\nОднако этого обещания он не выполнил, и первые доказательства были даны ",
      {
        "name": "label",
        "props": {
          "ref": "name_schroder"
        },
        "children": [
          "Шрёдером"
        ]
      },
      " (1896) и ",
      {
        "name": "label",
        "props": {
          "ref": "name_bernstein"
        },
        "children": [
          "Бернштейном"
        ]
      },
      " (1897).\nКак видно из работ и писем Кантора, он предполагал доказывать эту теорему одновременно с возможностью сравнить любые два множества (",
      {
        "name": "label",
        "props": {
          "ref": "theorem_set=subset"
        },
        "children": [
          "см. теорема ",
          {
            "name": "use",
            "props": {
              "ref": "theorem_set=subset",
              "path": "n"
            },
            "children": []
          },
          ""
        ]
      },
      ");\nбыть может, он имел в виду рассуждение, намеченное нами в ",
      {
        "name": "label",
        "props": {
          "ref": "problem_proof-<>="
        },
        "children": [
          "задаче ",
          {
            "name": "use",
            "props": {
              "ref": "problem_proof-<>=",
              "path": "n"
            },
            "children": []
          },
          ""
        ]
      },
      ".\n(Работы Кантора по теории множеств и его письма переведены на русский язык ",
      {
        "name": "label",
        "props": {
          "ref": "lib_4"
        },
        "children": [
          "[4]"
        ]
      },
      ";\nвсе цитаты даются по этому изданию.)\n"
    ]
  },
  "\n\n\nТеорема Кантора–Бернштейна значительно упрощает доказательства равномощности: например, если мы хотим доказать, что бублик и шар в пространстве равномощны, то достаточно заметить, что из бублика можно вырезать маленький шар (гомотетичный большому), а из шара — маленький бублик.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_45",
      "meta": {
        "n": 45
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "45"
            ]
          },
          ". ",
          "Посмотрите на приведённые выше задачи, где требовалось доказать равномощность, и убедитесь, что во многих из них применение теоремы Кантора–Бернштейна сильно упрощает дело.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_46",
      "meta": {
        "n": 46
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "46"
            ]
          },
          ". ",
          "Докажите, что все геометрические фигуры, содержащие хотя бы кусочек прямой или кривой, равномощны.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_square-part",
      "meta": {
        "n": 47
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "47"
            ]
          },
          ". ",
          "\nДокажите, что если квадрат разбит на два множества, то хотя бы одно из них равномощно квадрату.\n(Указание. Если одна из частей содержит отрезок, то можно воспользоваться теоремой Кантора–Бернштейна.\nЕсли же, скажем, первая часть не содержит отрезков, то в каждом горизонтальном сечении квадрата есть точка второй части, и с помощью аксиомы выбора во второй части можно найти подмножество, равномощное отрезку — после чего снова можно сослаться на теорему Кантора–Бернштейна.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_line-part",
      "meta": {
        "n": 48
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "48"
            ]
          },
          ". ",
          "Докажите, что если отрезок разбит на две части, то хотя бы одна из них равномощна отрезку.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nТо же самое доказательство теоремы Кантора–Бернштейна можно изложить более абстрактно (и избавиться от упоминания натуральных чисел).\nНапомним, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to A_2"
    ]
  },
  " есть взаимно однозначное соответствие между множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и его подмножеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_2"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_1"
    ]
  },
  " — некоторое промежуточное множество.\nНазовём множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X \\sub A"
    ]
  },
  " «хорошим», если оно содержит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\setminus A_1"
    ]
  },
  " и замкнуто относительно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ", т. е.\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nX \\supset (A \\setminus A_1) + f(X)\n"
    ]
  },
  "\n(мы используем знак ",
  {
    "name": "math",
    "props": {},
    "children": [
      "+"
    ]
  },
  " для объединения, поскольку объединяемые множества заведомо не пересекаются).\nЛегко проверить, что пересечение любого семейства хороших множеств хорошее, поэтому если мы пересечём все хорошие множества, то получим минимальное по включению хорошее множество.\nНазовём его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  ".\nЛегко проверить, что множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(A \\setminus A_1) + f(M)"
    ]
  },
  " будет хорошим, поэтому в силу минимальности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  " включение в определении хорошего множества превращается в равенство:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nM = (A \\setminus A_1) + f(M)\n"
    ]
  },
  "\nТеперь всё готово для построения биекции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g: A \\to A_1"
    ]
  },
  ".\nЭта биекция совпадает с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " внутри ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  " и тождественна вне ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_49",
      "meta": {
        "n": 49
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "49"
            ]
          },
          ". ",
          "Проведите это рассуждение подробно.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЭто рассуждение удобно при построении аксиоматической теории множеств, так как в нём не нужны натуральные числа (которые строятся далеко не сразу).\nНо по существу это то же самое рассуждение, поскольку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  " есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C_0 \\cup C_2 \\cup \\dots"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_50",
      "meta": {
        "n": 50
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "50"
            ]
          },
          ". ",
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " — взаимно однозначное соответствие между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и некоторым подмножеством множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g"
            ]
          },
          " — взаимно однозначное соответствие между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " и некоторым подмножеством множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\nДокажите, что можно так разбить множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " на непересекающиеся части ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A'"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A''"
            ]
          },
          ", а множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " — на непересекающиеся части ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B'"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B''"
            ]
          },
          ", что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " осуществляет взаимно однозначное соответствие между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A'"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B'"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g"
            ]
          },
          " — между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A''"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B''"
            ]
          },
          ".\n(Указание: именно это мы фактически установили при доказательстве теоремы Кантора–Бернштейна.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_51",
      "meta": {
        "n": 51
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "51"
            ]
          },
          ". ",
          "\nДокажите, что квадрат можно разбить на две части так, что из подобных им частей можно сложить круг. Формально: квадрат можно разбить на две части ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A'"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A''"
            ]
          },
          ", а круг — на две части ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B'"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B''"
            ]
          },
          ", для которых ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A'"
            ]
          },
          " подобно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B'"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A''"
            ]
          },
          " подобно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B''"
            ]
          },
          ".\n(Указание: воспользуйтесь предыдущей задачей.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "set-size-variants"
    },
    "children": [
      "\nТеперь, имея в виду теорему Кантора–Бернштейна, вернёмся к вопросу о сравнении мощностей.\nДля данных множеств ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " теоретически имеются четыре возможности:\n",
      {
        "name": "list",
        "props": {},
        "children": [
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              " равномощно некоторой части ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "B"
                ]
              },
              ", а ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "B"
                ]
              },
              " равномощно некоторой части ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              ".\n(В этом случае, как мы знаем, множества равномощны.)\n"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "\n",
              {
                "name": "area",
                "props": {
                  "key": "set-size<"
                },
                "children": [
                  "\n",
                  {
                    "name": "math",
                    "props": {},
                    "children": [
                      "A"
                    ]
                  },
                  " равномощно некоторой части ",
                  {
                    "name": "math",
                    "props": {},
                    "children": [
                      "B"
                    ]
                  },
                  ", но ",
                  {
                    "name": "math",
                    "props": {},
                    "children": [
                      "B"
                    ]
                  },
                  " не равномощно никакой части ",
                  {
                    "name": "math",
                    "props": {},
                    "children": [
                      "A"
                    ]
                  },
                  ".\nВ этом случае говорят, что ",
                  {
                    "name": "math",
                    "props": {},
                    "children": [
                      "A"
                    ]
                  },
                  " ",
                  {
                    "name": "format.i",
                    "props": {},
                    "children": [
                      "имеет меньшую мощность, чем"
                    ]
                  },
                  " ",
                  {
                    "name": "math",
                    "props": {},
                    "children": [
                      "B"
                    ]
                  },
                  ".\n"
                ]
              },
              "\n"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {},
                "children": [
                  "B"
                ]
              },
              " равномощно некоторой части ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              ", но ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              " не равномощно никакой части ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "B"
                ]
              },
              ".\nВ этом случае говорят, что ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              " ",
              {
                "name": "format.i",
                "props": {},
                "children": [
                  "имеет большую мощность, чем"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "B"
                ]
              },
              ".\n"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "\nНи ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              " не равномощно никакой части ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "B"
                ]
              },
              ", ни ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "B"
                ]
              },
              " не равномощно никакой части ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              ".\nЭтот случай на самом деле ",
              {
                "name": "label",
                "props": {
                  "ref": "theorem_set=subset"
                },
                "children": [
                  "невозможен"
                ]
              },
              ", но мы этого пока не знаем.\n"
            ]
          },
          "\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_52",
      "meta": {
        "n": 52
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "52"
            ]
          },
          ". ",
          "Докажите, что счётное множество имеет меньшую мощность, чем любое несчётное.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_53",
      "meta": {
        "n": 53
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "53"
            ]
          },
          ". ",
          "\nПроверьте аккуратно, что если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет меньшую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " имеет меньшую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " имеет меньшую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          " (транзитивность сравнения мощностей).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЗаметим, что мы уже долго говорим о сравнении мощностей, но воздерживаемся от упоминания «мощности множества» как самостоятельного объекта, а только сравниваем мощности разных множеств.\nВ принципе можно было бы определить мощность множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " как класс всех множеств, равномощных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nТакие классы для множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " совпадают в том и только том случае, когда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " равномощны, так что слова «имеют равную мощность» приобрели бы буквальный смысл.\nПроблема тут в том, что таких множеств (равномощных множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ") слишком много, поскольку всё на свете может быть их\nэлементами.\nИх насколько много, что образовать из них множество затруднительно, это может привести к ",
  {
    "name": "label",
    "props": {
      "ref": "russell-paradox"
    },
    "children": [
      "парадоксам"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "(см. раздел 1.6, с. 29)"
    ]
  },
  ".\n\n\nИз этой ситуации есть несколько выходов.\nСамый простой — по-прежнему говорить только о сравнении мощностей, но не о самих мощностях.\nМожно также ввести понятие «класса» — такой большой совокупности объектов, что её уже нельзя считать элементом других совокупностей («если вы понимаете, о чём я тут толкую» — добавила бы Сова из книжки о Винни-Пухе), и считать мощностью множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " класс всех множеств, равномощных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nЕщё один выход — для каждого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " выбрать некоторое «стандартное» множество, равномощное ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", и назвать его мощностью множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nОбычно в качестве стандартного множества берут минимальный ординал, равномощный ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", — но это построение уже требует более формального (аксиоматического) построения теории множеств.\n\n\n",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Кантор"
    ]
  },
  " говорил о мощностях так (1895): «",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "Мощностью"
    ]
  },
  " или ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "кардинальным числом"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  " мы называем то общее понятие, которое получается при помощи нашей активной мыслительной способности из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  ", когда мы абстрагируемся от качества его различных элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "m"
    ]
  },
  " и от порядка их задания. ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang \\dots \\rang"
    ]
  },
  " Так как из каждого отдельного элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "m"
    ]
  },
  ", когда мы отвлекаемся от качества, получается некая ”единица“, то само кардинальное число оказывается множеством, образованным исключительно из единиц, которое существует как интеллектуальный образ или как проекция заданного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  " в наш разум».\n\n\nТак или иначе, мы будем употреблять обозначение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A|"
    ]
  },
  " для мощности множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " хотя бы как вольность речи: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| = |B|"
    ]
  },
  " означает, что множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " равномощны;\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| \\leqslant |B|"
    ]
  },
  " означает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " равномощно некоторому подмножеству множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| < |B|"
    ]
  },
  " означает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " имеет ",
  {
    "name": "label",
    "props": {
      "ref": "set-size<"
    },
    "children": [
      "меньшую мощность"
    ]
  },
  ", чем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "(см. с. 24)"
    ]
  },
  ".\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_6",
      "meta": {
        "n": 6,
        "longN": "1.6"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.6"
            ]
          },
          ". ",
          "Теорема Кантора",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nКлассический пример неравномощных бесконечных множеств (до сих пор такого примера у нас не было!) даёт «диагональная конструкция ",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Кантора"
    ]
  },
  "».\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_01...",
      "meta": {
        "n": 7
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 7 (Кантора)"
        ]
      },
      ". ",
      "Множество бесконечных последовательностей нулей и единиц несчётно.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПредположим, что оно счётно.\nТогда все последовательности нулей и единиц можно перенумеровать: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_0, \\alpha_1, \\dots"
    ]
  },
  "\nСоставим бесконечную вниз таблицу, строками которой будут наши последовательности:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{matrix}\n\\alpha_0 & = & \\underline{\\alpha_{00}} & \\alpha_{01} & \\alpha_{02} & \\dots \\\\\n\\alpha_1 & = & \\alpha_{10} & \\underline{\\alpha_{11}} & \\alpha_{12} & \\dots \\\\\n\\alpha_2 & = & \\alpha_{20} & \\alpha_{21} & \\underline{\\alpha_{22}} & \\dots \\\\\n\\dots & \\dots & \\dots & \\dots & \\dots & \\dots\n\\end{matrix}\n"
    ]
  },
  "\n(через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_{ij}"
    ]
  },
  " мы обозначаем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "j"
    ]
  },
  "-й член ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  "-й последовательности).\nТеперь рассмотрим последовательность, образованную стоящими на диагонали членами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_{00}, \\alpha_{11}, \\alpha_{22}, \\dots"
    ]
  },
  ";\nеё ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  "-й член есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_{ii}"
    ]
  },
  " и совпадает с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  "-м членом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  "-й последовательности.\nЗаменив все члены на противоположные, мы получим последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ", у которой\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\beta_i = 1 - \\alpha_{ii},\n"
    ]
  },
  "\nтак что последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  " отличается от любой из последовательностей ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_i"
    ]
  },
  " (в позиции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ") и потому отсутствует в таблице.\nЭто противоречит нашему предположению о том, что таблица включает в себя все последовательности.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nИз этой теоремы следует, что множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R"
    ]
  },
  " действительных чисел\n(которое, как мы видели, равномощно множеству последовательностей нулей и единиц) несчётно.\nВ частности, оно не может совпадать со счётным множеством алгебраических чисел и потому существует действительное число, не являющееся алгебраическим (не являющееся корнем никакого ненулевого многочлена с целочисленными коэффициентами). Такие числа называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "трансцендентными"
    ]
  },
  ".\n\n\nК моменту создания Кантором теории множеств уже было известно, что такие числа существуют.\nПервый пример такого числа построил в 1844 году французский математик ",
  {
    "name": "label",
    "props": {
      "ref": "name_liouville"
    },
    "children": [
      "Ж. Лиувилль"
    ]
  },
  ".\nОн показал, что число, хорошо приближаемое рациональными, не может быть алгебраическим\n(таково, например, число ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sum(1 / 10^{n!})"
    ]
  },
  ").\nДоказательство теоремы Лиувилля не очень сложно, но всё-таки требует некоторых оценок погрешности приближения; на его фоне доказательство Кантора, опубликованное им в 1874 году, выглядит чистой воды фокусом.\nЭта публикация была первой работой по теории множеств; в её первом параграфе доказывается счётность множества алгебраических чисел, а во втором — несчётность множества действительных чисел.\n(Общее определение равномощности было дано Кантором лишь через три года, одновременно с доказательством равномощности пространств разного числа измерений, о котором мы уже говорили.)\n\n\nОтметим кстати, что в том же 1874 году французский математик ",
  {
    "name": "label",
    "props": {
      "ref": "name_hermite"
    },
    "children": [
      "Ш. Эрмит"
    ]
  },
  " доказал, что основание натуральных логарифмов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "e = 2,71828\\mathellipsis"
    ]
  },
  " трансцендентно, а через восемь лет немецкий математик ",
  {
    "name": "label",
    "props": {
      "ref": "name_lindemann"
    },
    "children": [
      "Ф. Линдеман"
    ]
  },
  " доказал трансцендентность числа ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\pi = 3,1415\\mathellipsis"
    ]
  },
  " и тем самым невозможность квадратуры круга.\n\n\nВ нескольких следующих задачах мы предполагаем известными некоторые начальные сведения из курса математического анализа.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_54",
      "meta": {
        "n": 54
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "54"
            ]
          },
          ". ",
          "\nПокажите, что для всякого несчётного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\sub \\R"
            ]
          },
          " можно указать точку ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a"
            ]
          },
          ", любая окрестность которой пересекается с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " по несчётному множеству.\n(Утверждение остаётся верным, если слова «несчётное множество» заменить на «множество мощности континуума».)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_55",
      "meta": {
        "n": 55
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "55"
            ]
          },
          ". ",
          "Покажите, что любое непустое замкнутое множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\sub \\R"
            ]
          },
          " без изолированных точек имеет мощность континуума.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_56",
      "meta": {
        "n": 56
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "56"
            ]
          },
          ". ",
          "\nПокажите, что любое замкнутое множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\sub \\R"
            ]
          },
          " либо конечно, либо счётно, либо имеет мощность континуума.\n(Указание. Рассмотрим множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B \\sub A"
            ]
          },
          ", состоящее из тех точек множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", в любой окрестности которых несчётно много других точек из ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " пусто, то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " конечно или счётно.\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " непусто, то оно замкнуто и не имеет изолированных точек.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЭта задача показывает, что для замкнутых подмножеств прямой верна гипотеза континуума, утверждающая, что любое подмножество прямой либо конечно, либо счётно, либо равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R"
    ]
  },
  ".\n(",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Кантор"
    ]
  },
  ", доказавший этот факт, рассматривал его как первый шаг к доказательству гипотезы континуума для общего случая, но из этого ничего не вышло.)\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_57",
      "meta": {
        "n": 57
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "57"
            ]
          },
          ". ",
          "\nИз плоскости выбросили произвольное счётное множество точек.\nДокажите, что оставшаяся часть плоскости линейно связна и, более того, любые две невыброшенные точки можно соединить двухзвенной ломаной, не задевающей выброшенных точек.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВернёмся к диагональной конструкции.\nМы знаем, что множество последовательностей нулей и единиц равномощно множеству подмножеств натурального ряда (каждому подмножеству соответствует его «характеристическая последовательность», у которой единицы стоят на местах из этого подмножества).\nПоэтому можно переформулировать эту теорему так:\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "Множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\N"
        ]
      },
      " не равномощно множеству своих подмножеств."
    ]
  },
  "\n\n\nДоказательство также можно шаг за шагом перевести на такой язык: пусть они равномощны; тогда есть взаимно однозначное соответствие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i \\mapsto A_i"
    ]
  },
  " между натуральными числами и подмножествами натурального ряда.\nДиагональная последовательность в этих терминах представляет собой множество тех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i \\in A_i"
    ]
  },
  ", а последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ", отсутствовавшая в перечислении, теперь будет его дополнением (",
  {
    "name": "math",
    "props": {},
    "children": [
      "B = \\{i\\ |\\ i \\notin A_i\\}"
    ]
  },
  ").\n\n\nПри этом оказывается несущественным, что мы имеем дело с натуральным рядом, и мы приходим к такому утверждению:\n\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_x!=2^x",
      "meta": {
        "n": 8
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 8 (общая формулировка теоремы Кантора)"
        ]
      },
      ". ",
      "Никакое множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "X"
        ]
      },
      " не равномощно множеству всех своих подмножеств.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi"
    ]
  },
  " — взаимно однозначное соответствие между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " и множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P(X)"
    ]
  },
  " всех подмножеств множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ".\nРассмотрим те элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X"
    ]
  },
  ", которые не принадлежат соответствующему им подмножеству.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  " — образованное ими множество:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nZ = \\{x \\in X\\ |\\ x \\notin \\varphi(x)\\}.\n"
    ]
  },
  "\nДокажем, что подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  " не соответствует никакому элементу множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ".\nПусть это не так и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z = \\varphi(z)"
    ]
  },
  " для некоторого элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z \\in X"
    ]
  },
  ".\nТогда\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nz \\in Z \\lrArr z \\notin \\varphi(z) \\lrArr z \\notin Z\n"
    ]
  },
  "\nпервое — по построению множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  ", второе — по предположению ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi(z) = Z"
    ]
  },
  ").\nПолученное противоречие показывает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  " действительно ничему не соответствует, так что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi"
    ]
  },
  " не взаимно однозначно.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nС другой, стороны, любое множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " равномощно некоторой части множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P(X)"
    ]
  },
  ".\nВ самом деле, каждому элементу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X"
    ]
  },
  " можно поставить в соответствие одноэлементное подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x\\}"
    ]
  },
  ".\nПоэтому, вспоминая ",
  {
    "name": "label",
    "props": {
      "ref": "set-size-variants"
    },
    "children": [
      "определение"
    ]
  },
  " сравнения множеств по мощности ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "(с. 24)"
    ]
  },
  ", можно сказать, что мощность множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " всегда меньше мощности множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P(X)"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_58",
      "meta": {
        "n": 58
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "58"
            ]
          },
          ". ",
          "Докажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n < 2^n"
            ]
          },
          " для всех натуральных ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n = 0, 1, 2, \\dots"
            ]
          },
          "",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВ общей формулировке ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_x!=2^x"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_x!=2^x",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " появляется в работе Кантора 1890/91 года.\nВместо подмножеств ",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Кантор"
    ]
  },
  " говорит о функциях, принимающих значения 0 и 1.\n\n\nНа самом деле мы уже приблизились к опасной границе, когда наглядные представления о множествах приводят к противоречию.\nВ самом деле, рассмотрим множество всех множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  ", элементами которого являются все множества.\nТогда, в частности, все подмножества множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "U"
    ]
  },
  " будут его элементами, и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P(U) \\sub U"
    ]
  },
  ", что невозможно по теореме Кантора.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "russell-paradox"
    },
    "children": [
      "\nЭто рассуждение можно развернуть, вспомнив доказательство теоремы Кантора — получится так называемый парадокс ",
      {
        "name": "label",
        "props": {
          "ref": "name_russell"
        },
        "children": [
          "Рассела"
        ]
      },
      ".\nВот как его обычно излагают.\n\n\nКак правило, множество не является своим элементом.\nСкажем, множество натуральных чисел ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\N"
        ]
      },
      " само не является натуральным числом и потому не будет своим элементом.\nОднако в принципе можно себе представить и множество, которое является своим элементом (например, множество всех множеств).\nНазовём такие множества «необычными».\nРассмотрим теперь множество всех обычных множеств.\nБудет ли оно обычным?\nЕсли оно обычное, то оно является своим элементом и потому необычное, и наоборот.\nКак же так?"
    ]
  },
  "\n\n\nМодифицированная версия этого парадокса такова: будем называть прилагательное самоприменимым, если оно обладает описываемым свойством.\nНапример, прилагательное «русский» самоприменимо, а прилагательное «глиняный» нет.\nДругой пример: прилагательное «трёхсложный» самоприменимо, а «двусложный» нет.\nТеперь вопрос: будет ли прилагательное «несамоприменимый» самоприменимым?\n(Любой ответ очевидно приводит к противоречию.)\n\n\nОтсюда недалеко до широко известного «парадокса лжеца», говорящего «я лгу», или до истории о солдате, который должен был брить всех солдат одной с ним части, кто не бреется сам и т. п.\n\n\nВозвращаясь к теории множеств, мы обязаны дать себе отчёт в том, что плохого было в рассуждениях, приведших к парадоксу Рассела.\nВопрос этот далеко не простой, и его обсуждение активно шло всю первую половину 20-го века.\nИтоги этого обсуждения приблизительно можно сформулировать так:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПонятие множества не является непосредственно очевидным; разные люди (и научные традиции) могут понимать его по-разному\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножества — слишком абстрактные объекты для того, чтобы вопрос «а что на самом деле?» имел смысл.\n",
          {
            "name": "area",
            "props": {
              "key": "сontinuum-hypothesis",
              "inline": true
            },
            "children": [
              "Например, в работе Кантора 1878 года была сформулирована ",
              {
                "name": "format.i",
                "props": {},
                "children": [
                  "континуум-гипотеза"
                ]
              },
              ": всякое подмножество отрезка либо конечно, либо счётно, либо равномощно всему отрезку."
            ]
          },
          "\n(Другими словами, между счётными множествами и множествами мощности континуум нет промежуточных мощностей).\nКантор написал, что это может быть доказано «с помощью некоторого метода индукции, в изложение которого мы не будем входить здесь подробнее», но на самом деле доказать это ему не удалось.\nБолее того, постепенно стало ясно, что утверждение континуум-гипотезы можно считать истинным или ложным, — при этом получаются разные теории множеств, но в общем-то ни одна из этих теорий не лучше другой.\n\n\nТут есть некоторая аналогия с неевклидовой геометрией.\nМы можем считать «пятый постулат ",
          {
            "name": "label",
            "props": {
              "ref": "name_euclid"
            },
            "children": [
              "Евклида"
            ]
          },
          "» (через данную точку проходит не более одной прямой, параллельной данной) истинным.\nТогда получится геометрия, называемая евклидовой.\nА можно принять в качестве аксиомы противоположное утверждение: через некоторую точку можно провести две различные прямые, параллельные некоторой прямой.\nТогда получится неевклидова геометрия.\n[Отметим, кстати, распространённое заблуждение: почему-то широкие массы писателей о науке и даже отдельные математики в минуты затмений (см. статью в Вестнике Академии Наук, посвящённую юбилею ",
          {
            "name": "label",
            "props": {
              "ref": "name_lobachevski"
            },
            "children": [
              "Лобачевского"
            ]
          },
          ") считают, что в неевклидовой геометрии параллельные прямые пересекаются.\nЭто не так — параллельные прямые и в евклидовой, и в неевклидовой геометрии определяются как прямые, которые не пересекаются.]\n\n\nВопрос о том, евклидова или неевклидова геометрия правильна «на самом деле», если вообще имеет смысл, не является математическим — скорее об этом следует спрашивать физиков.\nК теории множеств это относится в ещё большей степени, и разве что теология (Кантор неоднократно обсуждал вопросы теории множеств с профессионалами-теологами) могла бы в принципе претендовать на окончательный ответ.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЕсли мы хотим рассуждать о множествах, не впадая в противоречия, нужно проявлять осторожность и избегать определённых видов рассуждений.\nБезопасные (по крайней мере пока не приведшие к противоречию) правила обращения со множествами сформулированы в аксиоматической теории множеств (формальная теория ZF, названная в честь ",
          {
            "name": "label",
            "props": {
              "ref": "name_zermelo"
            },
            "children": [
              "Цермело"
            ]
          },
          " и ",
          {
            "name": "label",
            "props": {
              "ref": "name_fraenkel"
            },
            "children": [
              "Френкеля"
            ]
          },
          ").\nДобавив к этой теории аксиому выбора, получаем теорию, называемую ZFC (сhoice по-английски — выбор).\nЕсть и другие, менее популярные теории.\n"
        ]
      },
      "\n"
    ]
  },
  "\n\nОднако формальное построение теории множеств выходит за рамки нашего обсуждения.\nПоэтому мы ограничимся неформальным описанием ограничений, накладываемых во избежание противоречий: нельзя просто так рассмотреть множество всех множеств или множество всех множеств, не являющихся своими элементами, поскольку класс потенциальных претендентов слишком «необозрим».\nМножества можно строить лишь постепенно, исходя из уже построенных множеств.\nНапример, можно образовать множество всех подмножеств данного множества (",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "аксиома степени"
    ]
  },
  ").\nМожно рассмотреть подмножество данного множества, образованное элементами с каким-то свойством (",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "аксиома выделения"
    ]
  },
  ").\nМожно рассмотреть множество всех элементов, входящих хотя бы в один из элементов данного множества (",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "аксиома суммы"
    ]
  },
  ").\nЕсть и другие аксиомы.\n\n\nИзлагая сведения из теории множеств, мы будем стараться держаться подальше от опасной черты, и указывать на опасность в тех местах, когда возникнет искушение к этой черте приблизиться.\nПока что такое место было одно: попытка определить мощность множества как класс (множество) всех равномощных ему множеств.\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_7",
      "meta": {
        "n": 7,
        "longN": "1.7"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.7"
            ]
          },
          ". ",
          "Функции",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nДо сих пор мы старались ограничиваться минимумом формальностей и говорили о функциях, их аргументах, значениях, композиции и т.п. без попыток дать определения этих понятий.\nСейчас мы дадим формальные определения.\n\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — два множества.\nРассмотрим множество всех упорядоченных пар ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a, b \\rang"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  ".\nЭто множество называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "декартовым произведением"
    ]
  },
  " множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times B"
    ]
  },
  ".\n(К вопросу о том, что такое ",
  {
    "name": "label",
    "props": {
      "ref": "x->y"
    },
    "children": [
      "упорядоченная пара"
    ]
  },
  ", мы ещё вернёмся ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "на с. 36."
    ]
  },
  ")\n\n\nЛюбое подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "R"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times B"
    ]
  },
  " называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "отношением"
    ]
  },
  " между множествами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A = B"
    ]
  },
  ", говорят о ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "бинарном отношении"
    ]
  },
  " на множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nНапример, на множестве натуральных чисел можно рассмотреть бинарное отношение «быть делителем», обычно обозначаемое символом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|"
    ]
  },
  ".\nТогда можно в принципе было бы написать ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang 2, 6 \\rang \\in |"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang 2, 7 \\rang \\notin |"
    ]
  },
  ".\nОбычно, однако, знак отношения пишут между объектами (например, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2|6"
    ]
  },
  ").\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_59",
      "meta": {
        "n": 59
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "59"
            ]
          },
          ". ",
          "\nВопрос для самоконтроля: отношения «быть делителем» и «делиться на» — это одно и то же отношение или разные?\n(Ответ: конечно, разные — в упорядоченной паре порядок существен.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЕсли аргументами функции являются элементы множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", а значениями — элементы множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", то можно рассмотреть отношение между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", состоящее из пар вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x, f(x) \\rang"
    ]
  },
  ".\nПо аналогии с графиками функций на плоскости такое множество можно назвать графиком функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ".\nС формальной точки зрения, однако, удобнее не вводить отдельного неопределяемого понятия функции, а вместо этого отождествить функцию с её графиком.\n\n\nОтношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F \\sub A \\times B"
    ]
  },
  " называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "функцией"
    ]
  },
  " из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", если оно не содержит пар с одинаковым первым членом и разными вторыми.\nДругими словами, это означает, что для каждого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  " существует не более одного ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  ", при котором ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a, b \\rang \\in F"
    ]
  },
  ".\n\n\nТе элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  ", для которых такое ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " существует, образуют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "область определения"
    ]
  },
  " функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F"
    ]
  },
  ".\nОна обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{Dom}\\ F"
    ]
  },
  " (от английского слова domain).\nДля любого элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in \\mathrm{Dom}\\ F"
    ]
  },
  " можно определить ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "значение"
    ]
  },
  " функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F"
    ]
  },
  " на аргументе ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " («в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  "», как иногда говорят) как тот единственный элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a, b \\rang \\in F"
    ]
  },
  ".\nЭтот элемент записывают как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F(a)"
    ]
  },
  ".\nВсе такие элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " образуют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "множество значений"
    ]
  },
  " функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F"
    ]
  },
  ", которое обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{Val}\\ F"
    ]
  },
  ".\n\n\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\notin \\mathrm{Dom}\\ F"
    ]
  },
  ", то говорят, что функция ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "не определена"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ".\nЗаметим, что по нашему определению функция из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " не обязана быть определена на всех элементах множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " — её область определения может быть любым подмножеством множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nСимметричным образом множество её значений может не совпадать с множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\n\n\nЕсли область определения функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " совпадает с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", то пишут ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  ".\n\n\nПример: ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "тождественная"
    ]
  },
  " функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "id_A: A \\to A"
    ]
  },
  " переводит множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " в себя, причём ",
  {
    "name": "math",
    "props": {},
    "children": [
      "id(a) = a"
    ]
  },
  " для любого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  ".\nОна представляет собой множество пар вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a, a \\rang"
    ]
  },
  " для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  ".\n(Индекс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "id_A"
    ]
  },
  " иногда опускают, если ясно, о каком множестве идёт речь.)\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "Композицией"
    ]
  },
  " двух функций ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g: B \\to C"
    ]
  },
  " называют функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h: A \\to C"
    ]
  },
  ", определённую соотношением ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h(x) = g(f(x))"
    ]
  },
  ".\nДругими словами, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h"
    ]
  },
  " представляет собой множество пар\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\{\\lang a, c \\rang \\ | \\ \\lang a, b \\rang \\in f \\ \\text{и} \\ \\lang b, c \\rang \\in g \\ \\text{для некоторого} \\ b \\in B\\}.\n"
    ]
  },
  "\nКомпозиция функций обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g \\circ f"
    ]
  },
  " (мы, как и в большинстве книг, пишем справа функцию, которая применяется первой).\n\n\nОчевидно, композиция (как операция над функциями) ассоциативна, то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h \\circ (f \\circ g) = (h \\circ f) \\circ g"
    ]
  },
  ", поэтому в композиции нескольких подряд идущих функций можно опускать скобки.\n\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  ".\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "Прообразом"
    ]
  },
  " подмножества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B' \\sub B"
    ]
  },
  " называется множество всех элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in A"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x) \\in B'"
    ]
  },
  ".\nОно обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f^{-1}(B')"
    ]
  },
  ":\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nf^{-1}(B') = \\{x \\in A \\ | \\ f(x) \\in B'\\}.\n"
    ]
  },
  "\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "Образом"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A' \\sub A"
    ]
  },
  " называется множество всех значений функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " на всех элементах множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A'"
    ]
  },
  ".\nОно обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(A')"
    ]
  },
  ":\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nf(A') = \\{f(a) \\ | \\ a \\in A'\\} = \\{b \\in B \\ | \\ \\lang a, b \\rang \\in f \\ \\text{для некоторого} \\ a \\in A'\\}.\n"
    ]
  },
  "\nСтрого говоря, обозначение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(A')"
    ]
  },
  " может привести к путанице (одни и те же круглые скобки употребляются и для значения функции, и для образа множества), но обычно ясно, что имеется в виду.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_60",
      "meta": {
        "n": 60
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "60"
            ]
          },
          ". ",
          "\nКакие из следующих равенств верны?\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n\\begin{aligned}\nf(A' \\cap A'') &= f(A') \\cup f(A''); \\\\\nf(A' \\cup A'') &= f(A') \\cup f(A''); \\\\\nf(A' \\setminus A'') &= f(A') \\setminus f(A''); \\\\\nf^{-1}(B' \\cap B'') &= f^{-1}(B') \\cap f^{-1}(B''); \\\\\nf^{-1}(B' \\cup B'') &= f^{-1}(B') \\cup f^{-1}(B''); \\\\\nf^{-1}(B' \\setminus B'') &= f^{-1}(B') \\setminus f^{-1}(B''); \\\\\nf^{-1}(f(A')) &\\subset A'; \\\\\nf^{-1}(f(A')) &\\supset A'; \\\\\nf(f^{-1}(B')) &\\subset B'; \\\\\nf(f^{-1}(B')) &\\supset B'; \\\\\n(g \\circ f)(A) &= g(f(A)); \\\\\n(g \\circ f)^{-1}(C') &= f^{-1}(g^{-1}(C'));\n\\end{aligned}\n"
            ]
          },
          "\n(Здесь ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f: A \\to B, g: B \\to C, A', A'' \\sub A, B', B'' \\sub B, C' \\sub C"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nИногда вместо функций говорят об отображениях (резервируя термин «функция» для отображений с числовыми аргументами и значениями).\nМы не будем строго придерживаться таких различий, употребляя слова «отображение» и «функция» как синонимы.\n\n\nФункция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  " называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "инъективной"
    ]
  },
  ", или ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "инъекцией"
    ]
  },
  ", или ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "вложением"
    ]
  },
  ", если она переводит разные элементы в разные, то есть если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(a_1) \\not = f(a_2)"
    ]
  },
  " при различных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_2"
    ]
  },
  ".\n\n\nФункция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  " называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "сюръективной"
    ]
  },
  ", или ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "сюръекцией"
    ]
  },
  ", или ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "наложением"
    ]
  },
  ", если множество её значений есть всё ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\n(Иногда такие функции называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "отображениями"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".)\n\n\nЭти два определения более симметричны, чем может показаться на первый взгляд, как показывают такие задачи:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_61",
      "meta": {
        "n": 61
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "61"
            ]
          },
          ". ",
          "\nДокажите, что функция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f: A \\to B"
            ]
          },
          " является вложением тогда и только тогда, когда она имеет ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "левую обратную"
            ]
          },
          " функцию ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g: B \\to A"
            ]
          },
          ", то есть функцию ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g"
            ]
          },
          ", для которой ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g \\circ f = id_A"
            ]
          },
          ".\nДокажите, что функция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f: A \\to B"
            ]
          },
          " является наложением тогда и только тогда, когда она имеет ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "правую обратную"
            ]
          },
          " функцию ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g: B \\to A"
            ]
          },
          ", для которой ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f \\circ g = id_B"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_62",
      "meta": {
        "n": 62
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "62"
            ]
          },
          ". ",
          "\nДокажите, что функция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f: A \\to B"
            ]
          },
          " является вложением тогда и только тогда, когда на неё можно сокращать слева: из равенства ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f \\circ g_1 = f \\circ g_2"
            ]
          },
          " следует равенство ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g_1 = g_2"
            ]
          },
          "\n(для любых функций ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g_1"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g_2"
            ]
          },
          ", области значений которых содержатся в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ").\nДокажите, что функция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f: A \\to B"
            ]
          },
          " является наложением тогда и только тогда, когда на неё можно сокращать справа: из равенства ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g_1 \\circ f = g_2 \\circ f"
            ]
          },
          " следует равенство ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g_1 = g_2"
            ]
          },
          "\n(для любых функций ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g_1"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "g_2"
            ]
          },
          ", область определения которых есть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ").\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nОтображение (функция) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  ", которое одновременно является инъекцией и сюръекцией (вложением и наложением), называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "биекцией"
    ]
  },
  ", или взаимно однозначным соответствием.\n\n\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " — биекция, то существует обратная функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f^{-1}"
    ]
  },
  ", для которой ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f^{-1}(y) = x \\lrArr f(x) = y"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_63",
      "meta": {
        "n": 63
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "63"
            ]
          },
          ". ",
          "Могут ли для некоторой функции левая и правая обратные существовать, но быть различны?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nНапомним, что множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " равномощны, если существует биекция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  ".\nВ каком случае существует инъекция (вложение) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  "?\nЛегко понять, что вложение является взаимно однозначным соответствием между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и некоторым подмножеством множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", поэтому такое вложение существует тогда и только тогда, когда в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " есть подмножество, равномощное ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", т. е. когда мощность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " не превосходит мощности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " (в смысле определения, данного ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_<>="
    },
    "children": [
      "ранее"
    ]
  },
  ").\n\n\nЧуть менее очевиден другой результат: наложение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " существует тогда и только тогда, когда мощность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " не превосходит мощности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\n\n\nВ самом деле, пусть наложение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  " существует.\nДля каждого элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  " найдётся хотя бы один элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(a) = b"
    ]
  },
  ".\nВыбрав по одному такому элементу, мы получим подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A' \\subset A"
    ]
  },
  ", которое находится во взаимно однозначном соответствии с множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\n(Здесь снова используется ",
  {
    "name": "label",
    "props": {
      "ref": "choice-axiom"
    },
    "children": [
      "аксиома выбора"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      ", о которой мы говорили на с. 14."
    ]
  },
  ")\n\n\nВ обратную сторону: если какое-то подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A'"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " равномощно множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и имеется биекция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "g: A' \\to B"
    ]
  },
  ", то наложение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " можно получить, доопределив эту биекцию на элементах вне ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A'"
    ]
  },
  " каким угодно образом.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_64",
      "meta": {
        "n": 64
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "64"
            ]
          },
          ". ",
          "Найдите ошибку в этом рассуждении, не читая дальше.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nНа самом деле такое продолжение возможно, только если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " непусто, так что правильное утверждение звучит так: наложение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " существует только и только тогда, когда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " непусто и равномощно некоторому подмножеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", или когда оба множества пусты.\n\n",
  {
    "name": "area",
    "props": {
      "key": "x->y"
    },
    "children": [
      "\nВ нашем изложении остаётся ещё один не вполне понятный момент: что такое «упорядоченная пара»?\nНеформально говоря, это способ из двух объектов ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "y"
        ]
      },
      " образовать один объект ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\lang x, y \\rang"
        ]
      },
      ", причём этот способ обладает таким свойством:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\lang x_1, y_1 \\rang = \\lang x_2, y_2 \\rang \\lrArr x_1 = x_2 \\ \\text{и} \\ y_1 = y_2.\n"
        ]
      },
      "\n"
    ]
  },
  "\nВ принципе, можно так и считать понятие упорядоченной пары неопределяемым, а это свойство — аксиомой.\nОднако при формальном построении теории множеств удобно использовать трюк, придуманный польским математиком ",
  {
    "name": "label",
    "props": {
      "ref": "name_kuratowski"
    },
    "children": [
      "Куратовским"
    ]
  },
  ", и избежать появления отдельного понятия упорядоченной пары.\nПрежде чем описывать этот трюк, напомним, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x\\}"
    ]
  },
  " обозначает множество, единственным элементом которого является ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x, y\\}"
    ]
  },
  " обозначает множество, которое содержит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  " и не содержит других элементов.\nТем самым ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x, y\\} = \\{x\\} = \\{y\\}"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x = y"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_(x)-(x-y)",
      "meta": {
        "n": 9
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 9 (Упорядоченная пара по Куратовскому)"
        ]
      },
      ". ",
      "\nОпределим ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\lang x, y \\rang"
        ]
      },
      " как ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\{\\{x\\}, \\{x, y\\}\\}"
        ]
      },
      ".\nТогда выполнено указанное выше свойство:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\lang x_1, y_1 \\rang = \\lang x_2, y_2 \\rang \\lrArr x_1 = x_2 \\ \\text{и} \\ y_1 = y_2.\n"
        ]
      },
      "\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВ одну сторону это очевидно: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 = x_2"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y_1 = y_2"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x_1, y_1 \\rang = \\lang x_2, y_2 \\rang"
    ]
  },
  ".\nВ другую сторону: пусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x_1, y_1 \\rang = \\lang x_2, y_2 \\rang"
    ]
  },
  ".\nПо определению это означает, что\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\{\\{x_1\\}, \\{x_1, y_1\\}\\} = \\{\\{x_2\\}, \\{x_2, y_2\\}\\}.\n"
    ]
  },
  "\nТеперь нужно аккуратно разобрать случаи (не путая при этом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x\\}"
    ]
  },
  ").\nЭто удобно делать в следующем порядке.\nПусть сначала ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 \\not = y_1"
    ]
  },
  ".\nТогда множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x_1, y_1\\}"
    ]
  },
  " состоит из двух элементов.\nРаз оно принадлежит левой части равенства, то принадлежит и правой.\nЗначит, оно равно либо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x_2\\}"
    ]
  },
  ", либо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x_2, y_2\\}"
    ]
  },
  ".\nПервое невозможно, так как двухэлементное множество не может быть равно одноэлементному.\nЗначит, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x_1, y_1\\} = \\{x_2, y_2\\}"
    ]
  },
  ".\nС другой стороны, одноэлементное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x_1\\}"
    ]
  },
  " принадлежит левой части равенства, поэтому оно принадлежит и правой, и потому равно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x_2\\}"
    ]
  },
  " (поскольку не может быть равно двухэлементному).\nОтсюда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 = x_2"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y_1 = y_2"
    ]
  },
  ", что и требовалось.\n\n\nАналогично разбирается симметричный случай, когда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_2 \\not = y_2"
    ]
  },
  ".\n\n\nОсталось рассмотреть ситуацию, когда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 = y_1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_2 = y_2"
    ]
  },
  ".\nВ этом случае ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x_1, y_1\\} = \\{x_1\\}"
    ]
  },
  " и потому левая часть данного нам равенства есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{\\{x_1\\}\\}"
    ]
  },
  ".\nАналогичным образом, правая его часть есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{\\{x_2\\}\\}"
    ]
  },
  ", и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 = x_2"
    ]
  },
  ", так что все четыре элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1, x_2, y_1, y_2"
    ]
  },
  " совпадают.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nЗаметим, что возможны и другие определения упорядоченной пары, для которых аналогичное утверждение верно, так что никакого «философского смысла» в этом определении нет — это просто удобный технический приём.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_65",
      "meta": {
        "n": 65
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "65"
            ]
          },
          ". ",
          "\nДокажите утверждение ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_(x)-(x-y)"
            },
            "children": [
              "теоремы ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_(x)-(x-y)",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          " для ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "упорядоченной пары по ",
              {
                "name": "label",
                "props": {
                  "ref": "name_wiener"
                },
                "children": [
                  "Винеру"
                ]
              },
              ""
            ]
          },
          ": ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\lang x, y \\rang = \\{\\{",
              "\\varnothing",
              ", \\{x\\}\\}, \\{\\{y\\}\\}\\}"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_8",
      "meta": {
        "n": 8,
        "longN": "1.8"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "1.8"
            ]
          },
          ". ",
          "Операции над мощностями",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nМощности конечных множеств — натуральные числа, и их можно складывать, умножать, возводить в степень.\nЭти операции можно обобщить и на мощности бесконечных множеств, и делается это так.\n\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — два множества.\nЧтобы сложить их мощности, надо взять мощность множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\cup B"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " не пересекаются.\nЕсли они пересекаются, то их надо заменить на непересекающиеся равномощные им множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B'"
    ]
  },
  ".\nМощность объединения и будет ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "суммой"
    ]
  },
  " мощностей множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Замечания"
    ]
  },
  ".\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "1"
    ]
  },
  ".\nЧтобы избежать упоминания мощностей как самостоятельных объектов, следует считать выражение «мощность множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  " есть сумма мощностей множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "» идиоматическим выражением (а сказанное выше — его определением).\nНо мы для удобства будем часто пренебрегать такими предосторожностями.\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "2"
    ]
  },
  ".\nВ принципе следовало бы проверить корректность этого определения и доказать, что мощность множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A' \\cup B'"
    ]
  },
  " не зависит от того, какие именно непересекающиеся множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B'"
    ]
  },
  " (равномощные ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ") мы выберем.\n(Что, впрочем, очевидно.)\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "3"
    ]
  },
  ".\nДля конечных множеств получается обычное сложение натуральных чисел.\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "4"
    ]
  },
  ".\nНаконец, формально следовало бы ещё доказать, что такие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B'"
    ]
  },
  " можно выбрать.\nЭто можно сделать, например, так: положим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A' = A \\times \\{0\\}"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B' = B \\times \\{1\\}"
    ]
  },
  ".\n\n\nПоследней проблемы не будет при определении ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "произведения"
    ]
  },
  " мощностей как мощности декартова произведения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times B"
    ]
  },
  ".\n(Но остальные замечания остаются в силе.)\n\n\nТеперь определим ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "возведение в степень"
    ]
  },
  ".\nДля этого рассмотрим (для данных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ") множество всех функций вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: B \\to A"
    ]
  },
  "\n(напомним: это означает, что их область определения есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", а область значений содержится в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ").\nЭто множество обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^B"
    ]
  },
  ", и его мощность и будет результатом операции возведения в степень.\n\n\nЕсли множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " конечны и содержат ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " элементов соответственно, то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^B"
    ]
  },
  " содержит как раз ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a^b"
    ]
  },
  " элементов.\nВ самом деле, определяя функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: B \\to A"
    ]
  },
  ", мы должны определить её значение на каждом из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " элементов.\nЭто можно сделать ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " способами, так что получаем всего ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a^b"
    ]
  },
  " вариантов.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_66",
      "meta": {
        "n": 66
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "66"
            ]
          },
          ". ",
          "Чему равно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "0^0"
            ]
          },
          " согласно нашему определению? (Ответ: единице.)",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Пример"
    ]
  },
  ".\nОбозначим через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2"
    ]
  },
  " какое-нибудь множество из двух элементов, например, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{0, 1\\}"
    ]
  },
  ".\nЧто такое ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2^{\\N}"
    ]
  },
  "?\nПо определению это множество функций ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: \\N \\to \\{0, 1\\}"
    ]
  },
  ".\nТакие функции — это по существу последовательности нулей и единиц, только вместо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_0 f_1 f_2 \\dots"
    ]
  },
  " мы пишем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(0), f(1), f(2), \\dots"
    ]
  },
  "\n(Формально последовательность элементов некоторого множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " так и определяется — как функция типа ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N \\to X"
    ]
  },
  ".)\n\n\nЗаметим, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2^X"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P(X)"
    ]
  },
  "\n(в частном случае ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X = \\N"
    ]
  },
  " мы это доказывали; для общего случая доказательство такое же).\n\n\nОбычные свойства сложения и умножения (коммутативность, ассоциативность и дистрибутивность) сохраняют силу и для арифметики мощностей:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{aligned}\na + b &= b + a; \\\\\na + (b + c) &= (a + b) + c; \\\\\na \\times b &= b \\times a; \\\\\na \\times (b \\times c) &= (a \\times b) \\times c; \\\\\n(a + b) \\times c &= (a \\times c) + (b \\times c).\n\\end{aligned}\n"
    ]
  },
  "\nФормально их следует читать, избегая слова «мощность» как самостоятельного объекта: например, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\times b = b \\times a"
    ]
  },
  " означает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times A"
    ]
  },
  " равномощны\n(и это легко проверить: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x, y \\rang \\mapsto \\lang y, x \\rang"
    ]
  },
  " будет взаимно однозначным соответствием между ними).\nОстальные свойства доказываются столь же просто.\nЧуть сложнее свойства, включающие возведение в степень:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{aligned}\na^{b + c} &= a^b \\times a^c; \\\\\n(ab)^c &= a^c \\times b^c; \\\\\n(a^b)^c &= a^{b \\times c}.\n\\end{aligned}\n"
    ]
  },
  "\nПроверим первое из них.\nИз чего состоит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^{B + C}"
    ]
  },
  "?\n(Будем считать, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  " не пересекаются.)\nЕго элементами являются функции со значениями в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", определённые на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B + C"
    ]
  },
  ".\nТакая функция состоит из двух частей: своего сужения на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "\n(значения на аргументах из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " остаются теми же, остальные отбрасываются) и своего сужения на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  ".\nТем самым для каждого элемента множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^{B + C}"
    ]
  },
  " мы получаем пару элементов из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^C"
    ]
  },
  ".\nЭто и будет искомое взаимно однозначное соответствие.\n\n\nС соответствием между множествами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(A \\times B)^C"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^C \\times B^C"
    ]
  },
  " мы тоже часто сталкиваемся.\nНапример, элемент множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(\\R \\times \\R)^{\\R}"
    ]
  },
  " есть отображение типа ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R \\to \\R \\times \\R"
    ]
  },
  ", то есть кривая ",
  {
    "name": "math",
    "props": {},
    "children": [
      "t \\mapsto z(t) = \\lang x(t), y(t) \\rang"
    ]
  },
  " на плоскости.\nТакая кривая задаётся парой функций ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x, y: \\R \\to \\R"
    ]
  },
  ".\n\n\nСоответствие между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(A^B)^C"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^{(B \\times C)}"
    ]
  },
  " встречается несколько реже.\nЭлемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f \\in A^{(B \\times C)}"
    ]
  },
  " является отображением ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times C \\to A"
    ]
  },
  ", то есть, в обычной терминологии, функцией двух аргументов (первый из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", второй из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  ").\nЕсли зафиксировать в ней второй аргумент, то получится функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_c: B \\to A"
    ]
  },
  ", определённая соотношением ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_c(b) = f(b, c)"
    ]
  },
  " (точнее, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(\\lang b, c \\rang)"
    ]
  },
  ").\nОтображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c \\mapsto f_c"
    ]
  },
  ", принадлежащее ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(A^B)^C"
    ]
  },
  ", и соответствует элементу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f \\in A^{(B \\times C)}"
    ]
  },
  ".\n(Отчасти сходная конструкция встречается в алгебре, когда многочлен от двух переменных рассматривают как многочлен от одной переменной с коэффициентами в кольце многочленов от второй переменной.)\n\n\nМощность счётного множества символически обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_0"
    ]
  },
  ", мощность континуума (отрезка или множества бесконечных последовательностей нулей и единиц) обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c}"
    ]
  },
  ", так что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c} = 2^{\\alef_0}"
    ]
  },
  "\n\n\n(Естественный вопрос: каков смысл индекса ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_0"
    ]
  },
  "?\nчто такое, скажем, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  "?\nОбычно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  " обозначает наименьшую несчётную мощность (как мы увидим, такая существует).\nГипотеза континуума, о которой мы ",
  {
    "name": "label",
    "props": {
      "ref": "сontinuum-hypothesis"
    },
    "children": [
      "упоминали"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "на с. 30"
    ]
  },
  ", утверждает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c} = \\alef_1"
    ]
  },
  ".)\n\n\nИзвестные нам свойства счётных множеств можно записать так:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alef_0 + n = \\alef_0"
            ]
          },
          " для конечного ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " (объединение счётного и конечного множеств счётно);\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alef_0 + \\alef_0 = \\alef_0"
            ]
          },
          " (объединение двух счётных множеств счётно);\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alef_0 \\times \\alef_0 = \\alef_0"
            ]
          },
          " (объединение счётного числа счётных множеств счётно).\n"
        ]
      },
      "\n"
    ]
  },
  "\nОтсюда можно формально получить многие факты манипуляциями с мощностями.\nНапример, цепочка равенств\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\frak{c} \\times \\frak{c} = 2^{\\alef_0} \\times 2^{\\alef_0} = 2^{\\alef_0 + \\alef_0} = 2^{\\alef_0} = \\frak{c}\n"
    ]
  },
  "\nпоказывает, что прямая и плоскость равномощны.\n\n\nАналогичным образом,\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\frak{c}^{\\alef_0} = (2^{\\alef_0})^{\\alef_0} = 2^{\\alef_0 \\times \\alef_0} = 2^{\\alef_0} = \\frak{c}.\n"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_67",
      "meta": {
        "n": 67
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "67"
            ]
          },
          ". ",
          "\nОбъясните подробно выкладку:\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n\\frak{c} + \\frak{c} = 1 \\times \\frak{c} + 1 \\times \\frak{c} = 2 \\times \\frak{c} = 2^1 \\times 2^{\\alef_0} = 2^{1 + \\alef_0} = 2{\\alef_0} = \\frak{c}.\n"
            ]
          },
          "\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_68",
      "meta": {
        "n": 68
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "68"
            ]
          },
          ". ",
          "Проверьте, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alef_0 \\times \\frak{c} = \\frak{c}"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nПриведённые нами свойства мощностей полезно сочетать с ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_<>="
    },
    "children": [
      "теоремой Кантора–Бернштейна"
    ]
  },
  ".\nНапример, заметим, что\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\frak{c} = 2^{\\alef_0} \\leqslant \\alef_0^{\\alef_0} \\leqslant \\frak{c}^{\\alef_0} = \\frak{c},\n"
    ]
  },
  "\nпоэтому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_0^{\\alef_0} = \\frak{c}"
    ]
  },
  "\n(словами: множество всех бесконечных последовательностей натуральных чисел имеет мощность континуума).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_69",
      "meta": {
        "n": 69
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "69"
            ]
          },
          ". ",
          "\nПоследнее рассуждение неявно использует монотонность операции возведения в степень для мощностей\n(если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a_1 \\leqslant a_2"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a_1^b \\leqslant a_2^b"
            ]
          },
          ").\nПроверьте это и аналогичные свойства для других операций (впрочем, почти очевидные).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_70",
      "meta": {
        "n": 70
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "70"
            ]
          },
          ". ",
          "\nУстановите явное соответствие между последовательностями натуральных чисел и иррациональными числами на отрезке ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(0, 1)"
            ]
          },
          ", используя цепные дроби, то есть дроби вида ",
          {
            "name": "math",
            "props": {},
            "children": [
              "1 / (n_0 + 1 / (n_1 + 1 / (n_2 + \\dots)))"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_71",
      "meta": {
        "n": 71
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "71"
            ]
          },
          ". ",
          "\nПроверьте, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\frak{c}^{\\frak{c}} = \\alef_0^{\\frak{c}} = 2^{\\frak{c}}"
            ]
          },
          ".\n(Напомним, что по теореме Кантора эта мощность больше мощности континуума.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_72",
      "meta": {
        "n": 72
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "72"
            ]
          },
          ". ",
          "\nКакова мощность множества всех непрерывных функций с действительными аргументами и значениями?\nСущественна ли здесь непрерывность?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_73",
      "meta": {
        "n": 73
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "73"
            ]
          },
          ". ",
          "Какова мощность множества всех монотонных функций с действительными аргументами и значениями?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_74",
      "meta": {
        "n": 74
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "74"
            ]
          },
          ". ",
          "\nМожет ли семейство подмножеств натурального ряда быть несчётным, если любые два его элемента имеют конечное пересечение? конечную симметрическую разность?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВпоследствии мы увидим, что для бесконечных мощностей действуют простые правила ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\times b = a + b = max(a, b)"
    ]
  },
  ", но пока этого мы доказать не можем.\nПоэтому в задачах ",
  {
    "name": "label",
    "props": {
      "ref": "problem_square-part"
    },
    "children": [
      "",
      {
        "name": "use",
        "props": {
          "ref": "problem_square-part",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ", ",
  {
    "name": "label",
    "props": {
      "ref": "problem_line-part"
    },
    "children": [
      "",
      {
        "name": "use",
        "props": {
          "ref": "problem_line-part",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " нам пришлось воспользоваться обходным манёвром, чтобы доказать, что из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a + b = \\frak{c}"
    ]
  },
  " следует ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a = \\frak{c}"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b = \\frak{c}"
    ]
  },
  ".\nСледующее утверждение обобщает этот приём:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_cartesian-subset",
      "meta": {
        "n": 10
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 10"
        ]
      },
      ". ",
      "\nЕсли множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A_1 \\times A_2 \\times \\dots \\times A_n"
        ]
      },
      " разбито на непересекающиеся части ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B_1, \\dots , B_n"
        ]
      },
      ", то найдётся такое ",
      {
        "name": "math",
        "props": {},
        "children": [
          "i"
        ]
      },
      ", при котором мощность ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B_i"
        ]
      },
      " не меньше мощности ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A_i"
        ]
      },
      ".\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВ самом деле, рассмотрим проекцию множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_i \\subset A_1 \\times \\dots \\times A_n"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  ".\nЕсли хотя бы при одном ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  " она покрывает ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  " полностью, то всё доказано.\nЕсли нет, выберем для каждого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  " непокрытую точку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_i"
    ]
  },
  ".\nНабор ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x_1, \\dots , x_n \\rang"
    ]
  },
  " не входит ни в одно из множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_i"
    ]
  },
  ", что противоречит предположению.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nЗаметим, что в формулировке этого утверждения (которое иногда называют теоремой ",
  {
    "name": "label",
    "props": {
      "ref": "name_konig"
    },
    "children": [
      "Кёнига"
    ]
  },
  ") говорится о декартовом произведении конечного числа множеств, которое можно определить индуктивно (скажем, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times B \\times C"
    ]
  },
  " будет состоять из троек ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a, b, c \\rang"
    ]
  },
  ", которые суть пары ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang \\lang a, b \\rang , c \\rang "
    ]
  },
  ").\nДекартово произведение счётного числа множеств уже так не определишь.\nВыход такой: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0 \\times A_1 \\times A_2 \\times \\dots"
    ]
  },
  " (счётное число сомножителей) можно определить как множество всех последовательностей ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_0, a_1, a_2, \\dots"
    ]
  },
  ", у которых ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_i \\in A_i"
    ]
  },
  ", то есть как множество всех функций ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ", определённых на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N"
    ]
  },
  " со значениями в объединении всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  ", причём ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a(i) \\in A_i"
    ]
  },
  " при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ".\nПосле такого определения ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_cartesian-subset"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_cartesian-subset",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " легко переносится и на счётные (а также и на любые) произведения.\n\n\nПереходя к отрицаниям, теорему Кёнига можно сформулировать так: если при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i = 0, 1, 2, \\dots"
    ]
  },
  " для мощностей ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_i"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_i"
    ]
  },
  " выполнено неравенство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_i < a_i"
    ]
  },
  ", то\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nb_0 + b_1 + b_2 + \\ldots < a_0 \\times a_1 \\times a_2 \\times \\ldots\n"
    ]
  },
  "\nУчитывая, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c} \\times \\frak{c} \\times \\dots"
    ]
  },
  " (счётное произведение) равно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c}^{\\alef_0}"
    ]
  },
  ", то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c}"
    ]
  },
  ", можно сформулировать такое следствие теоремы Кёнига: если континуум разбит на счётное число подмножеств, то одно из них имеет мощность континуума.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_75",
      "meta": {
        "n": 75
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "75"
            ]
          },
          ". ",
          "Докажите подробно это утверждение.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_76",
      "meta": {
        "n": 76
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "76"
            ]
          },
          ". ",
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a_0, a_1, a_2, \\dots"
            ]
          },
          " — мощности, причём ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a_i > 2"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "i"
            ]
          },
          ".\nПокажите, что\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\na_0 + a_1 + a_2 + \\ldots \\leqslant a_0 \\times a_1 \\times a_2 \\times \\ldots\n"
            ]
          },
          "\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_77",
      "meta": {
        "n": 77
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "77"
            ]
          },
          ". ",
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m_0 < m_1 < m_2 < \\dots"
            ]
          },
          " — возрастающая последовательность мощностей.\nДокажите, что сумма ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m_0 + m_1 + m_2 + \\dots"
            ]
          },
          " не представима в виде ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a^{\\alef_0}"
            ]
          },
          " ни для какой мощности ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "chapter_2",
      "meta": {
        "n": 2,
        "longN": "2"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 2
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2"
            ]
          },
          ". ",
          "Упорядоченные множества",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_equivalence-order",
      "meta": {
        "n": 1,
        "longN": "2.1"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.1"
            ]
          },
          ". ",
          "Отношения эквивалентности и порядка",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nНапомним, что бинарным отношением на множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " называется подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "R \\subset X \\times X"
    ]
  },
  ";\nвместо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang x_1, x_2 \\rang \\in R"
    ]
  },
  " часто пишут ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 R x_2"
    ]
  },
  ".\n\n\nБинарное отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "R"
    ]
  },
  " на множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "отношением эквивалентности"
    ]
  },
  ", если выполнены следующие свойства:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n(рефлексивность) ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x R x"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\in X"
            ]
          },
          ";\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n(симметричность) ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x R y \\rArr y R x"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x, y \\in X"
            ]
          },
          ";\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n(транзитивность) ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x R y"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y R z \\rArr x R z"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x, y, z \\in X"
            ]
          },
          ".\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n\nИмеет место следующее очевидное, но важное утверждение:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_eql-classes",
      "meta": {
        "n": 11
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 11"
        ]
      },
      ". ",
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ") Если множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "X"
        ]
      },
      " разбито в объединение непересекающихся подмножеств, то отношение «лежать в одном подмножестве» является отношением эквивалентности.\n\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ") Всякое отношение эквивалентности получается описанным способом из некоторого разбиения.\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПервое утверждение совсем очевидно;\nмы приведём доказательство второго, чтобы было видно, где используются все пункты определения эквивалентности.\nИтак, пусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "R"
    ]
  },
  " — отношение эквивалентности.\nДля каждого элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X"
    ]
  },
  " рассмотрим его ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "класс эквивалентности"
    ]
  },
  " — множество всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\in X"
    ]
  },
  ", для которых верно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x R y"
    ]
  },
  ".\n\n\nДокажем, что для двух различных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1, x_2"
    ]
  },
  " такие множества либо не пересекаются, либо совпадают.\nПусть они пересекаются, то есть имеют общий элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  ".\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 R z"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_2 R z"
    ]
  },
  ", откуда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z R x_2"
    ]
  },
  " (симметричность) и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 R x_2"
    ]
  },
  " (транзитивность), а также ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_2 R x_1"
    ]
  },
  " (симметричность).\nПоэтому для любого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  " из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1 R z"
    ]
  },
  " следует ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_2 R z"
    ]
  },
  " (транзитивность) и наоборот.\n\n\nОсталось заметить, что в силу рефлексивности каждый элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " принадлежит задаваемому им классу, то есть действительно всё множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " разбито на непересекающиеся классы.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_78",
      "meta": {
        "n": 78
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "78"
            ]
          },
          ". ",
          "\nПокажите, что требования симметричности и транзитивности можно заменить одним: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x R z"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y R z \\rArr x R y"
            ]
          },
          "\n(при сохранении требования рефлексивности).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_79",
      "meta": {
        "n": 79
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "79"
            ]
          },
          ". ",
          "Сколько различных отношений эквивалентности существует на множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{ 1, 2, 3, 4, 5 \\}"
            ]
          },
          "?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_80",
      "meta": {
        "n": 80
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "80"
            ]
          },
          ". ",
          "\nНа множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "M"
            ]
          },
          " заданы два отношения эквивалентности, обозначаемые ",
          {
            "name": "math",
            "props": {},
            "children": [
              "∼_1"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "∼_2"
            ]
          },
          ", имеющие ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n_1"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n_2"
            ]
          },
          " классов эквивалентности соответственно.\nБудет ли их пересечение ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x ∼ y \\lrArr [(x ∼_1 y) \\ \\text{и} \\ (x ∼_2 y)]"
            ]
          },
          " отношением эквивалентности?\nСколько у него может быть классов?\nЧто можно сказать про объединение отношений?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_81",
      "meta": {
        "n": 81
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "81"
            ]
          },
          ". ",
          "\n(Теорема ",
          {
            "name": "label",
            "props": {
              "ref": "name_ramsey"
            },
            "children": [
              "Рамсея"
            ]
          },
          ") Множество всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "-элементных подмножеств бесконечного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " разбито на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l"
            ]
          },
          " классов (",
          {
            "name": "math",
            "props": {},
            "children": [
              "k, l"
            ]
          },
          " — натуральные числа).\nДокажите, что найдётся бесконечное множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B \\subset A"
            ]
          },
          ", все ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "-элементные подмножества которого принадлежат одному классу.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n(При ",
  {
    "name": "math",
    "props": {},
    "children": [
      "k = 1"
    ]
  },
  " это очевидно: если бесконечное множество разбито на конечное число классов, то один из классов бесконечен.\nПри ",
  {
    "name": "math",
    "props": {},
    "children": [
      "k = 2"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l = 2"
    ]
  },
  "  утверждение можно сформулировать так: из бесконечного множества людей можно выбрать либо бесконечно много попарно знакомых, либо бесконечно много попарно незнакомых.\nКонечный вариант этого утверждения — о том, что среди любых шести людей есть либо три попарно знакомых, либо три попарно незнакомых, — известная задача для школьников.)\n\n\nМножество классов эквивалентности называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "фактор-множеством"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " по отношению эквивалентности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "R"
    ]
  },
  ".\n(Если отношение согласовано с дополнительными структурами на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ", получаются фактор-группы, фактор-кольца и т. д.)\n\n\nОтношения эквивалентности нам не раз ещё встретятся, но сейчас наша основная тема — отношения порядка.\n\n\nБинарное отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  " на множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "отношением частичного порядка"
    ]
  },
  ", если выполнены такие свойства:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n(рефлексивность) ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant x"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\in X"
            ]
          },
          ";\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n(антисимметричность) ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant y"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y \\leqslant x \\rArr x = y"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x, y \\in X"
            ]
          },
          ";\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n(транзитивность) ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant y"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y \\leqslant z \\rArr x \\leqslant z"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x, y, z \\in X"
            ]
          },
          ".\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n(Следуя традиции, мы используем символ ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  " (а не букву) как знак отношения порядка.)\nМножество с заданным на нём отношением частичного порядка называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "частично упорядоченным"
    ]
  },
  ".\n\n\nГоворят, что два элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x, y"
    ]
  },
  " частично упорядоченного множества ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "сравнимы"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant x"
    ]
  },
  ".\nЗаметим, что определение частичного порядка не требует, чтобы любые два элемента множества были сравнимы.\nДобавив это требование, мы получим определение ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "линейного порядка"
    ]
  },
  " (",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "линейно упорядоченного множества"
    ]
  },
  ").\n\n\nПриведём несколько примеров частичных порядков:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Числовые множества с обычным отношением порядка (здесь порядок будет линейным)."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНа множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\R \\times \\R"
            ]
          },
          " всех пар действительных чисел можно ввести частичный порядок, считая, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\lang x_1, x_2 \\rang \\leqslant \\lang y_1, y_2 \\rang"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x_1 \\leqslant y_1"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x_2 \\leqslant y_2"
            ]
          },
          ".\nЭтот порядок уже не будет линейным: пары ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\lang 0, 1 \\rang"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\lang 1, 0 \\rang"
            ]
          },
          " не сравнимы.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНа множестве функций с действительными аргументами и значениями можно ввести частичный порядок, считая, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f \\leqslant g"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f(x) \\leqslant g(x)"
            ]
          },
          " при всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\in \\R"
            ]
          },
          ".\nЭтот порядок не будет линейным.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНа множестве целых положительных чисел можно определить порядок, считая, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant y"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " делит ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          ".\nЭтот порядок тоже не будет линейным.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОтношение «любой простой делитель числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " является также и делителем числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          "» не будет отношением порядка на множестве целых положительных чисел (оно рефлексивно и транзитивно, но не антисимметрично).\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          " — произвольное множество.\nТогда на множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "P(U)"
            ]
          },
          " всех подмножеств множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          " отношение включения ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\subset"
            ]
          },
          " будет частичным порядком.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНа буквах русского алфавита традиция определяет некоторый порядок (а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\leqslant"
            ]
          },
          " б ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\leqslant"
            ]
          },
          " в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\leqslant \\ldots \\leqslant"
            ]
          },
          " я).\nЭтот порядок линеен — про любые две буквы можно сказать, какая из них раньше (при необходимости заглянув в словарь).\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "lexical-order"
            },
            "children": [
              "\nНа словах русского алфавита определён ",
              {
                "name": "format.i",
                "props": {},
                "children": [
                  "лексикографический"
                ]
              },
              " порядок (как в словаре).\nФормально определить его можно так: если слово ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x"
                ]
              },
              " является началом слова ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "y"
                ]
              },
              ", то ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x \\leqslant y"
                ]
              },
              "\n(например, кант ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\leqslant"
                ]
              },
              " кантор).\nЕсли ни одно из слов не является началом другого, посмотрим на первую по порядку букву, в которой слова отличаются: то слово, где эта буква меньше в алфавитном порядке, и будет меньше.\nЭтот порядок также линеен (иначе что бы делали составители словарей?).\n"
            ]
          },
          "\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОтношение равенства ",
          {
            "name": "math",
            "props": {},
            "children": [
              "((x \\leqslant y) \\lrArr (x = y))"
            ]
          },
          " также является отношением частичного порядка, для которого никакие два различных элемента не сравнимы.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПриведём теперь бытовой пример.\nПусть есть множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          " картонных коробок.\nВведём на нём порядок, считая, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant y"
            ]
          },
          ", если коробка ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " целиком помещается внутрь коробки ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          " (или если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          " — одна и та же коробка).\nВ зависимости от набора коробок этот порядок может быть или не быть линейным.\n"
        ]
      },
      "\n"
    ]
  },
  "\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x, y"
    ]
  },
  " — элементы частично упорядоченного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ".\nГоворят, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x < y"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\not = y"
    ]
  },
  ".\nДля этого отношения выполнены такие свойства:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{gathered}\nx \\not < x; \\\\\n(x < y) \\ \\text{и} \\ (y < z) \\rArr x < z.\n\\end{gathered}\n"
    ]
  },
  "\n(Первое очевидно, проверим второе: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x < y"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < z"
    ]
  },
  ", то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y, x \\not = y, y \\leqslant z, y \\not = z"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant z"
    ]
  },
  " по транзитивности; если бы оказалось, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x = z"
    ]
  },
  ", то мы бы имели ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y \\leqslant x"
    ]
  },
  " и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x = y"
    ]
  },
  " по антисимметричности, что противоречит предположению.)\n\n\nТерминологическое замечание: мы читаем знак ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  " как «меньше или равно», а знак ",
  {
    "name": "math",
    "props": {},
    "children": [
      "<"
    ]
  },
  " — как «меньше», неявно подразумевая, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y"
    ]
  },
  " тогда и только тогда, когда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x < y"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x = y"
    ]
  },
  ".\nК счастью, это действительно так.\nЕщё одно замечание: выражение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x > y"
    ]
  },
  " («",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " больше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  "») означает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  ", а выражение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y"
    ]
  },
  " («",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " больше или равно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  "») означает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant x"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_82",
      "meta": {
        "n": 82
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "82"
            ]
          },
          ". ",
          "Объясните, почему не стоит читать ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant y"
            ]
          },
          " как «",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " не больше ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          "».",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВ некоторых книжках отношение частичного порядка определяется как отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "<"
    ]
  },
  ", удовлетворяющее двум указанным свойствам.\nВ этом случае отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y \\lrArr [(x < y) \\ \\text{или} \\ (x = y)]"
    ]
  },
  " является отношением частичного порядка в смысле нашего определения.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_83",
      "meta": {
        "n": 83
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "83"
            ]
          },
          ". ",
          "Проверьте это.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВо избежание путаницы отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "<"
    ]
  },
  " иногда называют отношением ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "строгого порядка"
    ]
  },
  ", а отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  " — отношением ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "нестрогого порядка"
    ]
  },
  ".\nОдно и то же частично упорядоченное множество можно задавать по-разному: можно сначала определить отношение нестрогого порядка ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  " (рефлексивное, антисимметричное и транзитивное) и затем из него получить отношение строгого порядка ",
  {
    "name": "math",
    "props": {},
    "children": [
      "<"
    ]
  },
  ", а можно действовать и наоборот.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_84",
      "meta": {
        "n": 84
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "84"
            ]
          },
          ". ",
          "\nОпуская требование антисимметричности в определении частичного порядка, получаем определение предпорядка.\nДокажите, что любой предпорядок устроен так: множество делится на непересекающиеся классы, при этом ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant y"
            ]
          },
          " для любых двух элементов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x, y"
            ]
          },
          " из одного класса, а на фактор-множестве задан частичный порядок, который и определяет результат сравнения двух элементов из разных классов.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВот несколько конструкций, позволяющих строить одни упорядоченные множества из других.\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Y"
            ]
          },
          " — подмножество частично упорядоченного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(X, \\leqslant)"
            ]
          },
          ".\nТогда на множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Y"
            ]
          },
          " возникает естественный частичный порядок, индуцированный из ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          ".\nФормально говоря,\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n(\\leqslant_Y) = (\\leqslant) \\cap (Y \\times Y).\n"
            ]
          },
          "\nЕсли порядок на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          " был линейным, то и индуцированный порядок на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Y"
            ]
          },
          ", очевидно, будет линейным.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Y"
            ]
          },
          " — два непересекающихся частично упорядоченных множества.\nТогда на их объединении можно определить частичный порядок так: внутри каждого множества элементы сравниваются как раньше, а любой элемент множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          " по определению меньше любого элемента ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Y"
            ]
          },
          ".\nЭто множество естественно обозначить ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X + Y"
            ]
          },
          ".\n(Порядок будет линейным, если он был таковым на каждом из множеств.)\n\n\nЭто же обозначение применяют и для пересекающихся (и даже совпадающих множеств).\nНапример, говоря об упорядоченном множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N + \\N"
            ]
          },
          ", мы берём две непересекающиеся копии натурального ряда ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{0, 1, 2, \\ldots \\}"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{\\overline{0}, \\overline{1}, \\overline{2}, \\ldots \\}"
            ]
          },
          " и рассматриваем множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{0, 1, 2, \\ldots , \\overline{0}, \\overline{1}, \\overline{2}, \\ldots \\}"
            ]
          },
          ", причём ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k \\leqslant \\overline{l}"
            ]
          },
          " при всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l"
            ]
          },
          ", а внутри каждой копии порядок обычный.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "key": "multi-set-order",
              "inline": true
            },
            "children": [
              "\nПусть ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "(X, \\leqslant_X)"
                ]
              },
              " и ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "(Y, \\leqslant_Y)"
                ]
              },
              " — два частично упорядоченных множества.\nМожно определить порядок на произведении ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "X \\times Y"
                ]
              },
              " несколькими способами.\nМожно считать, что ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\lang x_1, y_1 \\rang \\leqslant \\lang x_2, y_2 \\rang"
                ]
              },
              ", если ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x_1 \\leqslant_X x_2"
                ]
              },
              " и ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "y_1 \\leqslant_Y y_2"
                ]
              },
              " (покоординатное сравнение).\nЭтот порядок, однако, не будет линейным, даже если исходные порядки и были линейными: если первая координата больше у одной пары, а вторая у другой, как их сравнить?\nЧтобы получить линейный порядок, договоримся, какая координата будет «главной» и будем сначала сравнивать по ней, а потом (в случае равенства) — по другой.\nЕсли главной считать ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "X"
                ]
              },
              "-координату, то ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\lang x_1, y_1 \\rang \\leqslant \\lang x_2, y_2 \\rang"
                ]
              },
              ", если ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x_1 <_X x_2"
                ]
              },
              " или если ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x_1 = x_2"
                ]
              },
              ", а ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "y_1 \\leqslant_Y y_2"
                ]
              },
              ".\nОднако по техническим причинам удобно считать главной вторую координату.\nГоворя о произведении двух линейно упорядоченных множеств как о линейно упорядоченном множестве, мы в дальнейшем подразумеваем именно такой порядок (сначала сравниваем по второй координате).\n"
            ]
          },
          "\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_85",
      "meta": {
        "n": 85
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "85"
            ]
          },
          ". ",
          "\nДокажите, что в частично упорядоченном множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N \\times \\N"
            ]
          },
          " (порядок покоординатный) нет бесконечного подмножества, любые два элемента которого были бы несравнимы.\nВерно ли аналогичное утверждение для ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z \\times \\Z"
            ]
          },
          "?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_86",
      "meta": {
        "n": 86
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "86"
            ]
          },
          ". ",
          "Докажите аналогичное утверждение для ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N^k"
            ]
          },
          " (порядок покоординатный).",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_87",
      "meta": {
        "n": 87
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "87"
            ]
          },
          ". ",
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          " — конечное множество из ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " элементов.\nРассмотрим множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "P(U)"
            ]
          },
          " всех подмножеств множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "U"
            ]
          },
          ", упорядоченное по включению.\nКакова максимально возможная мощность множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "S \\subset P(U)"
            ]
          },
          ", если индуцированный на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "S"
            ]
          },
          " порядок линеен?\nесли никакие два элемента ",
          {
            "name": "math",
            "props": {},
            "children": [
              "S"
            ]
          },
          " не сравнимы? (Указание: см. ",
          {
            "name": "label",
            "props": {
              "ref": "problem_max-sub-size"
            },
            "children": [
              "задачу ",
              {
                "name": "use",
                "props": {
                  "ref": "problem_max-sub-size",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_88",
      "meta": {
        "n": 88
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "88"
            ]
          },
          ". ",
          "Сколько существует различных линейных порядков на множестве из ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " элементов?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_89",
      "meta": {
        "n": 89
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "89"
            ]
          },
          ". ",
          "\nДокажите, что всякий частичный порядок на конечном множестве можно продолжить до линейного\n(«продолжить» означает, что если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant y"
            ]
          },
          " в исходном порядке, то и в новом это останется так).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_90",
      "meta": {
        "n": 90
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "90"
            ]
          },
          ". ",
          "\nДано бесконечное частично упорядоченное множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          ".\nДокажите, что в нём всегда найдётся либо бесконечное подмножество попарно несравнимых элементов, либо бесконечное подмножество, на котором индуцированный порядок линеен.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_91",
      "meta": {
        "n": 91
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "91"
            ]
          },
          ". ",
          "\n(Конечный вариант предыдущей задачи.)\nДаны целые положительные числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          ".\nДокажите, что во всяком частично упорядоченном множестве мощности ",
          {
            "name": "math",
            "props": {},
            "children": [
              "mn + 1"
            ]
          },
          " можно указать либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m + 1"
            ]
          },
          " попарно несравнимых элементов, либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n + 1"
            ]
          },
          " попарно сравнимых.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_92",
      "meta": {
        "n": 92
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "92"
            ]
          },
          ". ",
          "\nВ строчку написаны ",
          {
            "name": "math",
            "props": {},
            "children": [
              "mn + 1"
            ]
          },
          " различных чисел.\nДокажите, что можно часть из них вычеркнуть так, чтобы осталась либо возрастающая последовательность длины ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m + 1"
            ]
          },
          ", либо убывающая последовательность длины ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n + 1"
            ]
          },
          ".\n(Указание: можно воспользоваться предыдущей задачей.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_93",
      "meta": {
        "n": 93
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "93"
            ]
          },
          ". ",
          "\nРассмотрим семейство всех подмножеств натурального ряда, упорядоченное по включению.\nСуществует ли у него линейно упорядоченное (в индуцированном порядке) подсемейство мощности континуум?\nСуществует ли у него подсемейство мощности континуум, любые два элемента которого несравнимы?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЭлемент частично упорядоченного множества называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "наибольшим"
    ]
  },
  ", если он больше любого другого элемента, и ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "максимальным"
    ]
  },
  ", если не существует большего элемента.\nЕсли множество не является линейно упорядоченным, то это не одно и то же: наибольший элемент автоматически является максимальным, но не наоборот.\n(Одно дело коробка, в которую помещается любая другая, другое — коробка, которая никуда больше не помещается.)\n\n\nЛегко понять, что наибольший элемент в данном частично упорядоченном множестве может быть только один, в то время как максимальных элементов может быть много.\n\n\nАналогично определяют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "наименьшие"
    ]
  },
  " и ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "минимальные"
    ]
  },
  " элементы.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_94",
      "meta": {
        "n": 94
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "94"
            ]
          },
          ". ",
          "\nДокажите, что любые два максимальных элемента не сравнимы.\nДокажите, что в конечном частично упорядоченном множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          " для любого элемента ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " найдётся максимальный элемент ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          ", больший или равный ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/2/2/img5.svg",
      "src": "/data/books/data/vereshagin-shen-sets/2/2/img5.svg"
    },
    "children": []
  },
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_2",
      "meta": {
        "n": 2,
        "longN": "2.2"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.2"
            ]
          },
          ". ",
          "Изоморфизмы",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nДва частично упорядоченных множества называются ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "изоморфными"
    ]
  },
  ", если между ними существует ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "изоморфизм"
    ]
  },
  ", то есть взаимно однозначное соответствие, сохраняющее порядок.\n(Естественно, что в этом случае они равномощны как множества.)\nМожно сказать так: биекция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  " называется изоморфизмом частично упорядоченных множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", если\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\na_1 \\leqslant a_2 \\lrArr f(a_1) \\leqslant f(a_2)\n"
    ]
  },
  "\nдля любых элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_1, a_2 \\in A"
    ]
  },
  " (слева знак ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  " обозначает порядок в множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", справа — в множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ").\n\n\nОчевидно, что отношение изоморфности рефлексивно (каждое множество изоморфно самому себе), симметрично (если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " изоморфно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y"
    ]
  },
  ", то и наоборот) и транзитивно (два множества, изоморфные третьему, изоморфны между собой).\nТаким образом, все частично упорядоченные множества разбиваются на классы изоморфных, которые называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "порядковыми типами"
    ]
  },
  ".\n(Правда, как и с мощностями, тут необходима осторожность — изоморфных множеств слишком много, и потому говорить о порядковых типах как множествах нельзя.)\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_iso-eql-lin",
      "meta": {
        "n": 12
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 12"
        ]
      },
      ". ",
      "Конечные линейно упорядоченные множества из одинакового числа элементов изоморфны.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nКонечное линейно упорядоченное множество всегда имеет наименьший элемент\n(возьмём любой элемент; если он не наименьший, возьмём меньший, если и он не наименьший, ещё меньший — и так далее;\nполучим убывающую последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x > y > z > \\ldots"
    ]
  },
  ", которая рано или поздно должна оборваться).\nПрисвоим наименьшему элементу номер ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1"
    ]
  },
  ".\nИз оставшихся снова выберем наименьший элемент и присвоим ему номер ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2"
    ]
  },
  " и так далее.\nЛегко понять, что порядок между элементами соответствует порядку между номерами, то есть что наше множество изоморфно множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{1, 2, \\dots , n\\}"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_95",
      "meta": {
        "n": 95
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "95"
            ]
          },
          ". ",
          "\nДокажите, что множество всех целых положительных делителей числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "30"
            ]
          },
          " с отношением «быть делителем» в качестве отношения порядка изоморфно множеству всех подмножеств множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\{a, b, c\\}"
            ]
          },
          ", упорядоченному по включению.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_96",
      "meta": {
        "n": 96
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "96"
            ]
          },
          ". ",
          "\nБудем рассматривать финитные последовательности натуральных чисел, то есть последовательности, у которых все члены, кроме конечного числа, равны ",
          {
            "name": "math",
            "props": {},
            "children": [
              "0"
            ]
          },
          ".\nНа множестве таких последовательностей введём покомпонентный порядок: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(a_0, a_1, \\dots ) \\leqslant (b_0, b_1, \\dots )"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a_i \\leqslant b_i"
            ]
          },
          " при всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "i"
            ]
          },
          ".\nДокажите, что это множество изоморфно множеству всех положительных целых чисел с отношением «быть делителем» в качестве порядка.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВзаимно однозначное отображение частично упорядоченного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " в себя, являющееся изоморфизмом, называют автоморфизмом частично упорядоченного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nТождественное отображение всегда является автоморфизмом, но для некоторых множеств существуют и другие автоморфизмы.\nНапример, отображение прибавления единицы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(x \\mapsto x + 1)"
    ]
  },
  " является автоморфизмом частично упорядоченного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Z"
    ]
  },
  " целых чисел (с естественным порядком).\nДля множества натуральных чисел та же формула не даёт автоморфизма (нет взаимной однозначности).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_97",
      "meta": {
        "n": 97
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "97"
            ]
          },
          ". ",
          "Покажите, что не существует автоморфизма упорядоченного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N"
            ]
          },
          " натуральных чисел, отличного от тождественного.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_98",
      "meta": {
        "n": 98
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "98"
            ]
          },
          ". ",
          "\nРассмотрим множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "P(A)"
            ]
          },
          " всех подмножеств некоторого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "-элементного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", частично упорядоченное по включению.\nНайдите число автоморфизмов этого множества.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_99",
      "meta": {
        "n": 99
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "99"
            ]
          },
          ". ",
          "Покажите, что множество целых положительных чисел, частично упорядоченное отношением «",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " делит ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          "», имеет континуум различных автоморфизмов.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВот несколько примеров равномощных, но не изоморфных линейно упорядоченных множеств\n(в силу ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_iso-eql-lin"
    },
    "children": [
      "теоремы ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_iso-eql-lin",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " они должны быть бесконечными).\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОтрезок ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, 1]"
            ]
          },
          " (с обычным отношением порядка) не изоморфен множеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\R"
            ]
          },
          ", так как у первого есть наибольший элемент, а у второго нет.\n(При изоморфизме наибольший элемент, естественно, должен соответствовать наибольшему.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМножество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z"
            ]
          },
          " (целые числа с обычным порядком) не изоморфно множеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q}"
            ]
          },
          " (рациональные числа).\nВ самом деле, пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha: \\Z \\to \\Bbb{Q}"
            ]
          },
          " является изоморфизмом.\nВозьмём два соседних целых числа, скажем, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "3"
            ]
          },
          ".\nПри изоморфизме ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " им должны соответствовать какие-то два рациональных числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha(2)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha(3)"
            ]
          },
          ", причём ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha(2) < \\alpha(3)"
            ]
          },
          ", так как ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2 < 3"
            ]
          },
          ".\nНо тогда рациональным числам между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha(2)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha(3)"
            ]
          },
          " должны соответствовать целые числа между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "3"
            ]
          },
          ", которых нет.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nБолее сложный пример — множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z + \\Z"
            ]
          },
          ".\nВозьмём в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z + \\Z"
            ]
          },
          " две копии нуля (из той и другой компоненты); мы обозначали их ",
          {
            "name": "math",
            "props": {},
            "children": [
              "0"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\overline{0}"
            ]
          },
          ".\nПри этом ",
          {
            "name": "math",
            "props": {},
            "children": [
              "0 < \\overline{0}"
            ]
          },
          ".\nПри изоморфизме им должны соответствовать два целых числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b"
            ]
          },
          ", для которых ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a < b"
            ]
          },
          ".\nТогда всем элементам между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "0"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\overline{0}"
            ]
          },
          " (их бесконечно много: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "1, 2, 3, \\dots , -\\overline{3}, -\\overline{2}, -\\overline{1}"
            ]
          },
          ") должны соответствовать числа между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b"
            ]
          },
          " — но их лишь конечное число.\n\n\nЭтот пример принципиально отличается от предыдущих тем, что здесь разницу между свойствами множеств нельзя записать формулой.\nКак говорят, упорядоченные множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z + \\Z"
            ]
          },
          " «элементарно эквивалентны».\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_100",
      "meta": {
        "n": 100
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "100"
            ]
          },
          ". ",
          "\nДокажите, что линейно упорядоченные множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z \\times \\N"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z \\times \\Z"
            ]
          },
          "\n(с описанным ",
          {
            "name": "label",
            "props": {
              "ref": "multi-set-order"
            },
            "children": [
              "выше"
            ]
          },
          " ",
          {
            "name": "tooltip",
            "props": {
              "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
            },
            "children": [
              "на с. 46"
            ]
          },
          " порядком) не изоморфны.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_101",
      "meta": {
        "n": 101
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "101"
            ]
          },
          ". ",
          "Будут ли изоморфны линейно упорядоченные множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N \\times \\Z"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Z \\times \\Z"
            ]
          },
          "?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_102",
      "meta": {
        "n": 102
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "102"
            ]
          },
          ". ",
          "Будут ли изоморфны линейно упорядоченные множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q} \\times \\Z"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q} \\times \\N"
            ]
          },
          "?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nОтображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\mapsto \\sqrt{2}x"
    ]
  },
  " осуществляет изоморфизм между интервалами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, 1)"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(0, \\sqrt{2}"
    ]
  },
  ").\nНо уже не так просто построить изоморфизм между множествами рациональных точек этих интервалов\n(то есть между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q} \\cap (0, 1)"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q} \\cap (0, \\sqrt{2})"
    ]
  },
  "),\nпоскольку умножение на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sqrt{2}"
    ]
  },
  " переводит рациональные числа в иррациональные.\nТем не менее изоморфизм построить можно.\nДля этого надо взять возрастающие последовательности рациональных чисел ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0 < x_1 < x_2 < \\ldots"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0 < y_1 < y_2 < \\ldots"
    ]
  },
  ", сходящиеся соответственно к ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sqrt{2}"
    ]
  },
  ", и построить кусочно-линейную функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ", которая переводит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_i"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y_i"
    ]
  },
  " и линейна на каждом из отрезков ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[x_i, x_{i+1}]"
    ]
  },
  " (",
  {
    "name": "label",
    "props": {
      "ref": "img_5"
    },
    "children": [
      "рис. 5"
    ]
  },
  ").\nЛегко понять, что она будет искомым изоморфизмом.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "img_5"
    },
    "children": [
      "\n",
      {
        "name": "image",
        "props": {
          "src": "/2/2/img5.svg",
          "height": 0.5
        },
        "children": [
          "Рис. 5. Ломаная осуществляет изоморфизм."
        ]
      },
      "\n"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_103",
      "meta": {
        "n": 103
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "103"
            ]
          },
          ". ",
          "\nПокажите, что множество рациональных чисел интервала ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(0, 1)"
            ]
          },
          " и множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q}"
            ]
          },
          " изоморфны.\n(Указание: здесь тоже можно построить ломаную;\nвпрочем, можно действовать иначе и начать с того, что функция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\mapsto 1 / x"
            ]
          },
          " переводит рациональные числа в рациональные.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nБолее сложная конструкция требуется в следующей задаче (видимо, ничего проще, чем сослаться на общую ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_iso-dense-sets"
    },
    "children": [
      "теорему ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_iso-dense-sets",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ", тут не придумаешь).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_104",
      "meta": {
        "n": 104
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "104"
            ]
          },
          ". ",
          "\nДокажите, что множество двоично-рациональных чисел интервала ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(0, 1)"
            ]
          },
          " изоморфно множеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q}"
            ]
          },
          ".\n(Число считается ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "двоично-рациональным"
            ]
          },
          ", если оно имеет вид ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m / 2^n"
            ]
          },
          ", где ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m"
            ]
          },
          " — целое число, а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " — натуральное.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nДва элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x, y"
    ]
  },
  " линейно упорядоченного множества называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "соседними"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x < y"
    ]
  },
  " и не существует элемента между ними, то есть такого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  ", что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x < z < y"
    ]
  },
  ".\nЛинейно упорядоченное множество называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "плотным"
    ]
  },
  ", если в нём нет соседних элементов (то есть между любыми двумя есть третий).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_iso-dense-sets",
      "meta": {
        "n": 13
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 13"
        ]
      },
      ". ",
      "Любые два счётных плотных линейно упорядоченных множества без наибольшего и наименьшего элементов изоморфны.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y"
    ]
  },
  " — данные нам множества.\nТребуемый изоморфизм между ними строится по шагам.\nПосле ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  " шагов у нас есть два ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  "-элементных подмножества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_n \\sub X"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y_n \\sub Y"
    ]
  },
  ", элементы которых мы будем называть «охваченными», и взаимно однозначное соответствие между ними, сохраняющее порядок.\nНа очередном шаге мы берём какой-то неохваченный элемент одного из множеств (скажем, множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ") и сравниваем его со всеми охваченными элементами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ".\nОн может оказаться либо меньше всех, либо больше, либо попасть между какими-то двумя.\nВ каждом из случаев мы можем найти неохваченный элемент в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y"
    ]
  },
  ", находящийся в том же положении (больше всех, между первым и вторым охваченным сверху, между вторым и третьим охваченным сверху и т. п.).\nПри этом мы пользуемся тем, что в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y"
    ]
  },
  " нет наименьшего элемента, нет наибольшего и нет соседних элементов, — в зависимости от того, какой из трёх случаев имеет место.\nПосле этого мы добавляем выбранные элементы к ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_n"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y_n"
    ]
  },
  ", считая их соответствующими друг другу.\n\n\nЧтобы в пределе получить изоморфизм между множествами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y"
    ]
  },
  " , мы должны позаботиться о том, чтобы все элементы обоих множеств были рано или поздно охвачены.\nЭто можно сделать так: поскольку каждое из множеств счётно, пронумеруем его элементы и будем выбирать неохваченный элемент с наименьшим номером (на нечётных шагах — из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ", на чётных — из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Y"
    ]
  },
  ").\nЭто соображение завершает доказательство.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_105",
      "meta": {
        "n": 105
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "105"
            ]
          },
          ". ",
          "Сколько существует неизоморфных счётных плотных линейно упорядоченных множеств (про наименьший и наибольший элементы ничего не известно)? (Ответ: 4.)",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_106",
      "meta": {
        "n": 106
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "106"
            ]
          },
          ". ",
          "\nПриведите пример неизоморфных линейно упорядоченных множеств мощности c без наименьшего и наибольшего элементов.\n(Указание: возьмите множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q} + \\R"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\R + \\Bbb{Q}"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_iso-sub-Q",
      "meta": {
        "n": 14
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 14"
        ]
      },
      ". ",
      "Всякое счётное линейно упорядоченное множество изоморфно некоторому подмножеству множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\Bbb{Q}"
        ]
      },
      ".",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nЗаметим сразу же, что вместо множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q}"
    ]
  },
  " можно было взять любое плотное счётное всюду плотное множество без первого и последнего элементов, так как они все изоморфны.\n\n\nДоказательство этого утверждения происходит так же, как и в ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_iso-dense-sets"
    },
    "children": [
      "теореме ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_iso-dense-sets",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " — с той разницей, что новые необработанные элементы берутся только с одной стороны (из данного нам множества), а пары к ним подбираются в множестве рациональных чисел.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_107",
      "meta": {
        "n": 107
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "107"
            ]
          },
          ". ",
          "Дайте другое доказательство ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_iso-sub-Q"
            },
            "children": [
              "теоремы ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_iso-sub-Q",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          ", заметив, что любое множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          " изоморфно подмножеству множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q} \\times X"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_founded-sets",
      "meta": {
        "n": 3,
        "longN": "2.3"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.3"
            ]
          },
          ". ",
          "Фундированные множества",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nПринцип математической индукции в одной из возможных форм звучит так:\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "\nПусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A(n)"
        ]
      },
      " — некоторое свойство натурального числа ",
      {
        "name": "math",
        "props": {},
        "children": [
          "n"
        ]
      },
      ".\nПусть нам удалось доказать ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A(n)"
        ]
      },
      " в предположении, что ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A(m)"
        ]
      },
      " верно для всех ",
      {
        "name": "math",
        "props": {},
        "children": [
          "m"
        ]
      },
      ", меньших ",
      {
        "name": "math",
        "props": {},
        "children": [
          "n"
        ]
      },
      ".\nТогда свойство ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A(n)"
        ]
      },
      " верно для всех натуральных чисел ",
      {
        "name": "math",
        "props": {},
        "children": [
          "n"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\n(Заметим, что по условию доказательство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A(0)"
    ]
  },
  " возможно без всяких предположений, поскольку меньших чисел нет.)\n\n\nДля каких частично упорядоченных множеств верен аналогичный принцип?\nОтвет даётся следующей простой теоремой:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_founded-set",
      "meta": {
        "n": 15
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 15"
        ]
      },
      ". ",
      "\nСледующие три свойства частично упорядоченного множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "X"
        ]
      },
      " равносильны:\n\n",
      {
        "name": "area",
        "props": {
          "key": "theorem_founded-set-list"
        },
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "key": "theorem_founded-set-а"
            },
            "children": [
              "\n(",
              {
                "name": "format.b",
                "props": {},
                "children": [
                  "а"
                ]
              },
              ") любое непустое подмножество ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "X"
                ]
              },
              " имеет минимальный элемент;\n"
            ]
          },
          "\n",
          {
            "name": "area",
            "props": {
              "key": "theorem_founded-set-б"
            },
            "children": [
              "\n(",
              {
                "name": "format.b",
                "props": {},
                "children": [
                  "б"
                ]
              },
              ") не существует бесконечной строго убывающей последовательности ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x_0 > x_1 > x_2 > \\ldots"
                ]
              },
              " элементов множества ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "X"
                ]
              },
              ";\n"
            ]
          },
          "\n",
          {
            "name": "area",
            "props": {
              "key": "theorem_founded-set-в"
            },
            "children": [
              "\n(",
              {
                "name": "format.b",
                "props": {},
                "children": [
                  "в"
                ]
              },
              ") для множества ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "X"
                ]
              },
              " верен принцип индукции в следующей форме: если (при каждом ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x \\in X"
                ]
              },
              ") из истинности ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A(y)"
                ]
              },
              " для всех ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "y < x"
                ]
              },
              " следует истинность ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A(x)"
                ]
              },
              ", то свойство ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A(x)"
                ]
              },
              " верно при всех ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x"
                ]
              },
              ".\nФормально это записывают так:\n",
              {
                "name": "math",
                "props": {
                  "block": true
                },
                "children": [
                  "\n\\forall x (\\forall y ((y < x) \\lrArr A(y)) \\lrArr A(x)) \\lrArr \\forall x A(x).\n"
                ]
              },
              "\n"
            ]
          },
          "\n"
        ]
      },
      "\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nСначала докажем эквивалентность первых двух свойств.\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0 > x_1 > x_2 > \\ldots"
    ]
  },
  " — бесконечная убывающая последовательность, то, очевидно, множество её значений не имеет минимального элемента (для каждого элемента следующий ещё меньше).\nПоэтому из ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_founded-set-а"
    },
    "children": [
      "(а)"
    ]
  },
  " следует ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_founded-set-б"
    },
    "children": [
      "(б)"
    ]
  },
  ".\nНапротив, если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — непустое множество, не имеющее минимального элемента, то бесконечную убывающую последовательность можно построить так.\nВозьмём произвольный элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_0 \\in B"
    ]
  },
  ".\nПо предположению он не является минимальным, так что можно найти ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1 \\in B"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_0 > b_1"
    ]
  },
  ".\nПо тем же причинам можно найти ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_2 \\in B"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1 > b_2"
    ]
  },
  " и т.д.\nПолучается бесконечная убывающая последовательность.\n\n\nТеперь выведем принцип индукции из существования минимального элемента в любом подмножестве.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A(x)"
    ]
  },
  " — произвольное свойство элементов множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ", верное не для всех элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ".\nРассмотрим непустое множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " тех элементов, для которых свойство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " неверно.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " — минимальный элемент множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nПо условию меньших элементов в множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " нет, поэтому для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  " свойство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A(y)"
    ]
  },
  " выполнено.\nНо тогда по предположению должно быть выполнено и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A(x)"
    ]
  },
  " — противоречие.\n\n\nОсталось доказать существование минимального элемента в любом непустом подмножестве, исходя из принципа индукции.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — подмножество без минимальных элементов.\nДокажем по индукции, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " пусто; другими словами, в качестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A(x)"
    ]
  },
  " возьмём свойство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\not \\in B"
    ]
  },
  ".\nВ самом деле, если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A(y)"
    ]
  },
  " верно для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  ", то никакой элемент, меньший ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", не лежит в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nЕсли бы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " лежал в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", то он был бы там минимальным, а таких нет.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nМножества, обладающие свойствами ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_founded-set-list"
    },
    "children": [
      "(а) – (в)"
    ]
  },
  ", называются ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "фундированными"
    ]
  },
  ".\nКакие есть примеры фундированных множеств?\nПрежде всего, наш исходный пример — множество натуральных чисел.\n\n\nДругой пример — множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N \\times \\N"
    ]
  },
  " пар натуральных чисел\n(меньше та пара, у которой второй член меньше; в случае равенства сравниваем первые).\nВ самом деле, проверим условие ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_founded-set-б"
    },
    "children": [
      "(б)"
    ]
  },
  ".\nНам будет удобно сформулировать его так: всякая последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "u_0 \\geqslant u_1 \\geqslant u_2 \\geqslant \\ldots"
    ]
  },
  " элементов множества рано или поздно стабилизируется (все члены, начиная с некоторого, равны);\nочевидно, что это эквивалентная формулировка.\n\n\nПусть дана произвольная последовательность пар\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\lang x_0, y_0 \\rang \\geqslant \\lang x_1, y_1 \\rang \\geqslant \\lang x_2, y_2 \\rang \\geqslant \\dots\n"
    ]
  },
  "\nПо определению порядка (сначала сравниваются вторые члены) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y_0 \\geqslant y_1 \\geqslant y_2 \\geqslant \\dots"
    ]
  },
  " и потому последовательность натуральных чисел ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y_i"
    ]
  },
  " с какого-то места не меняется.\nПосле этого уже ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_i"
    ]
  },
  " должны убывать — и тоже стабилизируются.\nЧто и требовалось.\n\n\nТо же самое рассуждение пригодно и в более общей ситуации.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_founded-mult",
      "meta": {
        "n": 16
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 16"
        ]
      },
      ". ",
      "\nПусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " — два фундированных частично упорядоченных множества.\nТогда их произведение ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A \\times B"
        ]
      },
      ", в котором\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\lang a_1, b_1 \\rang \\leqslant \\lang a_2, b_2 \\rang \\lrArr [(b_1 < b_2) \\ \\text{или} \\ (b_1 = b_2 \\ \\text{и} \\ a_1 \\leqslant a_2)],\n"
        ]
      },
      "\nявляется фундированным.\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВ последовательности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a_0, b_0 \\rang \\geqslant \\lang a_1, b_1 \\rang \\geqslant \\dots"
    ]
  },
  " стабилизируются сначала вторые, а затем и первые члены.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nОтсюда вытекает аналогичное утверждение для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N \\times \\N \\times \\N"
    ]
  },
  ", для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N^k"
    ]
  },
  " или вообще для произведения конечного числа фундированных множеств.\n\n\nЕщё проще доказать, что сумма ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A + B"
    ]
  },
  " двух фундированных множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " фундирована: последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0 \\geqslant x_1 \\geqslant x_2 \\geqslant \\dots"
    ]
  },
  " либо целиком содержится в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " (и мы ссылаемся на фундированность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "), либо содержит элемент из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nВ последнем случае все следующие элементы также принадлежат ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", и мы используем фундированность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\n\n\nЧасто в программировании (или в олимпиадных задачах) нам нужно доказать, что некоторый процесс не может продолжаться бесконечно долго.\nНапример, написав цикл, мы должны убедиться, что рано или поздно из него выйдем.\nЭто можно сделать так: ввести какой-то натуральный параметр и убедиться, что на каждом шаге цикла этот параметр уменьшается.\nТогда, если сейчас этот параметр равен ",
  {
    "name": "math",
    "props": {},
    "children": [
      "N"
    ]
  },
  ", то можно гарантировать, что не позже чем через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "N"
    ]
  },
  " шагов цикл закончится.\n\n\nОднако бывают ситуации, в которых число шагов заранее оценить нельзя, но тем не менее гарантировать завершение цикла можно, поскольку есть параметр, принимающий значения в фундированном множестве и убывающий на каждом шаге цикла.\n\n\nВот пример олимпиадной задачи, где по существу такое рассуждение и используется.\n\n\nБизнесмен заключил с чёртом сделку: каждый день он даёт чёрту одну монету, и в обмен получает любой набор монет по своему выбору, но все эти монеты меньшего достоинства (видов монет конечное число).\nМенять (или получать) деньги в другом месте бизнесмен не может.\nКогда монет больше не останется, бизнесмен проигрывает.\nДокажите, что рано или поздно чёрт выиграет, каков бы ни был начальный набор монет у бизнесмена.\n\n\nРешение: пусть имеется ",
  {
    "name": "math",
    "props": {},
    "children": [
      "k"
    ]
  },
  " видов монет.\nИскомый параметр определим так: посчитаем, сколько монет каждого вида есть у бизнесмена\n(",
  {
    "name": "math",
    "props": {},
    "children": [
      "n_1"
    ]
  },
  " — число монет минимального достоинства, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n_2"
    ]
  },
  " — число следующих, и так далее до ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n_k"
    ]
  },
  ").\nЗаметим, что в результате встречи с чёртом набор ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang n_1, \\dots , n_k \\rang"
    ]
  },
  " уменьшается (в смысле введённого нами порядка, когда мы сравниваем сначала последние члены, затем предпоследние и т. д.).\nПоскольку множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N^k"
    ]
  },
  " фундировано, этот процесс должен оборваться.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_108",
      "meta": {
        "n": 108
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "108"
            ]
          },
          ". ",
          "\nИмеется конечная последовательность нулей и единиц.\nЗа один шаг разрешается сделать такое действие: найти в ней группу ",
          {
            "name": "math",
            "props": {},
            "children": [
              "01"
            ]
          },
          " и заменить на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "100 \\dots 00"
            ]
          },
          "\n(при этом можно написать сколько угодно нулей).\nДокажите, что такие шаги нельзя выполнять бесконечно много раз.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_109",
      "meta": {
        "n": 109
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "109"
            ]
          },
          ". ",
          "\nРассмотрим множество всех слов русского алфавита\n(точнее, всех конечных последовательностей русских букв, независимо от смысла)\nс ",
          {
            "name": "label",
            "props": {
              "ref": "lexical-order"
            },
            "children": [
              "лексикографическим порядком"
            ]
          },
          " ",
          {
            "name": "tooltip",
            "props": {
              "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
            },
            "children": [
              "(см. с. 44)"
            ]
          },
          ".\nБудет ли это множество фундировано?\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_110",
      "meta": {
        "n": 110
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "110"
            ]
          },
          ". ",
          "\nРассмотрим множество невозрастающих последовательностей натуральных чисел, в которых все члены, начиная с некоторого, равны нулю.\nВведём в нём порядок так: сначала сравниваем первые члены, при равенстве первых вторые и т. д.\nДокажите, что это (линейно) упорядоченное множество фундировано.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_111",
      "meta": {
        "n": 111
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "111"
            ]
          },
          ". ",
          "\nРассмотрим множество всех многочленов от одной переменной ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ", коэффициенты которых — натуральные числа.\nУпорядочим его так: многочлен ",
          {
            "name": "math",
            "props": {},
            "children": [
              "P"
            ]
          },
          " больше многочлена ",
          {
            "name": "math",
            "props": {},
            "children": [
              "Q"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "P(x) > Q(x)"
            ]
          },
          " для всех достаточно больших ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ".\nПокажите, что это определение задаёт линейный порядок и что получающееся упорядоченное множество фундировано.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_4",
      "meta": {
        "n": 4,
        "longN": "2.4"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.4"
            ]
          },
          ". ",
          "Вполне упорядоченные множества",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nФундированные линейно упорядоченные множества называются ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "вполне упорядоченными"
    ]
  },
  ", а соответствующие порядки — ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "полными"
    ]
  },
  ".\nДля линейных порядков понятия наименьшего и минимального элемента совпадают, так что во вполне упорядоченном множестве всякое непустое подмножество имеет наименьший элемент.\n\n\nЗаметим, что частично упорядоченное множество, в котором всякое непустое подмножество имеет наименьший элемент, автоматически является линейно упорядоченным (в самом деле, всякое двухэлементное множество имеет наименьший элемент, поэтому любые два элемента сравнимы).\n\n\nПримеры вполне упорядоченных множеств: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N + k"
    ]
  },
  " (здесь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "k"
    ]
  },
  " обозначает конечное линейно упорядоченное множество из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "k"
    ]
  },
  " элементов), ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N + \\N"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N \\times \\N"
    ]
  },
  ".\n\n\nНаша цель — понять, как могут быть устроены вполне упорядоченные множества.\nНачнём с нескольких простых замечаний.\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nВполне упорядоченное множество имеет наименьший элемент.\n(Непосредственное следствие определения.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nДля каждого элемента ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " вполне упорядоченного множества (кроме наибольшего) есть непосредственно следующий за ним элемент ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          " (это означает, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y > x"
            ]
          },
          ", но не существует ",
          {
            "name": "math",
            "props": {},
            "children": [
              "z"
            ]
          },
          ", для которого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y > z > x"
            ]
          },
          ").\nВ самом деле, если множество всех элементов, больших ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ", непусто, то в нём есть минимальный элемент ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y"
            ]
          },
          ", который и будет искомым.\nТакой элемент обычно обозначают ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x + 1"
            ]
          },
          ", следующий за ним — ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x + 2"
            ]
          },
          " и т.д.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНекоторые элементы вполне упорядоченного множества могут не иметь непосредственно предыдущего.\nНапример, в множестве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N + \\N"
            ]
          },
          " есть два элемента, не имеющих непосредственно предыдущего\n(наименьший элемент, а также наименьший элемент второй копии натурального ряда).\nТакие элементы называют ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "предельными"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "z+n"
            },
            "children": [
              "\nВсякий элемент упорядоченного множества имеет вид ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "z + n"
                ]
              },
              ", где ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "z"
                ]
              },
              " — предельный, а ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "n"
                ]
              },
              " — натуральное число (обозначение ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "z + n"
                ]
              },
              " понимается в описанном выше смысле).\nВ самом деле, если ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "z"
                ]
              },
              " не предельный, возьмём предыдущий, если и он непредельный — то его предыдущий и т. д., пока не дойдём до предельного\n(бесконечно продолжаться это не может, так как множество вполне упорядочено).\nОчевидно, такое представление однозначно (у элемента может быть только один непосредственно предыдущий).\n"
            ]
          },
          "\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЛюбое ограниченное сверху множество элементов вполне упорядоченного множества имеет точную верхнюю грань.\n(Как обычно, подмножество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "X"
            ]
          },
          " частично упорядоченного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " называется ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "ограниченным сверху"
            ]
          },
          ", если оно имеет ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "верхнюю границу"
            ]
          },
          ", т.е. элемент ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a \\in A"
            ]
          },
          ", для которого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\leqslant a"
            ]
          },
          " при всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\in X"
            ]
          },
          ".\nЕсли среди всех верхних границ данного подмножества есть наименьшая, то она называется ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "точной верхней гранью"
            ]
          },
          ".)\n\n\nВ самом деле, множество всех верхних границ непусто и потому имеет наименьший элемент.\n(Заметим в скобках, что вопрос о точной нижней грани для вполне упорядоченного множества тривиален, так как всякое множество имеет наименьший элемент.)\n"
        ]
      },
      "\n"
    ]
  },
  "\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " — произвольное вполне упорядоченное множество.\nЕго наименьший элемент обозначим через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  ".\nСледующий за ним элемент обозначим через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1"
    ]
  },
  ", следующий за ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1"
    ]
  },
  " — через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2"
    ]
  },
  " и т.д.\nЕсли множество конечно, процесс этот оборвётся.\nЕсли бесконечно, посмотрим, исчерпали ли мы все элементы множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nЕсли нет, возьмём минимальный элемент из оставшихся.\nОбозначим его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega"
    ]
  },
  ".\nСледующий за ним элемент (если он есть) обозначим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega + 1"
    ]
  },
  ", затем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega + 2"
    ]
  },
  " и т.д.\nЕсли и на этом множество не исчерпается, то возьмём наименьший элемент из оставшихся, назовём его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega \\cdot 2"
    ]
  },
  ", и повторим всю процедуру.\nЗатем будут ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega \\cdot 3"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega \\cdot 4"
    ]
  },
  " и т.д.\nЕсли и на этом множество не кончится, минимальный из оставшихся элементов назовём ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega^2"
    ]
  },
  ".\nЗатем пойдут ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega^2 + 1, \\omega^2 + 2, \\dots , \\omega^2 + \\omega, \\dots , \\omega^2 + \\omega \\cdot 2, \\dots , \\omega^2 \\cdot 2, \\dots , \\omega^2 \\cdot 3, \\dots , \\omega^3 , \\dots"
    ]
  },
  "\n(мы не поясняем сейчас подробно обозначения).\n\n\nЧто, собственно говоря, доказывает это рассуждение?\nПопытаемся выделить некоторые утверждения.\nПри этом полезно такое определение: если линейно упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " разбито на две (непересекающиеся) части ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  ", причём любой элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " меньше любого элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "начальным отрезком"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nДругими словами, подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " линейно упорядоченного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " является начальным отрезком, если любой элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " меньше любого элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\setminus B"
    ]
  },
  ".\nЕщё одна переформулировка: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\sub A"
    ]
  },
  " является начальным отрезком, если из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a, b \\in A, b \\in B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant b"
    ]
  },
  " следует ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in B"
    ]
  },
  ".\nЗаметим, что начальный отрезок может быть пустым или совпадать со всем множеством.\n\n\nОтметим сразу же несколько простых свойств начальных отрезков:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНачальный отрезок вполне упорядоченного множества (как, впрочем, и любое подмножество) является вполне упорядоченным множеством.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНачальный отрезок начального отрезка есть начальный отрезок исходного множества.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОбъединение любого семейства начальных отрезков (в одном и том же упорядоченном множестве) есть начальный отрезок того же множества.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " — произвольный элемент вполне упорядоченного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", то множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, x)"
            ]
          },
          "\n(все элементы множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", меньшие ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ")\nи ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, x]"
            ]
          },
          " (элементы множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", меньшие или равные ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ") являются начальными отрезками.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "[0,x)"
            },
            "children": [
              "\nВсякий начальный отрезок ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "I"
                ]
              },
              " вполне упорядоченного множества ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              ", не совпадающий со всем множеством, имеет вид ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "[0, x)"
                ]
              },
              " для некоторого ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x \\in A"
                ]
              },
              ".\n(В самом деле, если ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "I \\not = A"
                ]
              },
              ", возьмём наименьший элемент ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x"
                ]
              },
              " в множестве ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A \\setminus I"
                ]
              },
              ".\nТогда все меньшие элементы принадлежат ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "I"
                ]
              },
              ", сам ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x"
                ]
              },
              " не принадлежит ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "I"
                ]
              },
              " и все бо´льшие ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "x"
                ]
              },
              " элементы не принадлежат ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "I"
                ]
              },
              ", иначе получилось бы противоречие с определением начального отрезка.)\n"
            ]
          },
          "\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЛюбые два начальных отрезка вполне упорядоченного множества сравнимы по включению, т. е. один есть подмножество другого.\n(Следует из предыдущего.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nНачальные отрезки вполне упорядоченного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", упорядоченные по включению, образуют вполне упорядоченное\nмножество.\nЭто множество состоит из наибольшего элемента (всё ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ") и остальной части, изоморфной множеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\n(В самом деле, начальные отрезки множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", не совпадающие с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", имеют вид ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, x)"
            ]
          },
          ", и соответствие ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, x) \\lrarr x"
            ]
          },
          " будет изоморфизмом.)\n"
        ]
      },
      "\n"
    ]
  },
  "\n\nВозвратимся к нашему рассуждению с последовательным выделением различных элементов из вполне упорядоченного множества.\nЕго первую часть можно считать доказательством такого утверждения: если вполне упорядоченное множество бесконечно, то оно имеет начальный отрезок, изоморфный ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega"
    ]
  },
  ".\n(Говоря о множестве натуральных чисел вместе с порядком, обычно употребляют обозначение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega"
    ]
  },
  ", а не ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N"
    ]
  },
  ".)\n\n\nНо на этом наше рассуждение не оканчивается.\nЕго следующая часть может считаться доказательством такого факта: либо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " изоморфно некоторому начальному отрезку множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega^2"
    ]
  },
  ", либо оно имеет начальный отрезок, изоморфный ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega^2"
    ]
  },
  ".\n(Здесь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega^2"
    ]
  },
  " — вполне упорядоченное множество пар натуральных чисел: сравниваются сначала вторые компоненты пар, а при их равенстве — первые.)\n\n\nВообще верно такое утверждение: для любых двух вполне упорядоченных множеств одно изоморфно начальному отрезку другого, и доказательство состоит более или менее в повторении проведённого рассуждения.\nНо чтобы сделать это аккуратно, нужна некоторая подготовка.\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_5",
      "meta": {
        "n": 5,
        "longN": "2.5"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.5"
            ]
          },
          ". ",
          "Трансфинитная индукция",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nТермины «индукция» и «рекурсия» часто употребляются вперемежку.\nНапример, определение факториала ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n! = 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot n"
    ]
  },
  " как функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(n)"
    ]
  },
  ", для которой ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(n) = n \\cdot f(n - 1)"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n > 0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(0) = 1"
    ]
  },
  ", называют и «индуктивным», и «рекурсивным».\nМы будем стараться разграничивать эти слова так: если речь идёт о доказательстве чего-то сначала для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n = 0"
    ]
  },
  ", затем для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n = 1, 2, \\dots"
    ]
  },
  ", причём каждое утверждение опирается на предыдущее, то это ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "индукция"
    ]
  },
  ".\nЕсли же мы определяем что-то сначала для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n = 0"
    ]
  },
  ", потом для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n = 1, 2, \\dots"
    ]
  },
  ", причём определение каждого нового значения использует ранее определённые, то это ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "рекурсия"
    ]
  },
  ".\n\n\nНаша цель — научиться проводить индуктивные доказательства и давать рекурсивные определения не только для натуральных чисел, но и для других вполне упорядоченных множеств (эту технику иногда называют «трансфинитной индукцией»).\n\n\nДоказательства по индукции мы уже обсуждали, говоря о фундированных множествах (см. раздел ",
  {
    "name": "link",
    "props": {
      "ref": "paragraph_founded-sets"
    },
    "children": [
      "",
      {
        "name": "use",
        "props": {
          "ref": "paragraph_founded-sets",
          "path": "longN"
        },
        "children": []
      },
      ""
    ]
  },
  "), и сейчас ограничимся только одним примером.\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_f(x)>x",
      "meta": {
        "n": 17
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 17"
        ]
      },
      ". ",
      "\nПусть множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " вполне упорядочено, а отображение ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f: A \\to A"
        ]
      },
      " возрастает\n(то есть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f(x) < f(y)"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x < y"
        ]
      },
      ").\nТогда ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f(x) > x"
        ]
      },
      " для всех ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x \\in A"
        ]
      },
      ".\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nСогласно принципу индукции (",
  {
    "name": "label",
    "props": {
      "ref": "theorem_founded-set"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_founded-set",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ") достаточно доказать неравенство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x) > x"
    ]
  },
  ", предполагая, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(y) > y"
    ]
  },
  " при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  ".\nПусть это не так и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x) < x"
    ]
  },
  ".\nТогда по монотонности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(f(x)) < f(x)"
    ]
  },
  ".\nНо, с другой стороны, элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y = f(x)"
    ]
  },
  " меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", и потому по предположению индукции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(y) > y"
    ]
  },
  ", то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(f(x)) > f(x)"
    ]
  },
  ".\n\n\nЕсли угодно, можно в явном виде воспользоваться существованием наименьшего элемента и изложить это же рассуждение так.\nПусть утверждение теоремы неверно.\nВозьмём наименьшее ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x) < x"
    ]
  },
  ".\nНо тогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(f(x)) < f(x)"
    ]
  },
  " по монотонности и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " не является наименьшим вопреки предположению.\n\n\nНаконец, это рассуждение можно пересказать и так: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x > f(x)"
    ]
  },
  ", то по монотонности\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nx > f(x) > f(f(x)) > f(f(f(x))) > \\dots ,\n"
    ]
  },
  "\nно бесконечных убывающих последовательностей в фундированном множестве быть не может.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nТеперь перейдём к рекурсии.\nВ определении факториала ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(n)"
    ]
  },
  " выражалось через ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(n - 1)"
    ]
  },
  ".\nВ общей ситуации значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(n)"
    ]
  },
  " может использовать не только одно предыдущее значение функции, но и все значения на меньших аргументах.\nНапример, можно определить функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: \\N \\to \\N"
    ]
  },
  ", сказав, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(n)"
    ]
  },
  " на единицу больше суммы всех предыдущих значений, то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(n) = f(0) + f(1) + \\ldots + f(n - 1) + 1"
    ]
  },
  ";\nэто вполне законное рекурсивное определение\n(надо только пояснить, что пустая сумма считается равной нулю, так что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(0) = 1"
    ]
  },
  ").\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_112",
      "meta": {
        "n": 112
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "112"
            ]
          },
          ". ",
          "Какую функцию ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " задаёт такое определение?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nКак обобщить эту схему на произвольные вполне упорядоченные множества вместо натурального ряда?\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " вполне упорядочено.\nМы хотим дать рекурсивное определение функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  " (где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — некоторое множество).\nТакое определение должно связывать значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x)"
    ]
  },
  " на некотором элементе ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in A"
    ]
  },
  " со значениями ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(y)"
    ]
  },
  " при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  ".\nДругими словами, рекурсивное определение указывает ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x)"
    ]
  },
  ", предполагая известным ограничение функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " на начальный отрезок ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, x)"
    ]
  },
  ".\nВот точная формулировка:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_transfinite-recursion",
      "meta": {
        "n": 18
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 18"
        ]
      },
      ". ",
      "Пусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " — вполне упорядоченное множество.\nПусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " — произвольное множество.\nПусть имеется некоторое рекурсивное правило, то есть отображение ",
      {
        "name": "math",
        "props": {},
        "children": [
          "F"
        ]
      },
      ", которое ставит в соответствие элементу ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x \\in A"
        ]
      },
      " и функции ",
      {
        "name": "math",
        "props": {},
        "children": [
          "g: [0, x) \\to B"
        ]
      },
      " некоторый элемент множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ".\nТогда существует и единственна функция ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f: A \\to B"
        ]
      },
      ", для которой\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\nf(x) = F(x, f | _{[0,x)})\n"
        ]
      },
      "\nпри всех ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x \\in A"
        ]
      },
      ".\n(Здесь ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f | _{[0,x)}"
        ]
      },
      " обозначает ограничение функции ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f"
        ]
      },
      " на начальный отрезок ",
      {
        "name": "math",
        "props": {},
        "children": [
          "[0, x)"
        ]
      },
      " — мы отбрасываем все значения функции на элементах, больших или равных ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x"
        ]
      },
      ".)\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nНеформально можно рассуждать так: значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " на минимальном элементе определено однозначно, так как предыдущих значений нет (сужение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f | _{[0,0)}"
    ]
  },
  " пусто).\nТогда и на следующем элементе значение функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " определено однозначно, поскольку на предыдущих (точнее, единственном предыдущем) функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " уже задана, и т.д.\n\n\nКонечно, это надо аккуратно выразить формально.\nВот как это делается.\nДокажем по индукции такое утверждение о произвольном элементе ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  ":\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "\nсуществует и единственно отображение ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f"
        ]
      },
      " отрезка ",
      {
        "name": "math",
        "props": {},
        "children": [
          "[0, a]"
        ]
      },
      " в множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ", для которого рекурсивное определение (равенство, приведённое в условии) выполнено при всех ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x \\in [0, a]"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\nБудем называть отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: [0, a] \\to B"
    ]
  },
  ", обладающее указанным свойством, ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "корректным"
    ]
  },
  ".\nТаким образом, мы хотим доказать, что для каждого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  " есть единственное корректное отображение отрезка ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a]"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\n\n\nПоскольку мы рассуждаем по индукции, можно предполагать, что для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c < a"
    ]
  },
  " это утверждение выполнено, то есть существует и единственно корректное отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_c: [0, c] \\to B"
    ]
  },
  ".\n(Корректность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_c"
    ]
  },
  " означает, что при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "d \\leqslant c"
    ]
  },
  " значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_c(d)"
    ]
  },
  " совпадает с предписанным по рекурсивному правилу.)\n\n\nРассмотрим отображения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_{c_1}"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_{c_2}"
    ]
  },
  " для двух различных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c_1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c_2"
    ]
  },
  ".\nПусть, например, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c_1 < c_2"
    ]
  },
  ".\nОтображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_{c_2}"
    ]
  },
  " определено на большем отрезке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, c_2]"
    ]
  },
  ".\nЕсли ограничить ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_{c_2}"
    ]
  },
  " на меньший отрезок ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, c_1]"
    ]
  },
  ", то оно совпадёт с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_{c_1}"
    ]
  },
  ", поскольку ограничение корректного отображения на меньший отрезок корректно (это очевидно), а мы предполагали единственность на отрезке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, c_1]"
    ]
  },
  ".\n\n\nТаким образом, все отображения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_c"
    ]
  },
  " согласованы друг с другом, то есть принимают одинаковое значение, если определены одновременно.\nОбъединив их, мы получаем некоторое единое отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h"
    ]
  },
  ", определённое на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a)"
    ]
  },
  ".\nПрименив к ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h"
    ]
  },
  " рекурсивное правило, получим некоторое значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  ".\nДоопределим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h"
    ]
  },
  " в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ", положив ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h(a) = b"
    ]
  },
  ".\nПолучится отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h: [0, a] \\to B"
    ]
  },
  "; легко понять, что оно корректно.\n\n\nЧтобы завершить индуктивный переход, надо проверить, что на отрезке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a]"
    ]
  },
  " корректное отображение единственно.\nВ самом деле, его ограничения на отрезки ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, c]"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c < a"
    ]
  },
  " должны совпадать с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_c"
    ]
  },
  ", поэтому осталось проверить однозначность в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " — что гарантируется рекурсивным определением\n(выражающим значение в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " через предыдущие).\nНа этом индуктивное доказательство заканчивается.\n\n\nОсталось лишь заметить, что для разных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " корректные отображения отрезков ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a]"
    ]
  },
  " согласованы друг с другом\n(сужение корректного отображения на меньший отрезок корректно, применяем единственность)\nи потому вместе задают некоторую функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to B"
    ]
  },
  ", удовлетворяющую рекурсивному определению.\n\n\nСуществование доказано;\nединственность тоже понятна, так как ограничение этой функции на любой отрезок ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a]"
    ]
  },
  " корректно и потому однозначно определено, как мы видели.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nПрежде чем применить эту теорему и доказать, что из двух вполне упорядоченных множеств одно является отрезком другого, нам потребуется её немного усовершенствовать.\nНам надо предусмотреть ситуацию, когда рекурсивное правило не всюду определено.\nПусть, например, мы определяем последовательность действительных чисел соотношением ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_n = \\tg x_{n-1}"
    ]
  },
  " и начальным условием ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0 = a"
    ]
  },
  ".\nПри некоторых значениях ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " может оказаться, что построение последовательности обрывается, поскольку тангенс не определён для соответствующего аргумента.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_113",
      "meta": {
        "n": 113
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "113"
            ]
          },
          ". ",
          "Докажите, что множество всех таких «исключительных» ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a"
            ]
          },
          " (когда последовательность конечна) счётно.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nАналогичная ситуация возможна и для общего случая.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_recursive-rule",
      "meta": {
        "n": 19
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 19"
        ]
      },
      ". ",
      "Пусть отображение ",
      {
        "name": "math",
        "props": {},
        "children": [
          "F"
        ]
      },
      ", о котором шла речь в ",
      {
        "name": "label",
        "props": {
          "ref": "theorem_transfinite-recursion"
        },
        "children": [
          "теореме ",
          {
            "name": "use",
            "props": {
              "ref": "theorem_transfinite-recursion",
              "path": "n"
            },
            "children": []
          },
          ""
        ]
      },
      ", является частичным\n(для некоторых элементов ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x"
        ]
      },
      " и функций ",
      {
        "name": "math",
        "props": {},
        "children": [
          "g: [0, x) \\to B"
        ]
      },
      " оно может быть не определено).\nТогда существует функция ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f"
        ]
      },
      ", которая\n",
      {
        "name": "list",
        "props": {},
        "children": [
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "\nлибо определена на всём ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "A"
                ]
              },
              " и согласована с рекурсивным определением;\n"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "\nлибо определена на некотором начальном отрезке ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "[0, a)"
                ]
              },
              " и на нём согласована с рекурсивным определением, причём для точки ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "a"
                ]
              },
              " и функции ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "f"
                ]
              },
              " рекурсивное правило неприменимо (отображение ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "F"
                ]
              },
              " не определено).\n"
            ]
          },
          "\n"
        ]
      },
      "\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nЭто утверждение является обобщением, но одновременно и следствием предыдущей ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_transfinite-recursion"
    },
    "children": [
      "теоремы ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_transfinite-recursion",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ".\nВ самом деле, добавим к множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " специальный элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  " («неопределённость») и модифицируем рекурсивное правило: новое правило даёт значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  ", когда старое было не определено.\n(Если среди значений функции на предыдущих аргументах уже встречалось ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  ", новое рекурсивное правило тоже даёт ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  ".)\n\n\nПрименив ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_transfinite-recursion"
    },
    "children": [
      "теорему ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_transfinite-recursion",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " к модифицированному правилу, получим некоторую функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f'"
    ]
  },
  ".\nЕсли эта функция нигде не принимает значения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  ", то реализуется первая из двух возможностей, указанных в теореме (при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f = f'"
    ]
  },
  ").\nЕсли же функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f'"
    ]
  },
  " принимает значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  " в какой-то точке, то она имеет то же значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  " и во всех больших точках.\nЗаменив значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\bot"
    ]
  },
  " на неопределённость, мы получаем из функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f'"
    ]
  },
  " функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ".\nОбласть определения функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " есть некоторый начальный отрезок ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a)"
    ]
  },
  " и реализуется вторая возможность, указанная в формулировке теоремы.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_114",
      "meta": {
        "n": 114
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "114"
            ]
          },
          ". ",
          "Сформулируйте и докажите утверждение об однозначности функции, заданной частичным рекурсивным правилом.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nТеперь у нас всё готово для доказательства теоремы о сравнении вполне упорядоченных множеств.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_A<>B",
      "meta": {
        "n": 20
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 20"
        ]
      },
      ". ",
      "\nПусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " — два вполне упорядоченных множества.\nТогда либо ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " изоморфно некоторому начальному отрезку множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " изоморфно некоторому начальному отрезку множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ".\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nОтметим прежде всего, что начальный отрезок может совпадать со всем множеством, так что случай изоморфных множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " также покрывается этой теоремой.\n\n\nОпределим отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " таким рекурсивным правилом: для любого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  "\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "\n",
      {
        "name": "math",
        "props": {},
        "children": [
          "f(a)"
        ]
      },
      " есть наименьший элемент множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ", который не встречается среди ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f(a')"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {},
        "children": [
          "a' < a"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\nЭто правило не определено в том случае, когда значения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(a')"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a' < a"
    ]
  },
  " покрывают всё ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nПрименяя ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_recursive-rule"
    },
    "children": [
      "теорему ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_recursive-rule",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ", мы получаем функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ", согласованную с этим правилом.\nТеперь рассмотрим два случая:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nФункция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " определена на всём ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\nЗаметим, что рекурсивное определение гарантирует монотонность, поскольку ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f(a)"
            ]
          },
          " определяется как минимальный ещё не использованный элемент;\nчем больше ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a"
            ]
          },
          ", тем меньше остаётся неиспользованных элементов и потому минимальный элемент может только возрасти\n(из определения следует также, что одинаковых значений быть не может).\nОстаётся лишь проверить, что множество значений функции ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          ", то есть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f(A)"
            ]
          },
          ", будет начальным отрезком.\nВ самом деле, пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b < f(a)"
            ]
          },
          " для некоторого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a \\in A"
            ]
          },
          ";\nнадо проверить, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b"
            ]
          },
          " также является значением функции ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          ".\nДействительно, согласно рекурсивному определению ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f(a)"
            ]
          },
          " является наименьшим неиспользованным значением, следовательно, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b"
            ]
          },
          " уже использовано, то есть встречается среди ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f(a')"
            ]
          },
          " при ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a' < a"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nФункция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " определена лишь на некотором начальном отрезке ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, a)"
            ]
          },
          ".\nВ этом случае этот начальный отрезок изоморфен ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", и функция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " является искомым изоморфизмом.\nВ самом деле, раз ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f(a)"
            ]
          },
          " не определено, то среди значений функции ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " встречаются все элементы множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ".\nС другой стороны, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f"
            ]
          },
          " сохраняет порядок в силу рекурсивного определения.\n"
        ]
      },
      "\n"
    ]
  },
  "\nТаким образом, в обоих случаях утверждение теоремы верно.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nМожет ли быть так, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " изоморфно начальному отрезку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфно начальному отрезку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  "?\nНет — за исключением тривиального случая, когда начальные отрезки представляют собой сами множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nЭто вытекает из такого утверждения:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_21",
      "meta": {
        "n": 21
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 21"
        ]
      },
      ". ",
      "Никакое вполне упорядоченное множество не изоморфно своему начальному отрезку (не совпадающему со всем множеством).",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПусть вполне упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " изоморфно своему начальному отрезку, не совпадающему со всем множеством.\nКак мы видели ",
  {
    "name": "label",
    "props": {
      "ref": "[0,x)"
    },
    "children": [
      "ранее"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "на с. 58"
    ]
  },
  ", этот отрезок имеет вид ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a)"
    ]
  },
  " для некоторого элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A"
    ]
  },
  ".\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: A \\to [0, a)"
    ]
  },
  " — изоморфизм.\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " строго возрастает, и по ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_f(x)>x"
    },
    "children": [
      "теореме ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_f(x)>x",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " имеет место неравенство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(a) > a"
    ]
  },
  ", что противоречит тому, что множество значений функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a)"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nЕсли множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " изоморфно начальному отрезку множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", а множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфно начальному отрезку множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", то композиция этих изоморфизмов даёт изоморфизм между множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и его начальным отрезком\n(начальный отрезок начального отрезка есть начальный отрезок).\nЭтот начальный отрезок обязан совпадать со всем множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", так что это возможно лишь если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфны.\n\n\nСказанное позволяет сравнивать вполне упорядоченные множества.\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " изоморфно начальному отрезку множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", не совпадающему со всем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", то говорят, что ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "порядковый тип множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " меньше порядкового типа множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ""
    ]
  },
  ".\nЕсли множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфны, то говорят, что у них ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "одинаковые порядковые типы"
    ]
  },
  ".\nНаконец, если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфно начальному отрезку множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", то говорят, что ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "порядковый тип множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " больше порядкового типа множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ""
    ]
  },
  ".\nМы только что доказали такое утверждение:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_set-size",
      "meta": {
        "n": 22
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 22"
        ]
      },
      ". ",
      "Для любых вполне упорядоченных множеств ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      " имеет место ровно один из указанных трёх случаев.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_subset-init",
      "meta": {
        "n": 115
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "115"
            ]
          },
          ". ",
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " — вполне упорядоченное множество, а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " — его подмножество с индуцированным порядком\n(и, тем самым, тоже вполне упорядоченное множество).\nПокажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " изоморфно начальному отрезку ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\nПриведите пример, когда этот начальный отрезок совпадает со всем множеством ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ", хотя ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B \\not = A"
            ]
          },
          ".\n(Указание. Если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " изоморфно собственному начальному отрезку множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", нарушается ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_f(x)>x"
            },
            "children": [
              "теорема ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_f(x)>x",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЕсли временно забыть о проблемах оснований теории множеств и определить порядковый тип упорядоченного множества как класс изоморфных ему упорядоченных множеств, то можно сказать, что мы определили линейный порядок на порядковых типах вполне упорядоченных множеств (на ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "ординалах"
    ]
  },
  ", как говорят).\nЭтот порядок будет полным.\nМы переформулируем это утверждение так, чтобы избегать упоминания классов.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_min-set",
      "meta": {
        "n": 23
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 23"
        ]
      },
      ". ",
      "Всякое непустое семейство вполне упорядоченных множеств имеет «наименьший элемент» — множество, изоморфное начальным отрезкам всех остальных множеств.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВозьмём какое-то множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " семейства.\nЕсли оно наименьшее, то всё доказано.\nЕсли нет, рассмотрим все множества семейства, которые меньше его, то есть изоморфны его начальным отрезкам вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, x)"
    ]
  },
  ".\nСреди всех таких элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " выберем наименьший.\nТогда соответствующее ему множество и будет наименьшим.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_116",
      "meta": {
        "n": 116
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "116"
            ]
          },
          ". ",
          "\nПокажите, что для любого вполне упорядоченного множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " существует равномощное ему вполне упорядоченное множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " с таким свойством: любой начальный отрезок ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " (кроме всего ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ") имеет меньшую мощность, чем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ".\n(Множества с этим свойством — точнее, их порядковые типы — называют ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "кардиналами"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nИз ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-size"
    },
    "children": [
      "теоремы ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_set-size",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " следует, что любые два вполне упорядоченных множества сравнимы по мощности (одно равномощно подмножеству другого).\nСейчас мы увидим, что всякое множество может быть вполне упорядочено (",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order"
    },
    "children": [
      "теорема Цермело"
    ]
  },
  "), и, следовательно, любые два множества сравнимы по мощности.\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_6",
      "meta": {
        "n": 6,
        "longN": "2.6"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.6"
            ]
          },
          ". ",
          "Теорема Цермело",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_set-order",
      "meta": {
        "n": 24
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 24 (Цермело)"
        ]
      },
      ". ",
      "Всякое множество может быть вполне упорядочено.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nДоказательство этой теоремы существенно использует аксиому выбора и вызывало большие нарекания своей неконструктивностью.\nНа счётных множествах полный порядок указать легко (перенеся с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N"
    ]
  },
  ").\nНо уже на множестве действительных чисел никакого конкретного полного порядка указать не удаётся, и доказав (с помощью аксиомы выбора) его существование, мы так и не можем себе этот порядок представить.\n\n\nОбъясним, в какой форме используется аксиома выбора.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " — данное нам множество.\nМы принимаем, что существует функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi"
    ]
  },
  ", определённая на всех подмножествах множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", кроме самого´ ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", которая указывает один из элементов вне этого подмножества:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nX \\subsetneq A \\rArr \\varphi(X) \\in A \\setminus X.\n"
    ]
  },
  "\nПосле того как такая функция фиксирована, можно построить полный порядок на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", и в этом построении уже нет никакой неоднозначности.\nВот как это делается.\n\n\nНаименьшим элементом множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " мы объявим элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_0 = \\varphi(",
      "\\varnothing",
      ")"
    ]
  },
  ".\nЗа ним идёт элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_1 = \\varphi(\\{a_0\\})"
    ]
  },
  ";\nпо построению он отличается от ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_0"
    ]
  },
  ".\nДалее следует элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_2 = \\varphi(\\{a_0, a_1\\})"
    ]
  },
  ".\nЕсли множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " бесконечно, то такой процесс можно продолжать и получить последовательность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{a_0, a_1, \\dots \\}"
    ]
  },
  " элементов множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nЕсли после этого остаются ещё не использованные элементы множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", рассмотрим элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_{\\omega} = \\varphi(\\{a_0, a_1, a_2, \\dots \\})"
    ]
  },
  " и так будем продолжать, пока всё ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " не кончится;\nкогда оно кончится, порядок выбора элементов и будет полным порядком на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\n\n\nКонечно, последняя фраза нуждается в уточнении — что значит «так будем продолжать»?\nВозникает желание применить теорему о трансфинитной рекурсии\n(у нас очень похожая ситуация: следующий элемент определяется рекурсивно, если известны все предыдущие).\nИ это можно сделать, если у нас есть другое вполне упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", и получить взаимно однозначное соответствие либо между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и частью ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", либо между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и частью ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nВ первом случае всё хорошо, но для этого надо иметь вполне упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " по крайней мере той же мощности, что и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", так что получается некий порочный круг.\n\n\nТем не менее из него можно выйти.\nМы сделаем это так: рассмотрим все потенциальные кусочки будущего порядка и убедимся, что их можно склеить.\n\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(S, \\leqslant_S)"
    ]
  },
  " — некоторое подмножество множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и заданный на нём порядок.\nБудем говорить, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(S, \\leqslant_S)"
    ]
  },
  " является ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "корректным фрагментом"
    ]
  },
  ", если оно является вполне упорядоченным множеством, причём ",
  {
    "name": "math",
    "props": {},
    "children": [
      "s = \\varphi([0, s))"
    ]
  },
  " для любого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "s \\in S"
    ]
  },
  ".\nЗдесь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, s)"
    ]
  },
  " — начальный отрезок множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ", состоящий из всех элементов, меньших ",
  {
    "name": "math",
    "props": {},
    "children": [
      "s"
    ]
  },
  " с точки зрения заданного на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " порядка.\n\n\nНапример, множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{\\varphi(",
      "\\varnothing",
      ")\\}"
    ]
  },
  " является корректным фрагментом\n(порядок здесь можно не указывать, так как элемент всего один).\nМножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{\\varphi(",
      "\\varnothing",
      "), \\varphi(\\{\\varphi(",
      "\\varnothing",
      ")\\})\\}"
    ]
  },
  "\n(первый из выписанных элементов считается меньшим второго) также является корректным фрагментом.\nЭто построение можно продолжать и дальше, но нам надо каким-то образом «перескочить» через бесконечное (и очень большое в смысле мощности) число шагов этой конструкции.\n\n\nПлан такой: мы докажем, что любые два корректных фрагмента в определённом смысле согласованы, после чего рассмотреть объединение всех корректных фрагментов.\nОно будет корректным и будет совпадать со всем множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  "\n(в противном случае его можно было бы расширить и получить корректный фрагмент, не вошедший в объединение).\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "theorem_set-order-l_1"
    },
    "children": [
      "\n",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Лемма 1"
        ]
      },
      ". Пусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "(S, \\leqslant_S)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "(T, \\leqslant_T)"
        ]
      },
      " — два корректных фрагмента.\nТогда один из них является начальным отрезком другого, причём порядки согласованы\n(два общих элемента всё равно как сравнивать — в смысле ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\leqslant_S"
        ]
      },
      " или в смысле ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\leqslant_T"
        ]
      },
      ").\n"
    ]
  },
  "\n\n\nЗаметим, что по ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_A<>B"
    },
    "children": [
      "теореме ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_A<>B",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " один из фрагментов изоморфен начальному отрезку другого.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " изоморфен начальному отрезку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h: S \\to T"
    ]
  },
  " — их изоморфизм.\nЛемма утверждает, что изоморфизм ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h"
    ]
  },
  " является тождественным, то есть что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h(x) = x"
    ]
  },
  " при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in S"
    ]
  },
  ".\nДокажем это индукцией по ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in S"
    ]
  },
  "\n(это законно, так как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " вполне упорядочено по определению корректного фрагмента).\nИндуктивное предположение гарантирует, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h(y) = y"
    ]
  },
  " для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  ".\nМы хотим доказать, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h(x) = x"
    ]
  },
  ".\nРассмотрим начальные отрезки ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, x)_S"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, h(x))_T"
    ]
  },
  "\n(с точки зрения порядков ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_S"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_T"
    ]
  },
  " соответственно).\nОни соответствуют друг другу при изоморфизме ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h"
    ]
  },
  ", поэтому по предположению индукции совпадают как множества.\nНо по определению корректности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x = \\varphi([0, x))"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "h(x) = \\varphi([0, h(x)))"
    ]
  },
  ", так что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x = h(x)"
    ]
  },
  ".\nЛемма 1 доказана.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "theorem_set-order-l_2"
    },
    "children": [
      "\nРассмотрим объединение всех корректных фрагментов (как множеств).\nНа этом объединении естественно определён линейный порядок: для всяких двух элементов найдётся фрагмент, которому они оба принадлежат (каждый принадлежит своему, возьмём больший из фрагментов), так что их можно сравнить.\nПо ",
      {
        "name": "label",
        "props": {
          "ref": "theorem_set-order-l_1"
        },
        "children": [
          "лемме 1"
        ]
      },
      " порядок не зависит от того, какой фрагмент будет выбран для сравнения.\n\n\n",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Лемма 2"
        ]
      },
      ". Это объединение будет корректным фрагментом.\n"
    ]
  },
  "\n\n\nЧтобы доказать лемму 2, заметим, что на этом объединении определён линейный порядок.\nОн будет полным.\nДля разнообразия объясним это в терминах убывающих (невозрастающих) последовательностей.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0 \\geqslant x_1 \\geqslant \\dots"
    ]
  },
  "; возьмём корректный фрагмент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F"
    ]
  },
  ", которому принадлежит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0"
    ]
  },
  ".\nИз ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order-l_1"
    },
    "children": [
      "леммы 1"
    ]
  },
  " следует, что все ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_i"
    ]
  },
  " также принадлежат этому фрагменту\n(поскольку фрагмент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F"
    ]
  },
  " будет начальным отрезком в любом большем фрагменте),\nа ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F"
    ]
  },
  " вполне упорядочен по определению, так что последовательность стабилизируется.\nЛемма 2 доказана.\n\n\nУтверждение ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order-l_2"
    },
    "children": [
      "леммы 2"
    ]
  },
  " можно переформулировать таким образом: существует наибольший корректный фрагмент.\nОсталось доказать, что этот фрагмент (обозначим его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ") включает в себя всё множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S \\not = A"
    ]
  },
  ", возьмём элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a = \\varphi(S)"
    ]
  },
  ", не принадлежащий ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ", и добавим его к ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ", считая, что он больше всех элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ".\nПолученное упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S'"
    ]
  },
  " (сумма ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " и одноэлементного множества) будет, очевидно, вполне упорядочено.\nКроме того, условие корректности также выполнено\n(для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " — по построению, для остальных элементов — поскольку оно было выполнено в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ").\nТаким образом, мы построили больший корректный фрагмент, что противоречит максимальности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ".\nЭто рассуждение завершает доказательство теоремы Цермело.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nКак мы уже говорили, из ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order"
    },
    "children": [
      "теоремы Цермело"
    ]
  },
  " и ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_A<>B"
    },
    "children": [
      "теоремы ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_A<>B",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " о сравнении вполне упорядоченных множеств немедленно вытекает такое утверждение:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_set=subset",
      "meta": {
        "n": 25
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 25"
        ]
      },
      ". ",
      "Из любых двух множеств одно равномощно подмножеству другого.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_proof-<>=",
      "meta": {
        "n": 117
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "117"
            ]
          },
          ". ",
          "\nДокажите ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_<>="
            },
            "children": [
              "теорему Кантора–Бернштейна (теорема ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_<>=",
                  "path": "n"
                },
                "children": []
              },
              ")"
            ]
          },
          ", используя ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_set-order"
            },
            "children": [
              "теорему Цермело"
            ]
          },
          " и ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_A<>B"
            },
            "children": [
              "теорему ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_A<>B",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          ".\n(Указание. Достаточно доказать, что если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\sub B \\sub C"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " равномощно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ", то все три множества равномощны.\nМожно считать, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          " вполне упорядочено и является кардиналом.\n",
          {
            "name": "label",
            "props": {
              "ref": "problem_subset-init"
            },
            "children": [
              "Задача ",
              {
                "name": "use",
                "props": {
                  "ref": "problem_subset-init",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          " позволяет считать ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " начальным отрезком ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ", а ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " — начальным отрезком ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", и тогда оба этих отрезка должны совпасть со всем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "C"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nПонятие вполне упорядоченного множества ввёл ",
  {
    "name": "label",
    "props": {
      "ref": "name_cantor"
    },
    "children": [
      "Кантор"
    ]
  },
  " в работе 1883 года;\nв его итоговой работе 1895 – 1897 годов приводится доказательство того, что любые два вполне упорядоченных множества сравнимы\n(одно изоморфно начальному отрезку другого).\n\n\nУтверждения о возможности полного упорядочения любого множества и о сравнении мощностей (теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order"
    },
    "children": [
      "",
      {
        "name": "use",
        "props": {
          "ref": "theorem_set-order",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " и ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set=subset"
    },
    "children": [
      "n ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_set=subset",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ") неоднократно встречаются в работах Кантора, но никакого внятного доказательства он не предложил, и оно было дано лишь в 1904 году немецким математиком ",
  {
    "name": "label",
    "props": {
      "ref": "name_zermelo"
    },
    "children": [
      "Э. Цермело"
    ]
  },
  ".\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_7",
      "meta": {
        "n": 7,
        "longN": "2.7"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.7"
            ]
          },
          ". ",
          "Трансфинитная индукция и базис Гамеля",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nВполне упорядоченные множества и ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order"
    },
    "children": [
      "теорема Цермело"
    ]
  },
  " позволяют продолжать индуктивные построения в трансфинитную область (если выражаться торжественно).\nПоясним это на примере из линейной алгебры.\n\n\nВсякое линейно независимое множество векторов в конечномерном пространстве может быть дополнено до базиса.\nКак это доказывается?\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " — данное нам линейно независимое множество.\nЕсли оно не является базисом, то некоторый вектор ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_0"
    ]
  },
  " через него не выражается.\nДобавим его к ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  ", получим линейно независимое множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S \\cup \\{x_0\\}"
    ]
  },
  ".\nЕсли и оно не является базисом, то некоторый вектор ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x_1"
    ]
  },
  " через него не выражается, и т.д.\nЛибо на каком-то шаге мы получим базис, либо процесс не оборвётся и мы получим бесконечную последовательность линейно независимых векторов, что противоречит конечномерности.\n\n\nТеперь с помощью трансфинитной индукции (точнее, рекурсии) мы избавимся от требования конечномерности.\n\n\nПусть дано произвольное векторное пространство.\nГоворят, что множество (возможно, бесконечное) векторов ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "линейно независимо"
    ]
  },
  ", если никакая нетривиальная линейная комбинация конечного числа векторов из этого множества не равна нулю.\n(Заметим в скобках, что говорить о бесконечных линейных комбинациях в принципе можно лишь если в пространстве определена сходимость, чего мы сейчас не предполагаем.)\nЛинейно независимое множество векторов называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "базисом ",
      {
        "name": "label",
        "props": {
          "ref": "name_hamel"
        },
        "children": [
          "Гамеля"
        ]
      },
      ""
    ]
  },
  " (или просто ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "базисом"
    ]
  },
  ") данного пространства, если любой вектор представим в виде конечной линейной комбинации элементов этого множества.\n\n\nКак и в конечной ситуации, максимальное линейно независимое множество (которое становится линейно зависимым при добавлении любого нового элемента) является, очевидно, базисом.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_26",
      "meta": {
        "n": 26
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 26"
        ]
      },
      ". ",
      "Всякое линейно независимое множество векторов может быть расширено до базиса Гамеля.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " — линейно независимое подмножество векторного пространства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  ".\nРассмотрим вполне упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " достаточно большой мощности (большей, чем мощность пространства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  ").\nОпределим функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  " с помощью трансфинитной рекурсии:\n\n\n",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "\n",
      {
        "name": "math",
        "props": {},
        "children": [
          "f(i) ="
        ]
      },
      " элемент пространства ",
      {
        "name": "math",
        "props": {},
        "children": [
          "V"
        ]
      },
      ", не выражающийся линейно через элементы ",
      {
        "name": "math",
        "props": {},
        "children": [
          "S"
        ]
      },
      " и значения ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f(j)"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {},
        "children": [
          "j < i"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\nЗаметим, что это рекурсивное правило оставляет ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(i)"
    ]
  },
  " неопределённым, если такого невыразимого элемента не существует.(Кроме того, можно отметить, что мы снова используем аксиому выбора.\nБолее подробно следовало бы сказать так: по аксиоме выбора существует некоторая функция, которая по каждому подмножеству пространства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  ", через которое не всё ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  " выражается, указывает один из невыразимых элементов.\nЗатем эта функция используется в рекурсивном определении.\nВпрочем, аксиома выбора и так уже использована для доказательства ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order"
    },
    "children": [
      "теоремы Цермело"
    ]
  },
  ".)\n\n\nЭто определение гарантирует, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " является инъекцией;\nболее того можно утверждать, что все значения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " вместе с множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " образуют линейно независимое множество.\nВ самом деле, пусть линейная комбинация некоторых значений функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " и элементов множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " равна нулю.\nМожно считать, что все коэффициенты в этой комбинации отличны от нуля (отбросив нулевые слагаемые).\nВходящие в комбинацию значения функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " имеют вид ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(i)"
    ]
  },
  " при различных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ".\nПосмотрим на тот из них, который имеет наибольшее ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ";\nпо построению он должен быть линейно независим от остальных — противоречие.\n\n\nПоскольку мы предположили, что множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " имеет большую мощность, чем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  ", рекурсивное определение задаёт функцию не на всём ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  ", а только на некотором начальном отрезке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, i)"
    ]
  },
  ", а в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  " рекурсивное правило не определено (",
  {
    "name": "label",
    "props": {
      "ref": "theorem_recursive-rule"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_recursive-rule",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ").\nЭто означает, что все векторы пространства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  " выражаются через элементы множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "S"
    ]
  },
  " и значения функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " на промежутке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, i)"
    ]
  },
  ".\nКроме того, как мы видели, все эти векторы независимы.\nТаким образом, искомый базис найден.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "basis-construct"
    },
    "children": [
      "\nНа самом деле можно обойтись без множества большей мощности, упорядочив само пространство ",
      {
        "name": "math",
        "props": {},
        "children": [
          "V"
        ]
      },
      ".\nПри этом на каждом шаге рекурсии надо либо добавлять очередной элемент к будущему базису (если он не выражается через предыдущие), либо оставлять базис без изменений.\n\n\n",
      "\n        ",
      {
        "name": "area",
        "props": {
          "key": "problem_basis-construct",
          "meta": {
            "n": 118
          }
        },
        "children": [
          "\n        ",
          {
            "name": "format.small",
            "props": {},
            "children": [
              "",
              {
                "name": "format.b",
                "props": {},
                "children": [
                  "118"
                ]
              },
              ". ",
              "Проведите это рассуждение подробно.",
              ""
            ]
          },
          "\n        "
        ]
      },
      "\n        ",
      "\n"
    ]
  },
  "\n\n\nБазис Гамеля может быть использован для построения разных экзотических примеров.\nВот некоторые из них:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_linear-func",
      "meta": {
        "n": 27
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 27"
        ]
      },
      ". ",
      "Существует (всюду определённая) функция ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f: \\R \\to \\R"
        ]
      },
      ", для которой ",
      {
        "name": "math",
        "props": {},
        "children": [
          "f(x + y) = f(x) + f(y)"
        ]
      },
      " при всех ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "y"
        ]
      },
      ", но которая не есть умножение на константу.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nРассмотрим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R"
    ]
  },
  " как векторное пространство над полем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q}"
    ]
  },
  ".\nВ нём есть базис Гамеля.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " — один из векторов базиса.\nРассмотрим функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ", которая с каждым числом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  "\n(рассматриваемым как вектор в пространстве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R"
    ]
  },
  " над полем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q}"
    ]
  },
  ")\nсопоставляет его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  "-координату\n(коэффициент при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " в единственном выражении ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " через векторы базиса).\nЭта функция линейна над ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q}"
    ]
  },
  ", поэтому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x + y) = f(x) + f(y)"
    ]
  },
  " для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x, y \\in \\R"
    ]
  },
  ".\nОна отлична от нуля (",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(\\alpha) = 1"
    ]
  },
  ") и принимает лишь рациональные значения, поэтому не может быть умножением на константу.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_119",
      "meta": {
        "n": 119
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "119"
            ]
          },
          ". ",
          "Покажите, что всякая функция, обладающая указанными в ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_linear-func"
            },
            "children": [
              "теореме ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_linear-func",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          " свойствами, не ограничена ни на каком отрезке и, более того, её график всюду плотен в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\R^2"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_28",
      "meta": {
        "n": 28
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 28"
        ]
      },
      ". ",
      "Аддитивные группы ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\R"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\R \\oplus \\R"
        ]
      },
      " изоморфны.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nРассмотрим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R"
    ]
  },
  " как векторное пространство над ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q}"
    ]
  },
  " и выберем базис в этом пространстве.\nОчевидно, он бесконечен.\nБазис в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R \\oplus \\R"
    ]
  },
  " может быть составлен из двух частей, каждая из которых представляет собой базис в одном из экземпляров ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R"
    ]
  },
  ".\nКак мы увидим чуть позже (см. раздел ",
  {
    "name": "link",
    "props": {
      "ref": "paragraph_cardinal-rules"
    },
    "children": [
      "",
      {
        "name": "use",
        "props": {
          "ref": "paragraph_cardinal-rules",
          "path": "longN"
        },
        "children": []
      },
      ""
    ]
  },
  "), для любого бесконечного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " удвоенная мощность ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "\n(мощность объединения двух непересекающихся множеств, равномощных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ") равна мощности ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nНаконец, осталось заметить, что пространства над одним и тем же полем с равномощными базисами изоморфны как векторные пространства и тем более как группы.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_120",
      "meta": {
        "n": 120
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "120"
            ]
          },
          ". ",
          "\nДокажите, что любой базис в пространстве ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\R"
            ]
          },
          " над полем ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\Bbb{Q}"
            ]
          },
          " имеет мощность континуума.\n(При доказательстве пригодятся результаты раздела ",
          {
            "name": "link",
            "props": {
              "ref": "paragraph_cardinal-rules"
            },
            "children": [
              "",
              {
                "name": "use",
                "props": {
                  "ref": "paragraph_cardinal-rules",
                  "path": "longN"
                },
                "children": []
              },
              ""
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nМы видели, что трансфинитная индукция позволяет доказать существование базиса в любом векторном пространстве.\nПродолжая эту линию, можно доказать, что любые два базиса векторного пространства равномощны.\n(Таким образом, понятие размерности как мощности базиса корректно определено и для бесконечномерных векторных пространств.)\nМы вернёмся к этому позже(",
  {
    "name": "label",
    "props": {
      "ref": "theorem_inf-basis"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_inf-basis",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ").\n\n\nОтметим, что существование базиса Гамеля можно использовать и «в мирных целях», а не только для построения экзотических примеров.\nИзвестная «третья проблема ",
  {
    "name": "label",
    "props": {
      "ref": "name_hilbert"
    },
    "children": [
      "Гильберта"
    ]
  },
  "» состояла в доказательстве того, что многогранники равного объёма могут не быть равносоставлены.\n(Это значит, что один из них нельзя разрезать на меньшие многогранники и сложить из них другой многогранник.)\nДля многоугольников на плоскости ситуация иная: если два многоугольника равновелики (имеют равную площадь), то они равносоставлены.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_29",
      "meta": {
        "n": 29
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 29"
        ]
      },
      ". ",
      "Куб нельзя разрезать на многогранные части, из которых можно было бы составить правильный тетраэдр.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВведём понятие ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "псевдообъёма"
    ]
  },
  " многогранника.\nКак и объём, псевдообъём будет аддитивен\n(если многогранник разбит на части, сумма их псевдообъёмов равна псевдообъёму исходного многогранника);\nпсевдообъёмы равных многогранников будут равны.\nОтсюда следует, что псевдообъёмы равносоставленных многогранников будут равны.\nМы подберём псевдообъём так, чтобы у куба он равнялся нулю, а у тетраэдра нет — и доказательство будет завершено.\n\n\nПсевдообъём многогранника мы определим как сумму ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sum l_i \\varphi(\\alpha_i)"
    ]
  },
  ", где сумма берётся по всем рёбрам многогранника, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l_i"
    ]
  },
  " — длина ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  "-го ребра, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_i"
    ]
  },
  " — двугранный угол при этом ребре, а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi"
    ]
  },
  " — некоторая функция.\nТакое определение автоматически гарантирует, что равные многогранники имеют равные псевдообъёмы.\nЧто нужно от функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi"
    ]
  },
  ", чтобы псевдообъём был аддитивен?\nПредставим себе, что многогранник разрезается плоскостью на две части, и плоскость проходит через уже имеющееся ребро длины ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l"
    ]
  },
  ".\nТогда двугранный угол ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " при этом ребре разбивается на две части ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma"
    ]
  },
  ".\nПоэтому в выражении для псевдообъёма вместо слагаемого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l \\varphi(\\alpha)"
    ]
  },
  " появляются слагаемые ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l \\varphi(\\beta) + l \\varphi(\\gamma)"
    ]
  },
  ", и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi(\\alpha)"
    ]
  },
  " должно равняться ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi(\\beta) + \\varphi(\\gamma)"
    ]
  },
  ".\nКроме того, разрезающая плоскость может образовать новое ребро, пересекшись с какой-то гранью.\nОбозначим длину этого ребра за ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l'"
    ]
  },
  ".\nТогда в псевдообъёме появятся слагаемые ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l' \\varphi(\\alpha) + l' \\varphi(\\pi - \\alpha)"
    ]
  },
  "\n(два образовавшихся двугранных угла дополнительны), которые в сумме должны равняться нулю.\n\n\nТеперь ясно, какими свойствами должна обладать функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi"
    ]
  },
  ".\nНужно, чтобы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi(\\beta + \\gamma) = \\varphi(\\beta) + \\varphi(\\gamma)"
    ]
  },
  " и чтобы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi(\\pi) = 0"
    ]
  },
  ".\nТогда псевдообъём будет и впрямь аддитивен.\nАккуратная проверка требует точного определения понятия многогранника (что не так и просто), и мы её проводить не будем.\nНаглядно аддитивность кажется очевидной, особенно если учесть, что все разрезы можно проводить плоскостями\n(при этом могут получиться более мелкие части, но это не страшно).\n\n\nИтак, для завершения рассуждения достаточно построить функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi: \\R \\to \\R"
    ]
  },
  ", для которой\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\varphi(\\beta + \\gamma) = \\varphi(\\beta) + \\varphi(\\gamma)"
            ]
          },
          " для всех ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta, \\gamma \\in \\R"
            ]
          },
          ";\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\varphi(\\pi) = 0"
            ]
          },
          " (это свойство вместе с предыдущим гарантирует аддитивность псевдообъёма);\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\varphi(\\pi / 2) = 0"
            ]
          },
          " (псевдообъём куба равен нулю; это свойство, впрочем, легко следует из двух предыдущих);\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\varphi(\\theta) \\not = 0"
            ]
          },
          ", где ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\theta"
            ]
          },
          " — двугранный угол при ребре правильного тетраэдра.\n"
        ]
      },
      "\n"
    ]
  },
  "\n\nСущественно здесь то, что отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\theta / \\pi"
    ]
  },
  " иррационально.\nПроверим это.\nВысоты двух соседних граней, опущенные на общее ребро, образуют равнобедренный треугольник со сторонами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sqrt{3}, \\sqrt{3}, 2"
    ]
  },
  ";\nнадо доказать, что углы этого треугольника несоизмеримы с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\pi"
    ]
  },
  ".\nУдобнее рассмотреть не ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\theta"
    ]
  },
  ", а другой угол треугольника (два других угла треугольника равны); обозначим его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ".\nЭто угол прямоугольного треугольника со сторонами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1, \\sqrt{2}"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sqrt{3}"
    ]
  },
  ", так что\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(\\cos \\beta + i \\sin \\beta) = (1 + \\sqrt{-2}) / \\sqrt{3}.\n"
    ]
  },
  "\nЕсли бы угол ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\theta"
    ]
  },
  " был соизмерим с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\pi"
    ]
  },
  ", то и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  " был бы соизмерим, поэтому некоторая степень этого комплексного числа равнялась бы единице.\nМожно проверить, однако, что это не так, поскольку кольцо чисел вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "m + n \\sqrt{-2} (m, n \\in Z)"
    ]
  },
  " евклидово и разложение на множители в нём однозначно.\n\n\nДальнейшее просто: рассмотрим числа ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\pi"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\theta"
    ]
  },
  ".\nОни независимы как элементы векторного пространства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R"
    ]
  },
  " над ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q}"
    ]
  },
  ", дополним их до базиса и рассмотрим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\Bbb{Q}"
    ]
  },
  "-линейный функционал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varphi: \\R \\to \\Bbb{Q}"
    ]
  },
  ", равный коэффициенту при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\theta"
    ]
  },
  " в разложении по этому базису.\nОчевидно, все требования при этом будут выполнены.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_121",
      "meta": {
        "n": 121
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "121"
            ]
          },
          ". ",
          "\nПокажите, что некоторое усложнение этого рассуждения позволяет обойтись без базиса Гамеля: достаточно определять ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\varphi"
            ]
          },
          " не на всех действительных числах, а только на линейных комбинациях углов, встречающихся при разрезании куба и тетраэдра на части.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВ качестве отступления приведём ещё два странных примера, возникающих благодаря аксиоме выбора\n(в них даже трансфинитная индукция не используется).\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Разноцветные шляпы"
    ]
  },
  ". Представим себе сначала шеренгу из ста человек в чёрных и белых шляпах.\nКаждый видит цвета шляп стоящих перед ним, но не видит своей шляпы и шляп позади стоящих, и должен отгадать цвет своей шляпы.\nМогут ли участники игры договориться заранее, как они должны действовать, чтобы с гарантией большинство догадок было правильными?\n(Игроки не произносят вслух свои догадки, так что другие игроки не могут их учитывать.)\n\n\nЛегко понять, что стоящая перед игроками задача неразрешима.\nСтоящий первым в шеренге не видит никого, так что его догадка ни от чего не зависит и заранее предопределена.\nНаденем ему шляпу другого цвета и сделаем его догадку ошибочной\nЦвет шляпы первого определяет догадку второго (у которого нет иной информации), и ему тоже можно надеть шляпу другого цвета.\nПосле этого определится догадка третьего, и так далее.\nТаким образом, для любой стратегии действий игроков есть вариант, в котором все ошибутся.\n\n\nСитуация удивительным образом меняется, если игроки стоят в бесконечной шеренге, у которой есть последний, но нет первого, и каждый из игроков видит шляпы впереди стоящих.\nДругими словами, игроки стоят в точках ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0, 1, 2, \\dots"
    ]
  },
  " числовой прямой, глядя вправо, и игрок в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  " знает свою координату и цвета шляп всех следующих игроков (",
  {
    "name": "math",
    "props": {},
    "children": [
      "i + 1, i + 2, \\dots"
    ]
  },
  ").\nЕго стратегия, таким образом, является функцией, аргумент которой — последовательность цветов видимых им шляп, а значением — догадка о цвете собственной шляпы.\n\n\nКак ни странно, существуют стратегии игроков, при которых с гарантией все догадки, кроме конечного числа, будут правильными.\nЧтобы доказать существование таких стратегий, будем называть «раскраской» последовательность цветов шляп всех игроков.\nДве раскраски будем называть эквивалентными, если они различаются лишь в конечном числе точек (для конечного числа игроков).\nВыберем в каждом классе эквивалентности по одной «канонической» раскраске.\nКаждый игрок должен действовать так: видя всех игроков перед собой, он может определить класс эквивалентности раскраски\n(так как изменение конечного числа остальных игроков, включая его самого´, не меняет этого класса).\nЗатем в качестве догадки он указывает цвет своей шляпы в каноническом представителе этого класса эквивалентности.\n\n\nКакова бы ни была реальная раскраска, она отличается от эквивалентной ей канонической раскраски лишь в конечном числе мест (по определению эквивалентности).\nПоэтому все игроки, стоящие дальше этих мест, угадают правильно — у них самих тот же цвет, и видят они то же самое, что в канонической раскраске.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_122",
      "meta": {
        "n": 122
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "122"
            ]
          },
          ". ",
          "\nПокажите, что игроки могут добиться того же результата (гарантировать конечное число неверных догадок) и в более сложной ситуации, когда они не знают своего положения.\n(Полезно отдельно рассмотреть классы, содержащие периодические раскраски.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Неизмеримое множество"
    ]
  },
  ". Будем считать две точки окружности эквивалентными, если дуга между ними составляет рациональную часть окружности (",
  {
    "name": "math",
    "props": {},
    "children": [
      "="
    ]
  },
  " измеряется рациональным числом градусов).\nЭто действительно отношение эквивалентности, так как сумма двух рациональных чисел рациональна (транзитивность).\nВыберем в каждом классе эквивалентности по одной точке;\nполученное множество «представителей» обозначим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  ".\n\n\nЕсли повернуть множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  " на рациональный (в градусах, то есть соизмеримый с окружностью) угол ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ", то повёрнутое множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M_{\\alpha}"
    ]
  },
  " не будет пересекаться с исходным: пересечение означало бы, что есть два представителя, отличающихся на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ", то есть лежащих в одном и том же классе.\n\n\nС другой стороны, в объединении множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M_{\\alpha}"
    ]
  },
  " (при всех рациональных углах поворота ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ") дают всю окружность (каждая точка имеет представителя в своём классе, и поворот ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M"
    ]
  },
  " на соответствующий угол покроет её).\n\n\nПолучается, что окружность разбита на счётное число конгруэнтных (совмещающихся поворотом) множеств.\nКакую же долю окружности (по мере) составляет каждое множество?\nПоскольку множества конгруэнтны, то эти доли равны;\nпоскольку они все помещаются в окружности без пересечений, то доля не может быть положительной, то есть равна нулю.\n\n\nКак ни странно, в объединении счётное число таких «нулевых» множеств составляет всю окружность.\n(Говоря более формально, не существует ненулевой счётно-аддитивной меры, определённой на всех подмножествах окружности и инвариантной относительно поворотов.)\n\n\nЕщё удивительнее пространственный вариант этого примера: можно разбить шар на конечное число непересекающихся множеств, из которых (сдвинув каждую часть в пространстве) можно получить два шара того же размера.\nЭтот пример называют «парадоксом ",
  {
    "name": "label",
    "props": {
      "ref": "name_banach"
    },
    "children": [
      "Банаха"
    ]
  },
  "—",
  {
    "name": "label",
    "props": {
      "ref": "name_tarski"
    },
    "children": [
      "Тарского"
    ]
  },
  "».\nНо это построение сложнее и требует знакомства с алгеброй\n(в одном из вариантов используется свободная подгруппа с двумя образующими в группе ",
  {
    "name": "math",
    "props": {},
    "children": [
      "SO(3)"
    ]
  },
  ").\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_8",
      "meta": {
        "n": 8,
        "longN": "2.8"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.8"
            ]
          },
          ". ",
          "Лемма Цорна и её применения",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nВ современных учебниках редко встречается трансфинитная индукция как таковая: она заменяется ссылкой на так называемую лемму ",
  {
    "name": "label",
    "props": {
      "ref": "name_zorn"
    },
    "children": [
      "Цорна"
    ]
  },
  ".\nСейчас мы покажем, как это делается, на примере теоремы о существовании базиса в линейном пространстве.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_zorns-lemma",
      "meta": {
        "n": 30
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 30 (лемма Цорна)"
        ]
      },
      ". ",
      "\nПусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "Z"
        ]
      },
      " — частично упорядоченное множество, в котором всякая цепь имеет верхнюю границу.\nТогда в этом множестве есть максимальный элемент, и, более того, для любого элемента ",
      {
        "name": "math",
        "props": {},
        "children": [
          "a \\in Z"
        ]
      },
      " существует элемент ",
      {
        "name": "math",
        "props": {},
        "children": [
          "b \\geqslant a"
        ]
      },
      ", являющийся максимальным в ",
      {
        "name": "math",
        "props": {},
        "children": [
          "Z"
        ]
      },
      ".\n(",
      {
        "name": "format.i",
        "props": {},
        "children": [
          "Цепь"
        ]
      },
      " — это подмножество, любые два элемента которого сравнимы.\nВерхняя граница цепи — элемент, больший или равный любого элемента цепи.)\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПрежде всего отметим, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  " лишь частично упорядочено, поэтому надо различать максимальные и наибольшие элементы.\nПо этой же причине мы вынуждены употреблять грамматически некорректную конструкцию «больший или равный любого (любому?)», поскольку сказать «не меньше любого» (стандартный выход из положения) означало бы изменить смысл.\n\n\nДоказательство повторяет рассуждения при построении базиса, но в более общей ситуации\n(теперь у нас не линейно независимые семейства, а произвольные элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  ").\n\n\nПусть дан произвольный элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ".\nПредположим, что не существует максимального элемента, большего или равного ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ".\nЭто значит, что для любого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\geqslant a"
    ]
  },
  " найдётся ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c > b"
    ]
  },
  ".\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c > a"
    ]
  },
  " и потому найдётся ",
  {
    "name": "math",
    "props": {},
    "children": [
      "d > c"
    ]
  },
  " и т.д.\nПродолжая этот процесс достаточно долго, мы исчерпаем все элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  " и придём к противоречию.\n\n\nПроведём рассуждение аккуратно (пока что мы даже не использовали условие леммы, касающееся цепей).\nВозьмём вполне упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " достаточно большой мощности (большей, чем мощность Z).\nПостроим строго возрастающую функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: I \\to Z"
    ]
  },
  " по трансфинитной рекурсии.\nЕё значение на минимальном элементе ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " будет равно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ".\nПредположим, что мы уже знаем все её значения на всех элементах, меньших некоторого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ".\nВ силу монотонности эти значения попарно сравнимы.\nПоэтому существует их верхняя граница ",
  {
    "name": "math",
    "props": {},
    "children": [
      "s"
    ]
  },
  ", которая, в частности, больше или равна ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ".\nВозьмём какой-то элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "t > s"
    ]
  },
  " и положим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(i) = t"
    ]
  },
  "; по построению монотонность сохранится.\nТем самым ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " равномощно части ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  ", что противоречит его выбору.\n\n\nВ этом рассуждении, формально говоря, есть пробел: мы одновременно определяем функцию по трансфинитной рекурсии и доказываем её монотонность с помощью трансфинитной индукции.\nНаше рекурсивное определение имеет смысл, лишь если уже построенная часть функции монотонна.\nФормально говоря, надо воспользоваться ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_recursive-rule"
    },
    "children": [
      "теоремой ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_recursive-rule",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ", считая, что следующее значение не определено, если уже построенный участок не монотонен, и получить функцию, определённую на всём ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " или на начальном отрезке.\nЕсли она определена на некотором начальном отрезке, то она монотонна на нём по построению, поэтому следующее значение тоже определено — противоречие.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nКак и при построении базиса Гамеля (",
  {
    "name": "label",
    "props": {
      "ref": "basis-construct"
    },
    "children": [
      "задача ",
      {
        "name": "use",
        "props": {
          "ref": "problem_basis-construct",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  "), можно обойтись без множества большей мощности.\nВполне упорядочим множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  " с помощью ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-order"
    },
    "children": [
      "теоремы Цермело"
    ]
  },
  ".\nЭтот порядок никак не связан с исходным порядком на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  ";\nмы будем обозначать его символом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\prec"
    ]
  },
  ".\nПостроим с помощью трансфинитной рекурсии функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: Z → Z"
    ]
  },
  " с такими свойствами:\n(1) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(z) > a"
    ]
  },
  " для любого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z \\in Z"
    ]
  },
  ";\n(2) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " монотонна в следующем смысле: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\prec y"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(x) \\leqslant f(y)"
    ]
  },
  ";\n(3) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(z)"
    ]
  },
  " не может быть строго меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  " (в смысле исходного порядка ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  ") ни при каком ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  ".\n\n\nДелается это так.\nЗначение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(z_0)"
    ]
  },
  " для ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\prec"
    ]
  },
  "-наименьшего элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z_0"
    ]
  },
  " мы положим равным либо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  ", либо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z_0"
    ]
  },
  " (последнее — если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z_0 > a"
    ]
  },
  ").\nЗначение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(z)"
    ]
  },
  " для остальных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  " есть либо верхняя граница значений ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(z')"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z' \\prec z"
    ]
  },
  "\n(по предположению индукции множество таких значений линейно упорядочено и потому имеет некоторую верхнюю границу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  "), либо само ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  " (последнее — если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z > \\alpha"
    ]
  },
  ").\n\n\nВ силу монотонности множество значений функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " линейно упорядочено и имеет верхнюю границу.\nЭта граница (обозначим её ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ") больше или равна ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a"
    ]
  },
  " (которое есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(z_0)"
    ]
  },
  ") и является искомым максимальным элементом: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < z"
    ]
  },
  " для некоторого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(z) \\leqslant \\beta < z"
    ]
  },
  ", что противоречит свойству (3).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_123",
      "meta": {
        "n": 123
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "123"
            ]
          },
          ". ",
          "Проведите это рассуждение подробно.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nТеперь повторим доказательство теоремы о базисе, используя лемму Цорна.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  " — произвольное векторное пространство.\nРассмотрим частично упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  ", состоящее из линейно независимых подмножеств пространства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "V"
    ]
  },
  ".\nПорядок на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  " задаётся отношением «быть подмножеством».\n\n\nПроверим, что условия леммы выполнены.\nПусть имеется некоторая цепь, то есть семейство линейно независимых множеств, причём любые два множества этого семейства сравнимы.\nОбъединим все эти множества и покажем, что полученное множество будет линейно независимым (тем самым оно будет верхней границей элементов цепи).\nВ самом деле, нетривиальная линейная комбинация включает в себя какое-то конечное число векторов, каждый из своего множества.\nЭтих множеств конечное число, и потому среди них есть наибольшее по включению (в конечном линейно упорядоченном множестве есть наибольший элемент).\nЭто наибольшее множество содержит все векторы нетривиальной линейной комбинации, и линейно независимо по предположению, так что наша нетривиальная линейная комбинация отлична от нуля.\n\n\nТаким образом, можно применить лемму Цорна и заключить, что любое линейно независимое множество векторов содержится в максимальном линейно независимом множестве векторов.\nК нему уже нельзя добавить ни одного вектора, не создав линейной зависимости, и оно является искомым базисом.\n\n\nАналогичным образом можно доказать существование ортогонального базиса в гильбертовом пространстве\n(там определение базиса другое: разрешаются бесконечные линейные комбинации, понимаемые как суммы рядов)\nили существование базиса трансцендентности (максимальная алгебраически независимая система элементов в расширении полей).\n\n\nМы приведём другой пример применения леммы Цорна, где фигурируют уже известные нам понятия.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_31",
      "meta": {
        "n": 31
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 31"
        ]
      },
      ". ",
      "Всякий частичный порядок может быть продолжен до линейного.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(X, \\leqslant)"
    ]
  },
  " — частично упорядоченное множество.\nТеорема утверждает, что существует отношение порядка ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant'"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ", продолжающее исходное\n(это значит, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant y \\rArr x \\leqslant' y"
    ]
  },
  ") и являющееся отношением линейного порядка.\n(Кстати, отметим, что слово «линейного» в формулировке теоремы нельзя заменить на слово «полного» — например, если исходный порядок линейный, но не полный.)\n\n\nГотовясь к применению леммы Цорна, рассмотрим частично упорядоченное множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "Z"
    ]
  },
  ", элементами которого будут частичные порядки на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  "\n(то есть подмножества множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X \\times X"
    ]
  },
  ", обладающие свойствами рефлексивности, транзитивности и антисимметричности),\nупорядоченные по включению: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_1"
    ]
  },
  " считается меньшим или равным ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_2"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_2"
    ]
  },
  " продолжает ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_1"
    ]
  },
  " (из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant_1 y"
    ]
  },
  " следует ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant_2 y"
    ]
  },
  ").\n\n\nЛегко проверить, что условие леммы Цорна выполнено: если у нас есть семейство частичных порядков, линейно упорядоченное по включению, то объединение этих порядков является частичным порядком, и этот порядок будет верхней границей семейства.\n(Проверим, например, что объединение обладает свойством транзитивности.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant_1 y"
    ]
  },
  " в одном из порядков семейства (",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_1"
    ]
  },
  "), а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant_2 z"
    ]
  },
  " в другом;\nодин из порядков (например, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant_1"
    ]
  },
  ") продолжает другой, тогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant_1 y \\leqslant_1 z"
    ]
  },
  " и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant z"
    ]
  },
  " в объединении.\nРефлексивность и антисимметричность проверяются столь же просто.)\n\n\nСледовательно, по лемме Цорна на множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " существует максимальный частичный порядок, продолжающий исходный.\nОбозначим его как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  "\n(путаницы с исходным порядком не возникнет, так как исходный нам больше не нужен).\nНам надо показать, что он будет линейным.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x, y \\in X"
    ]
  },
  " — два несравнимых элемента.\nРасширим порядок до нового порядка ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant'"
    ]
  },
  ", при котором ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\leqslant' y"
    ]
  },
  ".\nЭтот новый порядок определяется так: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant' b"
    ]
  },
  ", если (1) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant b"
    ]
  },
  " или (2) ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant x"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant b"
    ]
  },
  ".\nНесложно проверить, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant'"
    ]
  },
  " будет частичным порядком.\nРефлексивность очевидна.\nТранзитивность: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant' b"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\leqslant' c"
    ]
  },
  ", то есть четыре возможности.\nЕсли в обоих случаях имеет место случай (1), то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant b \\leqslant c"
    ]
  },
  " и всё очевидно.\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant' b"
    ]
  },
  " в силу (1), а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\leqslant c"
    ]
  },
  " в силу (2), то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant b \\leqslant x"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant c"
    ]
  },
  ", так что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant' c"
    ]
  },
  " в силу (2).\nАналогично рассматривается и симметричный случай.\nНаконец, двукратная ссылка на (2) невозможна, так как тогда (",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\leqslant x"
    ]
  },
  "), (",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant b"
    ]
  },
  "), (",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\leqslant x"
    ]
  },
  ") и (",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant c"
    ]
  },
  "), и получается, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\leqslant b \\leqslant x"
    ]
  },
  ", а мы предполагали, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  " не сравнимы.\nАнтисимметричность доказывается аналогично.\nТаким образом, отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant'"
    ]
  },
  " будет частичным порядком, строго содержащим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\leqslant"
    ]
  },
  ", что противоречит максимальности.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_124",
      "meta": {
        "n": 124
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "124"
            ]
          },
          ". ",
          "\nПокажите, что любое бинарное отношение без циклов\n(цикл образуется, если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "xRx"
            ]
          },
          ", или ",
          {
            "name": "math",
            "props": {},
            "children": [
              "xRyRx"
            ]
          },
          ", или ",
          {
            "name": "math",
            "props": {},
            "children": [
              "xRyRzRx"
            ]
          },
          " и т.д.)\nможет быть продолжено до линейного порядка.\n(Для конечных множеств поиск такого продолжения обычно называют «топологической сортировкой».)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_125",
      "meta": {
        "n": 125
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "125"
            ]
          },
          ". ",
          "\nМножество на плоскости называется ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "выпуклым"
            ]
          },
          ", если вместе с любыми двумя точками оно содержит соединяющий их отрезок.\nПокажите, что любые два непересекающихся выпуклых множества можно разделить прямой\n(каждое множество лежит по одну сторону от прямой, возможно, пересекаясь с ней).\n(Указание. Используя лемму Цорна, можно расширить исходные непересекающиеся множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " до взаимно дополнительных выпуклых множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A'"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B'"
            ]
          },
          ".\nЗатем можно убедиться, что граница между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A'"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B'"
            ]
          },
          " представляет собой прямую.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_126",
      "meta": {
        "n": 126
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "126"
            ]
          },
          ". ",
          "\nПокажите, что все подмножества натурального ряда можно разбить на «большие» и «малые» таким образом, чтобы выполнялись следующие свойства:\n(1) множество большое тогда и только тогда, когда его дополнение мало;\n(2) любое подмножество малого множества мало, а любое надмножество большого множества — большое;\n(3) объединение двух малых множеств мало, а пересечение двух больших множеств — большое;\n(4) все конечные множества — малые, а все множества с конечными дополнениями — большие.\n(Вначале будем требовать условий (1) – (4), но не настаивать на том, что любое множество должно быть большим или\nмалым.\nНапример, можно считать малыми конечные множества, а большими — их дополнения.\nЗатем можно добавлять множества, определяя их в большие или малые, применив трансфинитную индукцию или лемму Цорна.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nПостроенное в этой задаче деление множеств на большие и малые (точнее, класс больших множеств) называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "неглавным ультрафильтром"
    ]
  },
  ";\nслово «ультра» здесь соответствует требованию того, что всякое множество большое или малое; слово «неглавный» обозначает\nтребование (4).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_127",
      "meta": {
        "n": 127
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "127"
            ]
          },
          ". ",
          "\n(Продолжение.) Два агрессора играют в такую игру: сначала первый захватывает начальный отрезок натурального ряда произвольного размера (от ",
          {
            "name": "math",
            "props": {},
            "children": [
              "0"
            ]
          },
          " до какого-то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "), затем второй захватывает примыкающий отрезок (от ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k + 1"
            ]
          },
          " до какого-то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l"
            ]
          },
          ", затем первый захватывает следующий (от ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l + 1"
            ]
          },
          " до какого-то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m"
            ]
          },
          "), и т.д.\nИгра бесконечна; победителем в бесконечной партии считается тот игрок, который захватил большое множество.\nПокажите, что в этой игре ни один из игроков не имеет выигрышной стратегии.\n(Выигрышную стратегию для одного мог бы использовать и другой, поскольку конечный начальный участок не влияет на исход игры.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/2/9/img6.svg",
      "src": "/data/books/data/vereshagin-shen-sets/2/9/img6.svg"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/2/9/img7.svg",
      "src": "/data/books/data/vereshagin-shen-sets/2/9/img7.svg"
    },
    "children": []
  },
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_cardinal-rules",
      "meta": {
        "n": 9,
        "longN": "2.9"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.9"
            ]
          },
          ". ",
          "Свойства операций над мощностями",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nТеперь мы можем доказать несколько утверждений о мощностях.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_32",
      "meta": {
        "n": 32
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 32"
        ]
      },
      ". ",
      "Если ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " бесконечно, то множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A \\times \\N"
        ]
      },
      " равномощно ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ".",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВполне упорядочим множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nМы ",
  {
    "name": "label",
    "props": {
      "ref": "z+n"
    },
    "children": [
      "уже знаем"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "(см. с. 56)"
    ]
  },
  ", что всякий элемент множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " однозначно представляется в виде ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z + n"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z"
    ]
  },
  " — предельный элемент (не имеющий непосредственно предыдущего), а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  " — натуральное число.\nЭто означает, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times \\N"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — множество предельных элементов.\n(Тут есть небольшая трудность — последняя группа элементов конечна, если в множестве есть наибольший элемент.\nНо мы уже знаем, что добавление конечного или счётного множества не меняет мощности, так что этим можно пренебречь.)\n\n\nТеперь утверждение теоремы очевидно: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times \\N"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(B \\times \\N) \\times \\N"
    ]
  },
  ", то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times (\\N \\times \\N)"
    ]
  },
  " и тем самым ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times \\N"
    ]
  },
  " (произведение счётных множеств счётно), то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nПо ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_<>="
    },
    "children": [
      "теореме Кантора–Бернштейна"
    ]
  },
  " отсюда следует, что промежуточные мощности (в частности, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| + |A|"
    ]
  },
  ", а также любое произведение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и конечного множества) совпадают с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A|"
    ]
  },
  ".\nЕщё одно следствие полезно выделить:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_33",
      "meta": {
        "n": 33
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 33"
        ]
      },
      ". ",
      "Сумма двух бесконечных мощностей равна их максимуму.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПрежде всего напомним, что любые две мощности сравнимы (",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set=subset"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_set=subset",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ").\nПусть, скажем, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| \\leqslant |B|"
    ]
  },
  ".\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|B| \\leqslant |A| + |B| \\leqslant |B| + |B| \\leqslant |B| \\times \\alef_0 = |B|"
    ]
  },
  "\n(последнее неравенство — утверждение предыдущей теоремы).\nОстаётся воспользоваться ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_<>="
    },
    "children": [
      "теоремой Кантора–Бернштейна"
    ]
  },
  " и заключить, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|B| = |A + B|"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nТеперь можно доказать более сильное утверждение.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_34",
      "meta": {
        "n": 34
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 34"
        ]
      },
      ". ",
      "Если ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " бесконечно, то ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A \\times A"
        ]
      },
      " равномощно ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ".",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nЗаметим, что для счётного множества (как, впрочем, и для континуума — но это сейчас не важно) мы это уже знаем.\nПоэтому в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " есть подмножество, равномощное своему квадрату.\n\n\nРассмотрим семейство всех таких подмножеств вместе с соответствующими биекциями.\nЭлементами этого семейства будут пары ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang B, f \\rang"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: B \\to B \\times B"
    ]
  },
  " — взаимно однозначное соответствие.\nВведём на этом семействе частичный порядок: ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang B_1, f_1 \\rang \\leqslant \\lang B_2, f_2 \\rang"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_1 \\sub B_2"
    ]
  },
  " и ограничение отображения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_2"
    ]
  },
  " на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_1"
    ]
  },
  " совпадает с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_1"
    ]
  },
  " (",
  {
    "name": "label",
    "props": {
      "ref": "img_6"
    },
    "children": [
      "рис. 6"
    ]
  },
  ").\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "img_6"
    },
    "children": [
      "\n",
      {
        "name": "image",
        "props": {
          "src": "/data/books/data/vereshagin-shen-sets/2/9/img6.svg",
          "height": 0.5
        },
        "children": [
          "\nРис. 6. Отображение ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f_1"
            ]
          },
          " — взаимно однозначное соответствие между малым квадратом и его стороной;\n",
          {
            "name": "math",
            "props": {},
            "children": [
              "f_2"
            ]
          },
          " добавляет к нему взаимно однозначное соответствие между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B_2 \\setminus B_1"
            ]
          },
          " и «уголком» ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(B_2 \\times B_2) \\setminus (B_1 \\times B_1)"
            ]
          },
          ".\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n\nТеперь применим ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_zorns-lemma"
    },
    "children": [
      "лемму Цорна"
    ]
  },
  ".\nДля этого нужно убедиться, что любое линейно упорядоченное (в смысле описанного порядка) множество пар указанного вида имеет верхнюю границу.\nВ самом деле, объединим все первые компоненты этих пар; пусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — их объединение.\nКак обычно, согласованность отображений (гарантируемая определением порядка) позволяет соединить отображения в одно.\nЭто отображение (назовём его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ") отображает ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times B"
    ]
  },
  ".\nОно будет инъекцией: значения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(b')"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(b'')"
    ]
  },
  " при различных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b''"
    ]
  },
  " различны\n(возьмём большее из множеств, которым принадлежат ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b''"
    ]
  },
  "; на нём ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " является инъекцией по предположению).\nС другой стороны, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " является сюръекцией: для любой пары ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang b', b'' \\rang \\in B \\times B"
    ]
  },
  " возьмём множества, из которых произошли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b''"
    ]
  },
  ", выберем из них большее и вспомним, что мы имели взаимно однозначное соответствие между ним и его квадратом.\n\n\nПо лемме Цорна в нашем частично упорядоченном множестве существует максимальный элемент.\nПусть этот элемент есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang B, f \\rang"
    ]
  },
  ".\nМы знаем, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " есть взаимно однозначное соответствие между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times B"
    ]
  },
  " и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|B| = |B| \\times |B|"
    ]
  },
  ".\nТеперь есть две возможности.\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times B"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times A"
    ]
  },
  " и всё доказано.\nОсталось рассмотреть случай, когда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " не равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", то есть имеет меньшую мощность (большей оно иметь не может, будучи подмножеством).\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  " — оставшаяся часть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", то есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\setminus B"
    ]
  },
  ".\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| = |B| + |C| = \\max(|B|, |C|)"
    ]
  },
  ", следовательно, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  " равномощно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и больше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " по мощности.\nВозьмём в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  " часть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C'"
    ]
  },
  ", равномощную ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", и положим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B' = B + C'"
    ]
  },
  " (",
  {
    "name": "label",
    "props": {
      "ref": "img_7"
    },
    "children": [
      "рис. 7"
    ]
  },
  ").\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "img_7"
    },
    "children": [
      "\n",
      {
        "name": "image",
        "props": {
          "src": "/data/books/data/vereshagin-shen-sets/2/9/img7.svg",
          "height": 0.5
        },
        "children": [
          "\nРис. 7. Продолжение соответствия с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B' = B + C'"
            ]
          },
          ".\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n\nОбе части множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B'"
    ]
  },
  " равномощны ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nПоэтому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B' \\times B'"
    ]
  },
  " разбивается на 4 части, каждая из которых равномощна ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times B"
    ]
  },
  ", и, следовательно, равномощна ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "\n(напомним, что у нас есть взаимно однозначное соответствие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\times B"
    ]
  },
  ").\nСоответствие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " можно продолжить до соответствия ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f'"
    ]
  },
  " между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B' \\times B'"
    ]
  },
  ", дополнив его соответствием между ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C'"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "(B' \\times B') \\setminus (B \\times B)"
    ]
  },
  "\n(эта разность состоит из трёх множеств, равномощных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", так что равномощна ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ").\nВ итоге мы получаем бо´льшую пару ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang B', f' \\rang"
    ]
  },
  ", что противоречит утверждению леммы Цорна о максимальности.\nТаким образом, этот случай невозможен.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nВыведем теперь некоторые следствия из доказанного утверждения.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_35",
      "meta": {
        "n": 35
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 35"
        ]
      },
      ". ",
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ") Произведение двух бесконечных мощностей равно большей из них.\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ") Если множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " бесконечно, то множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A^n"
        ]
      },
      " всех последовательностей длины ",
      {
        "name": "math",
        "props": {},
        "children": [
          "n > 0"
        ]
      },
      ", составленных из элементов ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ", равномощно ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ".\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "в"
        ]
      },
      ") Если множество ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " бесконечно, то множество всех конечных последовательностей, составленных из элементов ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ", равномощно ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      ".\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПервое утверждение доказывается просто: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| \\leqslant |B|"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|B| \\leqslant |A| \\times |B| \\leqslant |B| \\times |B| = |B|"
    ]
  },
  ".\n\n\nВторое утверждение легко доказывается индукцией по ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  ": если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A^n| = |A|"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A^{n+1}| = |A^n| \\times |A| = |A| \\times |A| = |A|"
    ]
  },
  ".\n\n\nТретье тоже просто: множество конечных последовательностей есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1 + A + A^2 + A^3 + \\ldots"
    ]
  },
  ";\nкаждая из частей (кроме первой, которой можно пренебречь) равномощна ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " (по доказанному), и потому всё вместе есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "|A| \\times \\alef_0 = |A|"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nЗаметим, что из последнего утверждения теоремы вытекает, что семейство всех конечных подмножеств бесконечного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " имеет ту же мощность, что и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  "\n(подмножеств не больше, чем конечных последовательностей и не меньше, чем одноэлементных подмножеств).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_128",
      "meta": {
        "n": 128
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "128"
            ]
          },
          ". ",
          "Пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " бесконечно. Докажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "|A^A| = |2^A|"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_129",
      "meta": {
        "n": 129
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "129"
            ]
          },
          ". ",
          "\nРассмотрим мощность ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha = \\alef_0 + 2^{\\alef_0} + 2^{(2^{\\alef_0})} + \\ldots"
            ]
          },
          " (счётная сумма).\nПокажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " — минимальная мощность, которая больше мощностей множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\N, P(\\N), P(P(\\N)), \\dots"
            ]
          },
          "\nПокажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha^{\\alef_0} = 2^{\\alpha} > \\alpha"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nТеперь мы можем доказать упоминавшееся ранее утверждение о равномощности базисов.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_inf-basis",
      "meta": {
        "n": 36
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 36"
        ]
      },
      ". ",
      "Любые два базиса в бесконечномерном векторном пространстве имеют одинаковую мощность.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nПусть даны два базиса — первый и второй.\nДля каждого вектора из первого базиса фиксируем какой-либо способ выразить его через векторы второго базиса.\nВ этом выражении участвует конечное множество векторов второго базиса.\nТаким образом, есть некоторая функция, которая каждому вектору первого базиса ставит в соответствие некоторое конечное множество векторов второго.\nКак мы только что видели, возможных значений этой функции столько же, сколько элементов во втором базисе.\nКроме того, прообраз каждого значения состоит из векторов первого базиса, выражающихся через данный (конечный) набор векторов второго, и потому конечен.\nВыходит, что первый базис разбит на группы, каждая группа конечна, а всего групп не больше, чем векторов во втором базисе.\nПоэтому мощность первого базиса не превосходит мощности второго, умноженной на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_0"
    ]
  },
  "\n(от чего, как мы знаем, мощность бесконечного множества не меняется).\nОсталось провести симметричное рассуждение и сослаться на ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_<>="
    },
    "children": [
      "теорему Кантора–Бернштейна"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_10",
      "meta": {
        "n": 10,
        "longN": "2.10"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.10"
            ]
          },
          ". ",
          "Ординалы",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nКак мы уже говорили, ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "ординалом"
    ]
  },
  " называется порядковый тип вполне упорядоченного множества, то есть класс всех изоморфных ему упорядоченных множеств (естественно, они будут вполне упорядоченными).\n\n\nНа ординалах естественно определяется линейный порядок.\nЧтобы сравнить два ординала ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ", возьмём их представители ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nПрименим ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_set-size"
    },
    "children": [
      "теорему ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_set-size",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " и посмотрим, какой из трёх случаев\n(",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " изоморфно начальному отрезку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", отличному от всего ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "; множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфны; ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфно начальному отрезку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", отличному от всего ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ") имеет место.\nВ первом случае ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha < \\beta"
    ]
  },
  ", во втором ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha = \\beta"
    ]
  },
  ", в третьем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha > \\beta"
    ]
  },
  ".\n\n\nМы отвлекаемся от ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_01..."
    },
    "children": [
      "трудностей"
    ]
  },
  ", связанных с основаниями теории множеств; как формально можно оправдать наши рассуждения, мы ещё обсудим.\nПока что отметим некоторые свойства ординалов.\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nМы определили на ординалах линейный порядок.\nЭтот порядок будет полным: любое непустое семейство ординалов имеет наименьший элемент (",
          {
            "name": "label",
            "props": {
              "ref": "theorem_min-set"
            },
            "children": [
              "теорема ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_min-set",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          "; разница лишь в том, что мы не употребляли там слова «ординал», а говорили о представителях).\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " — некоторый ординал.\nРассмотрим начальный отрезок ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, \\alpha)"
            ]
          },
          " в классе ординалов (образованный всеми ординалами, меньшими ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " в смысле указанного порядка).\nЭтот отрезок упорядочен по типу ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " (то есть изоморфен представителям ординала ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          ").\nВ самом деле, пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " — один из представителей ординала ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          ".\nОрдиналы, меньшие ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          ", соответствуют собственным (не совпадающим с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ") начальным отрезкам множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\nТакие отрезки имеют вид ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, a)"
            ]
          },
          " и тем самым находятся во взаимно однозначном соответствии с элементами множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          ".\n(Легко проверить, что это соответствие сохраняет порядок.)\n\n\nСказанное можно переформулировать так: каждый ординал упорядочен как множество меньших ординалов.\n(В одном из формальных построений теории ординалов каждый ординал равен множеству всех меньших ординалов.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОрдинал называется ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "непредельным"
            ]
          },
          ", если существует непосредственно предшествующий ему (в смысле указанного порядка) ординал.\nЕсли такого нет, ординал называют ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "предельным"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЛюбое ограниченное семейство ординалов имеет точную верхнюю грань\n(наименьший ординал, больший или равный всем ординалам семейства).\nВ самом деле, возьмём какой-то ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          ", являющийся верхней границей.\nТогда все ординалы семейства изоморфны начальным отрезкам множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", представляющего ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          ".\nЕсли среди этих отрезков есть само ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          " будет точной верхней гранью (и наибольшим элементом семейства).\nЕсли нет, то эти отрезки имеют вид ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, b)"
            ]
          },
          " для различных элементов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b \\in B"
            ]
          },
          ".\nРассмотрим множество ",
          {
            "name": "math",
            "props": {},
            "children": [
              "S"
            ]
          },
          " всех таких элементов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b"
            ]
          },
          ".\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "S"
            ]
          },
          " не ограничено в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          " будет точной верхней гранью.\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "S"
            ]
          },
          " ограничено, то оно имеет точную верхнюю грань ",
          {
            "name": "math",
            "props": {},
            "children": [
              "s"
            ]
          },
          ", и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, s)"
            ]
          },
          " будет точной верхней гранью семейства.\n"
        ]
      },
      "\n"
    ]
  },
  "\nМожно сказать, что семейство ординалов — это как бы универсальное вполне упорядоченное семейство;\nлюбое вполне упорядоченное множество изоморфно некоторому начальному отрезку этого семейства.\nПоэтому мы немедленно придём к противоречию, если захотим рассмотреть множество всех ординалов (ведь для всякого вполне упорядоченного множества есть ещё большее — добавим к нему новый элемент, больший всех предыдущих).\nЭтот парадокс называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "парадоксом ",
      {
        "name": "label",
        "props": {
          "ref": "name_forti"
        },
        "children": [
          "Бурали-Форти"
        ]
      },
      ""
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_130",
      "meta": {
        "n": 130
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "130"
            ]
          },
          ". ",
          "Докажите, что точная верхняя грань счётного числа счётных ординалов счётна.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nКак же рассуждать об ординалах, не впадая в противоречия?\nВ принципе можно заменять утверждения об ординалах утверждениями о их представителях и воспринимать упоминания ординалов как «вольность речи».\nДругой подход (предложенный ",
  {
    "name": "label",
    "props": {
      "ref": "name_neumann"
    },
    "children": [
      "фон Нейманом"
    ]
  },
  ") применяется при аксиоматическом построении теории множеств, и состоит он примерно в следующем: мы объявляем каждый ординал равным множеству всех меньших ординалов.\nТогда минимальный ординал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  " (порядковый тип пустого множества) будет пустым множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varnothing"
    ]
  },
  ", следующий за ним ординал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "1"
    ]
  },
  " (порядковый тип одноэлементного множества) будет ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{0\\} = \\{",
      "\\varnothing",
      "\\}"
    ]
  },
  ", затем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2 = \\{0, 1\\} = \\{",
      "\\varnothing",
      ", \\{",
      "\\varnothing",
      "\\}\\}, 3 = \\{0, 1, 2\\} = \\{",
      "\\varnothing",
      ", \\{",
      "\\varnothing",
      "\\}, \\{",
      "\\varnothing",
      ", \\{",
      "\\varnothing",
      "\\}\\}, 4 = \\{0, 1, 2, 3\\}"
    ]
  },
  " и т.д.\nЗа ними следует ординал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega"
    ]
  },
  " (порядковый тип множества натуральных чисел), равный ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{0, 1, 2, 3, \\dots \\}"
    ]
  },
  ", потом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega + 1 = \\{0, 1, 2, 3, \\dots , \\omega\\}"
    ]
  },
  ", потом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega + 2 = \\{0, 1, 2, 3, \\dots , \\omega, \\omega + 1\\}"
    ]
  },
  " и т.д.\n\n\nМы не будем говорить подробно об аксиоматической теории множеств Цермело–Френкеля, но два обстоятельства следует иметь в виду.\nВо-первых, в ней нет никаких объектов, кроме множеств, и есть ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "аксиома экстенсиональности"
    ]
  },
  " (или ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "объёмности"
    ]
  },
  "), которая говорит, что два объекта, содержащие одни и те же элементы, равны.\nПоэтому существует лишь один объект, не содержащий элементов (пустое множество).\nВо-вторых, в ней есть ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "аксиома фундирования"
    ]
  },
  ", которая говорит, что отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\in"
    ]
  },
  " фундировано: во всяком множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " есть элемент, являющийся ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\in"
    ]
  },
  "-минимальным, то есть элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X \\cap x = ",
      "\\varnothing",
      ""
    ]
  },
  ".\nОтсюда следует, что никакое множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " не может быть своим элементом (иначе для множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\{x\\}"
    ]
  },
  " нарушалась бы аксиома фундирования).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_131",
      "meta": {
        "n": 131
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "131"
            ]
          },
          ". ",
          "Выведите из аксиомы фундирования, что не существует множеств ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x, y, z"
            ]
          },
          ", для которых ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\in y \\in z \\in x"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nФилософски настроенный математик обосновал бы аксиому фундирования так: множества строятся из ранее построенных множеств, начиная с пустого, и поэтому возможна индукция по построению\n(доказывая какое-либо свойство множеств, можно рассуждать индуктивно и предполагать, что оно верно для всех его элементов).\n\n\nТеперь можно определить ординалы так.\nБудем говорить, что множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "транзитивно"
    ]
  },
  ", если всякий элемент множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " является подмножеством множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", то есть если из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z \\in y \\in x"
    ]
  },
  " следует ",
  {
    "name": "math",
    "props": {},
    "children": [
      "z \\in x"
    ]
  },
  ".\nНазовём ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "ординалом"
    ]
  },
  " транзитивное множество, всякий элемент которого транзитивен.\nЭто требование гарантирует, что на элементах любого ординала отношение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\in"
    ]
  },
  " является (строгим) частичным порядком.\n\n\nАксиома фундирования гарантирует, что частичный порядок ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\in"
    ]
  },
  " на любом ординале является фундированным.\nПосле этого по индукции можно доказать, что он является линейным (и, следовательно, полным).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_132",
      "meta": {
        "n": 132
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "132"
            ]
          },
          ". ",
          "\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "а"
            ]
          },
          ") Используя определение ординала как транзитивного множества с транзитивными элементами, докажите, что элемент ординала есть ординал.\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "б"
            ]
          },
          ") Пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " — ординал (в смысле данного нами определения).\nДокажите, что отношение ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\in"
            ]
          },
          " на нём является частичным порядком.\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "в"
            ]
          },
          ") Докажите, что для любых элементов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a, b \\in \\alpha"
            ]
          },
          " верно ровно одно из трёх соотношений: либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a \\in b"
            ]
          },
          ", либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a = b"
            ]
          },
          ", либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b \\in a"
            ]
          },
          ".\n(Указание: используйте двойную индукцию по фундированному отношению ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\in"
            ]
          },
          " на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          ", а также аксиому экстенсиональности.)\n(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "г"
            ]
          },
          ") Докажите, что один ординал изоморфен собственному начальному отрезку другого тогда и только тогда, когда является его элементом.\n(Таким образом, отношение ",
          {
            "name": "math",
            "props": {},
            "children": [
              "<"
            ]
          },
          " на ординалах как упорядоченных множествах совпадает с отношением принадлежности.)\nДокажите, что каждый ординал является множеством всех меньших его ординалов.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nЗаметим ещё, что если каждый ординал есть множество всех меньших его ординалов, то точная верхняя грань множества ординалов есть их объединение.\n\n\nМы не будем подробно развивать этот подход и по-прежнему будем наивно представлять себе ординалы как порядковые типы вполне упорядоченных множеств.\n\n\nПрежде чем перейти к сложению и умножению ординалов, отметим такое свойство (уже упомянутое в ",
  {
    "name": "label",
    "props": {
      "ref": "problem_subset-init"
    },
    "children": [
      "задаче ",
      {
        "name": "use",
        "props": {
          "ref": "problem_subset-init",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  "):\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_subset-ordinal",
      "meta": {
        "n": 37
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 37"
        ]
      },
      ". ",
      "\nПусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " — подмножество вполне упорядоченного множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ".\nТогда порядковый тип множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "A"
        ]
      },
      " не превосходит порядкового типа множества ",
      {
        "name": "math",
        "props": {},
        "children": [
          "B"
        ]
      },
      ".\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nОтметим сразу же, что равенство возможно, даже если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " является собственным подмножеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\nНапример, чётные натуральные числа имеют тот же порядковый тип ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega"
    ]
  },
  ", что и все натуральные числа.\n\n\nРассуждая от противного, предположим, что порядковый тип множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " больше.\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " изоморфно некоторому начальному отрезку множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", не совпадающему со всем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_0"
    ]
  },
  " — верхняя граница (в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ") этого отрезка, а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f: B \\to A"
    ]
  },
  " — соответствующий изоморфизм.\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " строго возрастает и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(b) \\geqslant b"
    ]
  },
  " для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  " (",
  {
    "name": "label",
    "props": {
      "ref": "theorem_f(x)>x"
    },
    "children": [
      "теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_f(x)>x",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  ").\nВ частности, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(a_0) \\geqslant a_0"
    ]
  },
  ", но по предположению любое значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(b)"
    ]
  },
  " меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_0"
    ]
  },
  " — противоречие.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_11",
      "meta": {
        "n": 11,
        "longN": "2.11"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.11"
            ]
          },
          ". ",
          "Арифметика ординалов",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nМы определили сумму и произведение линейно упорядоченных множеств в разделе ",
  {
    "name": "link",
    "props": {
      "ref": "paragraph_equivalence-order"
    },
    "children": [
      "",
      {
        "name": "use",
        "props": {
          "ref": "paragraph_equivalence-order",
          "path": "longN"
        },
        "children": []
      },
      ""
    ]
  },
  ".\n(Напомним, что в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A + B"
    ]
  },
  " элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " предшествуют элементам ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", а в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times B"
    ]
  },
  " мы сначала сравниваем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "-компоненты пар, а в случае их равенства — ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  "-компоненты.)\n\n\nЛегко проверить следующие свойства сложения:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nСложение ассоциативно: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + (\\beta + \\gamma) = (\\alpha + \\beta) + \\gamma"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nСложение не коммутативно: например, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "1 + \\omega = \\omega"
            ]
          },
          ", но ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\omega + 1 \\not = \\omega"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОчевидно, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + 0 = 0 + \\alpha = \\alpha"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nСумма возрастает при росте второго аргумента: если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta_1 < \\beta_2"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + \\beta_1 < \\alpha + \\beta_2"
            ]
          },
          ".\n(В самом деле, пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta_1"
            ]
          },
          " изоморфно начальному отрезку в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta_2"
            ]
          },
          ", отличному от всего ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta_2"
            ]
          },
          ".\nДобавим к этому изоморфизму тождественное отображение на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " и получим изоморфизм между ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + \\beta_1"
            ]
          },
          " и начальным отрезком в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + \\beta_2"
            ]
          },
          ", отличным от ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + \\beta_2"
            ]
          },
          ".)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nСумма неубывает при росте первого аргумента: если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha_1 < \\alpha_2"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha_1 + \\beta \\leqslant \\alpha_2 + \\beta"
            ]
          },
          ".\n(В самом деле, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha_1 + \\beta"
            ]
          },
          " изоморфно подмножеству в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha_2 +\\beta"
            ]
          },
          ".\nЭто подмножество не является начальным отрезком, но мы можем воспользоваться ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_subset-ordinal"
            },
            "children": [
              "теоремой ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_subset-ordinal",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          ".)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОпределение суммы согласовано с обозначением ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + 1"
            ]
          },
          " для следующего за ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " ординала.\n(Здесь ",
          {
            "name": "math",
            "props": {},
            "children": [
              "1"
            ]
          },
          " — порядковый тип одноэлементного множества.)\nСледующим за ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + 1"
            ]
          },
          " ординалом будет ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(\\alpha + 1) + 1 = \\alpha + (1 + 1) = \\alpha + 2"
            ]
          },
          " и т.д.\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha \\geqslant \\beta"
            ]
          },
          ", то существует единственный ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\gamma"
            ]
          },
          ", для которого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta + \\gamma = \\alpha"
            ]
          },
          ".\n(В самом деле, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          " изоморфно начальному отрезку в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          "; оставшаяся часть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " и будет искомым ординалом ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\gamma"
            ]
          },
          ".\nЕдинственность следует из монотонности сложения по второму аргументу.)\nЗаметим, что эту операцию можно называть «вычитанием слева».\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n«Вычитание справа», напротив, возможно не всегда.\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " — некоторый ординал.\nТогда уравнение ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta + 1 = \\alpha"
            ]
          },
          " (относительно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          ") имеет решение тогда и только тогда, когда ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " — непредельный ординал, (т.е. когда ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " имеет наибольший элемент).\n"
        ]
      },
      "\n"
    ]
  },
  "\nОпределение суммы двух ординалов в силу ассоциативности можно распространить на любое конечное число ординалов.\nМожно определить и сумму ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_1 + \\alpha_2 + \\dots"
    ]
  },
  " счётной последовательности ординалов (элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_i"
    ]
  },
  " предшествуют элементам ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_j"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i < j"
    ]
  },
  "; внутри каждого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_i"
    ]
  },
  " порядок прежний).\nКак легко проверить, это множество действительно будет вполне упорядоченным: чтобы найти минимальный элемент в его подмножестве, рассмотрим компоненты, которые это подмножество задевает, выберем из них компоненту с наименьшим номером и воспользуемся её полной упорядоченностью.\n\n\nВ этом построении можно заменить натуральные числа на элементы произвольного вполне упорядоченного множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  " и определить сумму ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sum A_i"
    ]
  },
  " семейства вполне упорядоченных множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  ", индексированного элементами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "I"
    ]
  },
  ", как порядковый тип множества всех пар вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a, i \\rang"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a \\in A_i"
    ]
  },
  ".\nПри сравнении пар сравниваются вторые компоненты, а в случае равенства и первые (в соответствующем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  ").\nЕсли все ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_i"
    ]
  },
  " изоморфны одному и тому же множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", получаем уже известное нам определение произведения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A \\times I"
    ]
  },
  ".\n\n\nТеперь перейдём к умножению ординалов.\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nУмножение ассоциативно: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(\\alpha\\beta)\\gamma = \\alpha(\\beta\\gamma)"
            ]
          },
          ".\n(В самом деле, в обоих случаях по существу получается множество троек; тройки сравниваются справа налево, пока не обнаружится различие.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nУмножение не коммутативно: например, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2 \\cdot \\omega = \\omega"
            ]
          },
          ", в то время как ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\omega \\cdot 2 \\not = \\omega"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nОчевидно, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha \\cdot 0 = 0 \\cdot \\alpha = 0"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha \\cdot 1 = 1 \\cdot \\alpha = \\alpha"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nВыполняется одно из свойств дистрибутивности: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha(\\beta + \\gamma) = \\alpha\\beta + \\alpha\\gamma"
            ]
          },
          " (непосредственно следует из определения).\nСимметричное свойство выполнено не всегда: ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(1 + 1) \\cdot \\omega = \\omega \\not= \\omega + \\omega"
            ]
          },
          ".\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПроизведение строго возрастает при увеличении второго множителя, если первый не равен ",
          {
            "name": "math",
            "props": {},
            "children": [
              "0"
            ]
          },
          ".\n(Для разнообразия выведем это из ранее доказанных свойств: если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta_2 > \\beta_1"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta_2 = \\beta_1 + \\delta"
            ]
          },
          ", так что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\beta_2 = \\alpha(\\beta_1 + \\delta) = \\alpha\\beta_1 + \\alpha\\delta > \\alpha\\beta_1"
            ]
          },
          ".)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nПроизведение не убывает при возрастании первого множителя.\n(В самом деле, если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha_1 < \\alpha_2"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha_1\\beta"
            ]
          },
          " изоморфно подмножеству ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha_2\\beta"
            ]
          },
          ".\nЭто подмножество не является начальным отрезком, но можно сослаться на ",
          {
            "name": "label",
            "props": {
              "ref": "theorem_subset-ordinal"
            },
            "children": [
              "теорему ",
              {
                "name": "use",
                "props": {
                  "ref": "theorem_subset-ordinal",
                  "path": "n"
                },
                "children": []
              },
              ""
            ]
          },
          ".)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "key": "ord_lin-sum"
            },
            "children": [
              "\nЛюбой ординал, меньший ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\alpha\\beta"
                ]
              },
              ", однозначно представим в виде ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\alpha\\beta' + \\alpha'"
                ]
              },
              ", где ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\beta' < \\beta"
                ]
              },
              " и ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\alpha' < \\alpha"
                ]
              },
              ".\n"
            ]
          },
          "\n\n\n(В самом деле, пусть множества ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "B"
            ]
          },
          " упорядочены по типам ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          ".\nТогда ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\times B"
            ]
          },
          " упорядочено по типу ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\beta"
            ]
          },
          ".\nВсякий ординал, меньший ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\beta"
            ]
          },
          ", есть начальный отрезок в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\times B"
            ]
          },
          ", ограниченный некоторым элементом ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\lang a, b \\rang"
            ]
          },
          ".\nНачальный отрезок ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, \\lang a, b \\rang)"
            ]
          },
          " состоит из пар, у которых второй член меньше ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b"
            ]
          },
          ", а также из пар, у которых второй член равен ",
          {
            "name": "math",
            "props": {},
            "children": [
              "b"
            ]
          },
          ", а первый меньше ",
          {
            "name": "math",
            "props": {},
            "children": [
              "a"
            ]
          },
          ".\nОтсюда следует, что этот начальный отрезок изоморфен ",
          {
            "name": "math",
            "props": {},
            "children": [
              "A \\times [0, b) + [0, a)"
            ]
          },
          ", так что остаётся положить ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta' = [0, b)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha' = [0, a)"
            ]
          },
          ".\nТеперь проверим однозначность.\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\beta' +\\alpha' = \\alpha\\beta'' +\\alpha''"
            ]
          },
          ".\nЕсли ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta' = \\beta''"
            ]
          },
          ", то можно воспользоваться однозначностью левого вычитания и получить, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha' = \\alpha''"
            ]
          },
          ".\nОстаётся проверить, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta'"
            ]
          },
          " не может быть, скажем, меньше ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta''"
            ]
          },
          ".\nВ этом случае ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta'' = \\beta' + \\delta"
            ]
          },
          ", и сокращая ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\beta'"
            ]
          },
          " слева, получим, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha' = \\alpha\\delta + \\alpha''"
            ]
          },
          ", что невозможно, так как левая часть меньше ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          ", а правая часть больше или равна ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          ".)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\nАналогичное «деление с остатком» возможно и для любых ординалов.\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha > 0"
            ]
          },
          ".\nТогда любой ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\gamma"
            ]
          },
          " можно разделить с остатком на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          ", то есть представить в виде ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\tau + \\rho"
            ]
          },
          ", где ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\rho < \\alpha"
            ]
          },
          ", и притом единственным образом.\n\n\n(В самом деле, существование следует из предыдущего утверждения, надо только взять достаточно большое ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          ", чтобы ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\beta"
            ]
          },
          " было больше ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\gamma"
            ]
          },
          ", скажем, ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta = \\gamma + 1"
            ]
          },
          ".\nЕдинственность доказывается так же, как и в предыдущем пункте.)\n"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "\n",
          {
            "name": "area",
            "props": {
              "key": "ordinal-position"
            },
            "children": [
              "Повторяя деление с остатком на ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\alpha > 0"
                ]
              },
              ", можно построить позиционную систему счисления для ординалов: всякий ординал, меньший ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\alpha^{k+1}"
                ]
              },
              " (здесь ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "k"
                ]
              },
              " — натуральное число), можно однозначно представить в виде ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\alpha^k\\beta_k + \\alpha^{k-1}\\beta_{k-1} + \\ldots + \\alpha\\beta_1 + \\beta_0"
                ]
              },
              ", где «цифры» ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\beta_k, \\ldots , \\beta_1, \\beta_0"
                ]
              },
              " — ординалы, меньшие ",
              {
                "name": "math",
                "props": {},
                "children": [
                  "\\alpha"
                ]
              },
              "."
            ]
          },
          "\n"
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_133",
      "meta": {
        "n": 133
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "133"
            ]
          },
          ". ",
          "Для каких ординалов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "1 + \\alpha = \\alpha"
            ]
          },
          "?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_134",
      "meta": {
        "n": 134
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "134"
            ]
          },
          ". ",
          "Для каких ординалов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2 \\cdot \\alpha = \\alpha"
            ]
          },
          "?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_135",
      "meta": {
        "n": 135
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "135"
            ]
          },
          ". ",
          "Какие ординалы представимы в виде ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\omega \\cdot \\alpha"
            ]
          },
          "?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_136",
      "meta": {
        "n": 136
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "136"
            ]
          },
          ". ",
          "\nДокажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + \\beta = \\beta"
            ]
          },
          " тогда и только тогда, когда ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\omega \\leqslant \\beta"
            ]
          },
          "\n(здесь ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          " — ординалы).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_137",
      "meta": {
        "n": 137
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "137"
            ]
          },
          ". ",
          "\nДокажите, что если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha + \\beta = \\beta + \\alpha"
            ]
          },
          " для некоторых ординалов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          ", то найдётся такой ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\gamma"
            ]
          },
          " и такие натуральные числа ",
          {
            "name": "math",
            "props": {},
            "children": [
              "m"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          ", что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha = \\gamma m"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta = \\gamma n"
            ]
          },
          ".\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_138",
      "meta": {
        "n": 138
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "138"
            ]
          },
          ". ",
          "\nОпределим операцию «замены основания» с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k > 1"
            ]
          },
          " на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l > k"
            ]
          },
          ".\nЧтобы применить эту операцию к натуральному числу ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          ", надо записать ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "-ичной системе счисления, а затем прочесть эту запись в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l"
            ]
          },
          "-ичной системе.\n(Очевидно, число при этом возрастёт, если оно было больше или равно ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          ".)\nВозьмём произвольное число ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " и будет выполнять над ним такие операции: замена основания с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "2"
            ]
          },
          " на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "3"
            ]
          },
          " – вычитание единицы – замена основания с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "3"
            ]
          },
          " на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "4"
            ]
          },
          " – вычитание единицы – замена основания с ",
          {
            "name": "math",
            "props": {},
            "children": [
              "4"
            ]
          },
          " на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "5"
            ]
          },
          " – вычитание единицы – ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\dots"
            ]
          },
          "\nДокажите, что рано или поздно мы получим нуль и вычесть единицу не удастся.\n(Указание: замените все основания на ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\omega"
            ]
          },
          "; получится убывающая последовательность ординалов.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_12",
      "meta": {
        "n": 12,
        "longN": "2.12"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.12"
            ]
          },
          ". ",
          "Индуктивные определения и степени",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nМы определили сложение и умножение ординалов с помощью явных конструкций порядка на соответствующих множествах.\nВместо этого можно было бы их определить индуктивно.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_38",
      "meta": {
        "n": 38
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 38"
        ]
      },
      ". ",
      "\nСложение ординалов обладает следующими свойствами:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{aligned}\n\\alpha + 0 &= \\alpha; \\\\\n\\alpha + (\\beta + 1) &= (\\alpha + \\beta) + 1; \\\\\n\\alpha + \\gamma &= \\sup\\{\\alpha + \\beta \\ | \\ \\beta < \\gamma\\} \\ \\text{для предельного} \\ \\gamma \\not= 0.\n\\end{aligned}\n"
        ]
      },
      "\nЭти свойства однозначно определяют операцию сложения.\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nДва первых свойства очевидны; проверим третье.\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\gamma"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha + \\beta < \\alpha + \\gamma"
    ]
  },
  ", так что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha + \\gamma"
    ]
  },
  " будет верхней границей всех сумм вида ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha + \\beta"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\gamma"
    ]
  },
  ".\nНадо проверить, что эта граница точная.\nПусть некоторый ординал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau"
    ]
  },
  " меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha + \\gamma"
    ]
  },
  ".\nУбедимся, что он меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha + \\beta"
    ]
  },
  " для некоторого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\gamma"
    ]
  },
  ".\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau < \\alpha"
    ]
  },
  ", всё очевидно.\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau > \\alpha"
    ]
  },
  ", представим его в виде ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau = \\alpha + \\sigma"
    ]
  },
  ".\nТогда ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha + \\sigma < \\alpha + \\gamma"
    ]
  },
  " и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma < \\gamma"
    ]
  },
  ".\nПоскольку ординал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma"
    ]
  },
  " предельный, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma + 1"
    ]
  },
  " также меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma"
    ]
  },
  " и остаётся положить ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta = \\sigma + 1"
    ]
  },
  ".\n\n\nУказанные свойства однозначно определяют операцию сложения, так как представляют собой рекурсивное определение по ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  "\n(если есть две операции сложения, обладающие этими свойствами, возьмём минимальное ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ", для которого они различаются и т. д.).\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nАналогично можно определить и умножение:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_39",
      "meta": {
        "n": 39
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 39"
        ]
      },
      ". ",
      "\nУмножение ординалов обладает следующими свойствами:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{aligned}\n\\alpha 0 &= 0; \\\\\n\\alpha(\\beta + 1) &= \\alpha\\beta + \\alpha; \\\\\n\\alpha\\gamma &= \\sup\\{\\alpha\\beta \\ | \\ \\beta < \\gamma\\} \\ \\text{для предельного} \\ \\gamma \\not= 0.\n\\end{aligned}\n"
        ]
      },
      "\nЭти свойства однозначно определяют операцию умножения.\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nДоказательство аналогично, нужно только проверить, что если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau < \\alpha\\gamma"
    ]
  },
  " для предельного ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau < \\alpha\\beta"
    ]
  },
  " для некоторого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\gamma"
    ]
  },
  ".\nКак мы видели ",
  {
    "name": "label",
    "props": {
      "ref": "ord_lin-sum"
    },
    "children": [
      "ранее"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "на с. 89"
    ]
  },
  ", ординал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau"
    ]
  },
  " имеет вид ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\tau = \\alpha\\gamma' + \\alpha'"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma' < \\gamma"
    ]
  },
  ";\nдостаточно положить ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta = \\gamma' + 1"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nВозникает естественное желание определить операцию возведения в степень.\nМы уже по существу определили возведение в целую положительную степень\n(",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^n"
    ]
  },
  " есть произведение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  " сомножителей, равных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ").\nДругими словами, если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " упорядочено по типу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ", то множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^n"
    ]
  },
  " последовательностей длины ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  " с элементами из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " с обратным лексикографическим порядком (сравнение справа налево) упорядочено по типу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^n"
    ]
  },
  ".\n\n\nСледующий шаг — определить ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^{\\omega}"
    ]
  },
  ".\nПервая идея, приходящая в голову — взять множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^{\\N}"
    ]
  },
  " бесконечных последовательностей и определить на нём полный порядок.\nНо как его ввести — неясно.\nПоэтому можно попробовать определить ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "возведение в степень"
    ]
  },
  " индуктивно с помощью следующих соотношений:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{aligned}\n\\alpha^0 &= 1; \\\\\n\\alpha^{\\beta + 1} &= \\alpha^{\\beta} \\cdot \\alpha; \\\\\n\\alpha^{\\gamma} &= \\sup\\{\\alpha^{\\beta} \\ | \\ \\beta < \\gamma\\} \\ \\text{для предельного} \\ \\gamma \\not= 0.\n\\end{aligned}\n"
    ]
  },
  "\n",
  {
    "name": "label",
    "props": {
      "ref": "theorem_transfinite-recursion"
    },
    "children": [
      "Теорема ",
      {
        "name": "use",
        "props": {
          "ref": "theorem_transfinite-recursion",
          "path": "n"
        },
        "children": []
      },
      ""
    ]
  },
  " (о трансфинитной рекурсии) гарантирует, что эти соотношения однозначно определяют некоторую операцию над ординалами, которая и называется возведением в степень.\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Замечание"
    ]
  },
  ". Тут опять мы подходим к опасной границе парадоксов и вынуждены выражаться уклончиво.\nНа самом деле теорема о трансфинитной рекурсии говорила об определении функции на вполне упорядоченном множестве, а ординалы не образуют множества — их слишком много.\nКроме того, в ней шла речь о функциях со значениями в некотором заданном множестве, которого здесь тоже нет.\nПодобные индуктивные определения можно корректно обосновать в теории множеств с использованием так называемой ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "аксиомы подстановки"
    ]
  },
  ", но мы об этом говорить не будем.\nВместо этого мы дадим явное описание возведения в степень, свободное от этих проблем.\n\n\nЧтобы понять смысл возведения в степень, посмотрим, как выглядит ординал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^{\\omega}"
    ]
  },
  " (для некоторого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ").\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " — множество, упорядоченное по типу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ".\nОрдинал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^{\\omega}"
    ]
  },
  " по определению есть точная верхняя грань ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^n"
    ]
  },
  " для натуральных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  ".\nОрдинал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^n"
    ]
  },
  " есть порядковый тип множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^n"
    ]
  },
  ", упорядоченного в обратном лексикографическом порядке.\nЧтобы найти точную верхнюю грань, представим множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^n"
    ]
  },
  " как начальные отрезки друг друга.\nНапример, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^2"
    ]
  },
  " состоит из пар ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a_1, a_2 \\rang"
    ]
  },
  " и отождествляется с начальным отрезком в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^3"
    ]
  },
  ", состоящим из троек ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\lang a_1, a_2, 0 \\rang"
    ]
  },
  ".\n(Здесь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  " — наименьший элемент в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ".)\nТеперь видно, что все множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^n"
    ]
  },
  " можно рассматривать как начальные отрезки множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^{\\infty}"
    ]
  },
  ", состоящего из бесконечных последовательностей ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_0, a_1, \\dots"
    ]
  },
  ", элементы которых принадлежат ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и в которых лишь конечное число членов отлично от нуля.\n(Последнее требование делает корректным определение обратного лексикографического порядка — мы находим самую правую позицию, в которой последовательности различаются, и сравниваем их значения в этой позиции.)\nВ объединении эти начальные отрезки дают всё ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^{\\infty}"
    ]
  },
  ", так что это множество с описанным порядком имеет тип ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^\\omega"
    ]
  },
  ".\n\n\nАналогичным образом можно описать возведение в произвольную степень.\n\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " — вполне упорядоченные множества, имеющие порядковые типы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ".\nРассмотрим множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  ", состоящее из отображений ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ", имеющих «конечный носитель»\n(равных минимальному элементу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " всюду, за исключением конечного множества).\nВведём на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " порядок: если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_1 \\not= f_2"
    ]
  },
  ", выберем наибольший элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_1(b) \\not= f_2(b)"
    ]
  },
  " и сравним ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_1(b)"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_2(b)"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_40",
      "meta": {
        "n": 40
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 40"
        ]
      },
      ". ",
      "\nУказанное правило задаёт полный порядок на множестве ",
      {
        "name": "math",
        "props": {},
        "children": [
          "[B \\to A]"
        ]
      },
      " и порядковый тип этого множества есть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha^{\\beta}"
        ]
      },
      ".\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nНам надо проверить, что указанный порядок является полным и что выполнены требования индуктивного определения степени.\n\n\nНазовём ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "носителем"
    ]
  },
  " элемента ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f \\in [B \\to A]"
    ]
  },
  " множество тех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b \\in B"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f(b) > 0"
    ]
  },
  "\n(здесь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  " обозначает наименьший элемент множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  ").\nНазовём ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "рангом"
    ]
  },
  " функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  " наибольший элемент носителя\n(по определению носитель конечен, так что наибольший элемент существует).\nРанг определён для всех функций, кроме тождественно нулевой, которая является минимальным элементом множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  ".\nЧем больше ранг функции, тем больше сама функция в смысле введённого нами порядка.\n\n\nПусть порядок на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " не является полным и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_0 > f_1 > f_2 > \\dots"
    ]
  },
  " — убывающая последовательность элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  ".\nВсе элементы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_i"
    ]
  },
  " отличны от ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  "; рассмотрим их ранги.\nЭти ранги образуют невозрастающую последовательность, поэтому начиная с некоторого места стабилизируются (множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " вполне упорядочено).\nОтбросим начальный отрезок и будем считать, что с самого начала ранги всех элементов убывающей последовательности одинаковы и равны некоторому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  ".\nВ соответствии с определением, значения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_0(b), f_1(b), \\ldots"
    ]
  },
  " образуют невозрастающую последовательность, поэтому начиная с некоторого места стабилизируются.\nОтбросив начальный отрезок, будем считать, что все ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_i"
    ]
  },
  " имеют одинаковый ранг ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " и одинаковое значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_i(b)"
    ]
  },
  ".\nТогда значения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_i(b)"
    ]
  },
  " не влияют на сравнения, и потому их можно заменить на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  ".\nПолучим убывающую последовательность элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " с рангами меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  ".\nЧтобы завершить рассуждение, остаётся сослаться на принцип индукции по множеству ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ".\n\n\n(Более формально, рассмотрим все бесконечно убывающие последовательности.\nУ каждой из них рассмотрим ранг первого элемента.\nРассмотрим те из них, у которых этот ранг минимально возможный;\nпусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " — это минимальное значение.\nВ любой такой последовательности все элементы имеют ранг ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  ".\nИз всех таких последовательностей ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_0 > f_1 > \\dots"
    ]
  },
  " выберем ту, у которой значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_0(b)"
    ]
  },
  " минимально;\nвсе следующие её члены имеют то же значение в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " (т.е. ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f_i(b) = f_0(b)"
    ]
  },
  ").\nЗаменив значение в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b"
    ]
  },
  " нулём, получим бесконечную убывающую последовательность из элементов меньшего ранга, что противоречит предположению.)\n\n\nТеперь покажем, что такое явное определение степени согласовано с индуктивным определением.\nДля конечных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "n"
    ]
  },
  " это очевидно.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma = \\beta + 1"
    ]
  },
  ".\nКаково (явное) определение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^{\\gamma}"
    ]
  },
  "?\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " упорядочено по типу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ".\nТогда мы должны добавить к ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " новый наибольший элемент (обозначим его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "m"
    ]
  },
  ") и рассмотреть отображения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B \\cup \\{m\\} \\to A"
    ]
  },
  " с конечным носителем.\nЯсно, что такое отображение задаётся парой, состоящей из его сужения на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  "\n(которое может быть произвольным элементом множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  ") и значения на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "m"
    ]
  },
  ".\nПри определении порядка мы сначала сравниваем значения на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "m"
    ]
  },
  ", а потом сужения на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", то есть полученное множество изоморфно ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A] \\times A"
    ]
  },
  ", что и требовалось.\n\n\nПусть теперь ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma"
    ]
  },
  " — ненулевой предельный ординал и множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "C"
    ]
  },
  " упорядочено по типу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma"
    ]
  },
  ".\nКак устроено множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[C \\to A]"
    ]
  },
  "?\nЭлементы, ранг которых меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "c \\in C"
    ]
  },
  ", образуют в нём начальный отрезок, и этот начальный отрезок изоморфен ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[[0, c) \\to A]"
    ]
  },
  ".\nА само множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[C \\to A]"
    ]
  },
  " является объединением этих начальных отрезков\n(поскольку каждый элемент этого множества имеет конечный носитель)\nи потому его порядковый тип является точной верхней гранью их порядковых типов, что и требовалось.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nНепосредственным следствием этой теоремы является такое утверждение:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_41",
      "meta": {
        "n": 41
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 41"
        ]
      },
      ". ",
      "\nЕсли ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\beta"
        ]
      },
      " — счётные ординалы, то ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha + \\beta"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha\\beta"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha^\\beta"
        ]
      },
      " счётны.\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nДля суммы и произведения утверждение очевидно.\nДля степени: если мы пронумеровали все элементы вполне упорядоченных множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  ", то любой элемент множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " может быть задан конечным списком натуральных чисел\n(носитель и значения на элементах носителя), а таких списков счётное число.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_139",
      "meta": {
        "n": 139
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "139"
            ]
          },
          ". ",
          "Докажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha^{\\beta + \\gamma} = \\alpha^{\\beta} \\cdot \\alpha^{\\gamma}"
            ]
          },
          " двумя способами: по индукции и с использованием явного определения степени.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_140",
      "meta": {
        "n": 140
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "140"
            ]
          },
          ". ",
          "Докажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(\\alpha^{\\beta})^{\\gamma} = \\alpha^{\\beta\\gamma}"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_141",
      "meta": {
        "n": 141
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "141"
            ]
          },
          ". ",
          "Докажите, что если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha > 2"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha^{\\beta} > \\alpha\\beta"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_142",
      "meta": {
        "n": 142
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "142"
            ]
          },
          ". ",
          "Докажите, что если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\omega^{\\gamma} = \\alpha + \\beta"
            ]
          },
          " для некоторых ординалов ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha, \\beta"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\gamma"
            ]
          },
          ", то либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta = 0"
            ]
          },
          ", либо ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta = \\omega^{\\gamma}"
            ]
          },
          ".",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_143",
      "meta": {
        "n": 143
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "143"
            ]
          },
          ". ",
          "Какие ординалы нельзя представить в виде суммы двух меньших ординалов?",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_144",
      "meta": {
        "n": 144
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "144"
            ]
          },
          ". ",
          "Докажите счётность ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha^{\\beta}"
            ]
          },
          " для счётных ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta"
            ]
          },
          ", используя индуктивное определение степени.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_145",
      "meta": {
        "n": 145
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "145"
            ]
          },
          ". ",
          "\nДан некоторый ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha > 1"
            ]
          },
          ".\nУкажите наименьший ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\beta > 0"
            ]
          },
          ", для которого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alpha\\beta = \\beta"
            ]
          },
          ".\n(Указание: что будет, если умножить ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " на степенной ряд ",
          {
            "name": "math",
            "props": {},
            "children": [
              "1 + x + x^2 + x^3 + \\dots"
            ]
          },
          "?)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nОтметим важную разницу между возведением ординалов в степень и ранее рассмотренными операциями сложения и умножения ординалов.\nОпределяя сумму и произведение ординалов, мы вводили некоторый порядок на сумме и произведении соответствующих множеств (в обычном смысле), здесь же само множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " определяется с учётом порядка и отлично от ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^B"
    ]
  },
  ".\n(В частности, при счётных ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " счётно, а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A^B"
    ]
  },
  " — нет.)\n\n\nЯвное описание множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " позволяет понять, как устроены его начальные отрезки, то есть какой вид имеют ординалы, меньшие ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^{\\beta}"
    ]
  },
  ".\n\n\nРассмотрим некоторую функцию ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f \\in [B \\to A]"
    ]
  },
  ".\nПусть она отлична от нуля в точках ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1 > b_2 > \\ldots > b_k"
    ]
  },
  " и принимает в этих точках значения ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_1, a_2, \\dots , a_k"
    ]
  },
  ".\nНас интересуют все функции, меньшие функции ",
  {
    "name": "math",
    "props": {},
    "children": [
      "f"
    ]
  },
  ".\n\n\nВсе они равны нулю в точках, больших ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1"
    ]
  },
  ".\nВ самой точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1"
    ]
  },
  " они могут быть либо меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_1"
    ]
  },
  ", либо равны ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_1"
    ]
  },
  ".\nЛюбая функция первого типа меньше любой функции второго типа.\nФункции первого типа могут принимать любые значения в точках, меньших ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1"
    ]
  },
  ", а в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1"
    ]
  },
  " имеют значение из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, a_1)"
    ]
  },
  ".\nТем самым их можно отождествить с элементами множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[[0, b_1) \\to A] \\times [0, a_1)"
    ]
  },
  ", и при этом отождествлении сохраняется порядок.\n\n\nФункции второго типа (равные ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_1"
    ]
  },
  " в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1"
    ]
  },
  ") снова разбиваются на две категории: те, которые в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_2"
    ]
  },
  " меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_2"
    ]
  },
  " и те, которые в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_2"
    ]
  },
  " равны ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_2"
    ]
  },
  ".\nФункции первой категории отождествляются с элементами множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[[0, b_2) \\to A] \\times [0, a_2)"
    ]
  },
  ".\nФункции второй категории снова разобьём на части в зависимости от их значения в точке ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_3"
    ]
  },
  " и т.д.\nТаким образом, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[0, f)"
    ]
  },
  " как упорядоченное множество изоморфно множеству\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{aligned}\n[[0, b_1) \\to A] \\times [0, a_1) &+ [[0, b_2) \\to A] \\times [0, a_2) + \\ldots + \\\\\n    &+ [[0, b_k) \\to A] \\times [0, a_k).\n\\end{aligned}\n"
    ]
  },
  "\nПереходя к ординалам (начальные отрезки — это меньшие ординалы), получаем такое утверждение:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_42",
      "meta": {
        "n": 42
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 42"
        ]
      },
      ". ",
      "\nВсякий ординал, меньший ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha^{\\beta}"
        ]
      },
      ", представляется в виде\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\alpha^{\\beta_1} \\alpha_1 + \\alpha^{\\beta_2} \\alpha_2 + \\ldots + \\alpha^{\\beta_k} \\alpha_k,\n"
        ]
      },
      "\nгде ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\beta > \\beta_1 > \\beta_2 > \\ldots > \\beta_k"
        ]
      },
      ", а ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha_1, \\alpha_2, \\dots , \\alpha_k < \\alpha"
        ]
      },
      ". Такое представление однозначно и любая сумма указанного вида является ординалом, меньшим ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\alpha^{\\beta}"
        ]
      },
      ".\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nВозможность такого представления мы уже доказали.\nПоследнее утверждение следует из того, что любая сумма такого вида является начальным отрезком в множестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  "\n(где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B"
    ]
  },
  " упорядочены по типам ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ") и разным суммам соответствуют разные начальные отрезки.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nЭто утверждение обобщает описанную нами ",
  {
    "name": "label",
    "props": {
      "ref": "ordinal-position"
    },
    "children": [
      "ранее"
    ]
  },
  " ",
  {
    "name": "tooltip",
    "props": {
      "content": "Оригинальный текст приводится без изменений.\n\n\n                Но в электронном издании нет нумерации страниц.\n\n\n                Воспользуйтесь ссылкой рядом для навигации."
    },
    "children": [
      "(с. 90)"
    ]
  },
  " «позиционную систему обозначений с основанием ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  "» для ординалов, меньших ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha^k"
    ]
  },
  "; теперь вместо ",
  {
    "name": "math",
    "props": {},
    "children": [
      "k"
    ]
  },
  " можно использовать любой ординал.\n\n\nМожно было бы сразу сказать, что элементами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "[B \\to A]"
    ]
  },
  " являются формальные суммы вида\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\alpha^{\\beta_1} \\alpha_1 + \\alpha^{\\beta_2} \\alpha_2 + \\ldots + \\alpha^{\\beta_k} \\alpha_k\n"
    ]
  },
  "\n(где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta > \\beta_1 > \\ldots > \\beta_k"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_1, \\dots , \\alpha_k < \\alpha"
    ]
  },
  ") с естественным порядком на них.\n\n\nТеперь уже понятно, как устроены ординалы в последовательности\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\omega^{\\omega}, \\omega^{(\\omega^{\\omega})}, \\dots\n"
    ]
  },
  "\nПервый из них образован «одноэтажными» выражениями вида\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\omega^{b_1} a_1 + \\omega^{b_2} a_2 + \\ldots + \\omega^{b_k} a_k,\n"
    ]
  },
  "\nгде ",
  {
    "name": "math",
    "props": {},
    "children": [
      "a_i"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_i"
    ]
  },
  " — натуральные числа (и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1 > \\dots > b_k"
    ]
  },
  ").\nЕсли в качестве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "b_1, \\dots , b_k"
    ]
  },
  " разрешить писать любые «одноэтажные» выражения указанного вида, то полученные «двухэтажные» выражения упорядочены по типу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\omega^{(\\omega^{\\omega})}"
    ]
  },
  ".\nРазрешив в показателях двухэтажные выражения, мы получим трехэтажные выражения, которые образуют следующий ординал и т.д.\nЕсли объединить все эти множества, то есть не ограничивать число этажей\n(которое для каждого выражения тем не менее конечно), то получится множество, упорядоченное по типу\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\sup(\\omega, \\omega^{\\omega}, \\omega^{(\\omega^{\\omega})}, \\dots)\n"
    ]
  },
  "\nЭтот ординал обозначается ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\varepsilon_0"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_146",
      "meta": {
        "n": 146
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "146"
            ]
          },
          ". ",
          "\nДокажите, что\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n\\varepsilon_0 = \\omega + \\omega^{\\omega} + \\omega^{(\\omega^{\\omega})} + \\ldots\n"
            ]
          },
          "\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_147",
      "meta": {
        "n": 147
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "147"
            ]
          },
          ". ",
          "\nОпределим для натуральных чисел операцию «тотальной замены основания ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          " на ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l"
            ]
          },
          "»\n(здесь ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l"
            ]
          },
          " — натуральные числа, причём ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l > k"
            ]
          },
          ") следующим образом: данное число ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " запишем в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "-ичной системе, то есть разложим по степеням ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          ", показатели степеней снова запишем в ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          "-ичной системе, новые показатели также разложим и т.д.\nЗатем на всех уровнях заменим основание ",
          {
            "name": "math",
            "props": {},
            "children": [
              "k"
            ]
          },
          " на основание ",
          {
            "name": "math",
            "props": {},
            "children": [
              "l"
            ]
          },
          " и вычислим значение получившегося выражения.\nДокажите, что начав с любого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "n"
            ]
          },
          " и выполняя последовательность операций «вычитание единицы – тотальная замена основания 2 на 3 – вычитание единицы – тотальная замена основания 3 на 4 – вычитание единицы – тотальная замена основания 4 на 5 – . . . », мы рано или поздно зайдём в тупик, т. е. получится нуль и вычесть единицу будет нельзя.\n(Указание: заменим все основания сразу на ординал ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\omega"
            ]
          },
          "; получится убывающая последовательность ординалов, меньших ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\varepsilon_0"
            ]
          },
          ".)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n\n\n",
  "\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "paragraph_13",
      "meta": {
        "n": 13,
        "longN": "2.13"
      }
    },
    "children": [
      "\n        ",
      {
        "name": "header",
        "props": {
          "level": 3
        },
        "children": [
          "\n        ",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "2.13"
            ]
          },
          ". ",
          "Приложения ординалов",
          "\n        "
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\nВ большинстве случаев рассуждения с использованием трансфинитной индукции и ординалов можно заменить ссылкой на ",
  {
    "name": "label",
    "props": {
      "ref": "theorem_zorns-lemma"
    },
    "children": [
      "лемму Цорна"
    ]
  },
  ";\nпри этом рассуждение становится менее наглядным, но формально более простым.\nТем не менее бывают ситуации, когда такая замена затруднительна.\nВ этом разделе мы приведём два подобных примера.\n\n\nПервый из них касается ",
  {
    "name": "label",
    "props": {
      "ref": "name_borel"
    },
    "children": [
      "борелевских"
    ]
  },
  " множеств.\n(Для простоты мы рассматриваем подмножества действительной прямой.)\nСемейство подмножеств называется ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      " ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\sigma"
        ]
      },
      "-алгеброй"
    ]
  },
  ", если оно замкнуто относительно конечных и счётных пересечений и объединений, а также относительно перехода к дополнению.\n(Это означает, что вместе с каждым множеством ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A"
    ]
  },
  " это семейство содержит его дополнение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\R \\setminus A"
    ]
  },
  ", и вместе с любыми множествами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0, A_1, \\dots"
    ]
  },
  " семейство содержит их объединение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0 \\cup A_1 \\cup \\dots"
    ]
  },
  " и пересечение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "A_0 \\cap A_1 \\cap \\dots"
    ]
  },
  ")\nПример: семейство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P(\\R)"
    ]
  },
  " всех подмножеств прямой, очевидно, является ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгеброй.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_43",
      "meta": {
        "n": 43
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 43"
        ]
      },
      ". ",
      "Существует наименьшая ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\sigma"
        ]
      },
      "-алгебра, содержащая все отрезки ",
      {
        "name": "math",
        "props": {},
        "children": [
          "[a, b]"
        ]
      },
      " на прямой.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nФормально можно рассуждать так: рассмотрим все возможные ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгебры, содержащие отрезки.\nИх пересечение будет ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгеброй, и тоже будет содержать все отрезки.\n(Вообще пересечение любого семейства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгебр будет ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгеброй — это очевидное следствие определения.)\nЭта ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгебра и будет искомой.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nМножества, входящие в эту наименьшую ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгебру, называют ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "борелевскими"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_148",
      "meta": {
        "n": 148
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "148"
            ]
          },
          ". ",
          "\nДокажите, что всякое открытое и всякое замкнутое подмножество прямой является борелевским.\n(Указание: открытое множество есть объединение содержащихся в нём отрезков с рациональными концами.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_149",
      "meta": {
        "n": 149
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "149"
            ]
          },
          ". ",
          "Докажите, что прообраз любого борелевского множества при непрерывном отображении является борелевским множеством.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_150",
      "meta": {
        "n": 150
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "150"
            ]
          },
          ". ",
          "\nПусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f_0, f_1, \\dots"
            ]
          },
          " — последовательность непрерывных функций с действительными аргументами и значениями.\nДокажите, что множество точек ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ", в которых последовательность ",
          {
            "name": "math",
            "props": {},
            "children": [
              "f_0(x), f_1(x), \\dots"
            ]
          },
          " имеет предел, является борелевским.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nБорелевские множества играют важную роль в ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "дескриптивной теории множеств"
    ]
  },
  ".\nНо мы хотим лишь продемонстрировать использование трансфинитной индукции (которую трудно заменить на лемму Цорна) на примере следующей теоремы:\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_44",
      "meta": {
        "n": 44
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 44"
        ]
      },
      ". ",
      "Семейство всех борелевских множеств имеет мощность континуума.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nКласс борелевских множеств можно строить постепенно.\nНачнём с отрезков и дополнений к отрезкам.\nНа следующем шаге рассмотрим всевозможные счётные пересечения и объединения уже построенных множеств (отрезков и дополнений к ним).\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_151",
      "meta": {
        "n": 151
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "151"
            ]
          },
          ". ",
          "Докажите, что при этом получатся (среди прочего) все открытые и все замкнутые подмножества прямой.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nДалее можно рассмотреть счётные объединения и пересечения уже построенных множеств и т.д.\n\n\nБолее формально, пусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_0"
    ]
  },
  " — семейство множеств, состоящее из всех отрезков и дополнений к ним.\nОпределим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{i+1}"
    ]
  },
  " по индукции как семейство множеств, являющихся счётными объединениями или пересечениями множеств из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_i"
    ]
  },
  ".\n\n\nВсе семейства ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_i"
    ]
  },
  " состоят из борелевских множеств (поскольку счётное объединение или пересечение борелевских множеств является борелевским).\nИсчерпывают ли они все борелевские множества?\nВообще говоря, нет: если мы возьмём по одному множеству из каждого класса ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_i"
    ]
  },
  " для всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i = 0, 1, 2, \\dots"
    ]
  },
  " и рассмотрим их счётное пересечение, то оно вполне может не принадлежать ни одному из классов.\nПоэтому мы рассмотрим класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\omega}"
    ]
  },
  ", представляющий собой объединение всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_i"
    ]
  },
  " по всем натуральным ",
  {
    "name": "math",
    "props": {},
    "children": [
      "i"
    ]
  },
  ", затем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\omega + 1}"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\omega + 2}"
    ]
  },
  " и т.д.\nОбъединение этой последовательности классов естественно назвать ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\omega 2}"
    ]
  },
  " и продолжить построение.\n\n\nДадим формальное определение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha}"
    ]
  },
  " для любого ординала ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ".\nЭто делается с помощью трансфинитной рекурсии.\nПри ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha = \\beta + 1"
    ]
  },
  " элементами класса ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha}"
    ]
  },
  " будут счётные объединения и пересечения множеств из класса ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\beta}"
    ]
  },
  ".\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " — предельный ординал, отличный от ",
  {
    "name": "math",
    "props": {},
    "children": [
      "0"
    ]
  },
  ", то класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha}"
    ]
  },
  " представляет собой объединение всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\beta}"
    ]
  },
  " по всем ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\alpha"
    ]
  },
  ".\n(Класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_0"
    ]
  },
  " мы уже определили.)\n\n\nИз определения следует, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha} \\subset \\mathcal{B}_{\\beta}"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha < \\beta"
    ]
  },
  ", так что мы получаем возрастающую цепь классов.\nКаждый класс замкнут относительно перехода к дополнению (для начального класса мы об этом позаботились, далее по индукции).\nВсе классы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha}"
    ]
  },
  " содержатся в классе борелевских множеств, так как мы применяем лишь операции счётного объединения и пересечения, относительно которых класс борелевских множеств замкнут.\n\n\nВозникает вопрос: как далеко нужно продолжать эту конструкцию?\nОказывается, что достаточно дойти до первого несчётного ординала.\n\n\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  " — наименьший несчётный ординал.\n(Это — стандартное для него обозначение.)\nДругими словами, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  " есть семейство всех счётных ординалов, упорядоченных отношением ",
  {
    "name": "math",
    "props": {},
    "children": [
      "<"
    ]
  },
  " на ординалах.\n\n\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Лемма"
    ]
  },
  ". Класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  " замкнут относительно счётных объединений и пересечений и потому содержит все борелевские множества.\n\n\nДоказательство леммы.\nПусть имеется счётная последовательность множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_0, B_1, \\dots"
    ]
  },
  " , принадлежащих ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  ".\nОрдинал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  " — предельный, и класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  " является объединением меньших классов.\nПоэтому каждое из множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_i"
    ]
  },
  " принадлежит какому-то классу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_{\\alpha_i}"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_i"
    ]
  },
  " — некоторый ординал, меньший ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  ", т.е. конечный или счётный ординал.\nПоложим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta = \\sup_i \\alpha_i"
    ]
  },
  ".\nОрдинал ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  " есть точная верхняя грань счётного числа счётных ординалов и потому счётен.\nВ самом деле, рассмотрим ординалы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha_i"
    ]
  },
  " как начальные отрезки в каком-то большем ординале (например, в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  ");\nих точная верхняя грань будет объединением счётного числа счётных начальных отрезков и потому будет счётным ординалом.\n\n\nТеперь первое утверждение леммы очевидно: все ",
  {
    "name": "math",
    "props": {},
    "children": [
      "B_i"
    ]
  },
  " лежат в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\beta}"
    ]
  },
  ", а потому их объединение (или пересечение) лежит в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\beta + 1}"
    ]
  },
  " и тем более в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  "\n(поскольку ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta + 1"
    ]
  },
  " есть счётный ординал и меньше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  ").\n\n\nТаким образом, класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  " является ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\sigma"
    ]
  },
  "-алгеброй, содержащей отрезки, и потому содержит все борелевские множества.\nЛемма доказана.\n\n\nКак мы уже отмечали, все классы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha}"
    ]
  },
  " состоят из борелевских множеств, так что класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  " совпадает с классом всех борелевских множеств.\n\n\nЧто можно сказать про мощность классов?\nКласс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_0"
    ]
  },
  " имеет мощность континуума (отрезки задаются своими концами).\nЕсли класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha}"
    ]
  },
  " имеет мощность континуума, то и следующий класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alpha + 1}"
    ]
  },
  " имеет мощность континуума\n(каждый его элемент задаётся счётной последовательностью элементов предшествующего класса, а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c}^{\\alef_0} = \\frak{c}"
    ]
  },
  ").\nКаждый предельный класс есть объединение предыдущих, и пока мы не выходим за пределы счётных ординалов, объединение это будет счётно, а ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c} \\alef_0 = \\frak{c}"
    ]
  },
  ", так что мы не выходим за пределы континуума.\nНаконец, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  " есть объединение несчётного числа предыдущих классов (а именно, ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  " классов), но так как ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1 \\leqslant \\frak{c}"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\frak{c} \\alef_1 = \\frak{c}"
    ]
  },
  ".\n\n\nТаким образом, класс ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathcal{B}_{\\alef_1}"
    ]
  },
  ", он же класс всех борелевских множеств, имеет мощность континуума.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nОбычно построение борелевских множеств начинается немного иначе.\nИменно, на нижнем уровне рассматриваются два класса: открытые и замкнутые множества.\nНа следующем уровне находятся классы ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F_{\\sigma}"
    ]
  },
  " (счётные объединения замкнутых множеств) и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "G_{\\delta}"
    ]
  },
  " (счётные пересечения открытых множеств).\nЕщё на уровень выше лежат счётные пересечения множеств из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "F_{\\sigma}"
    ]
  },
  " и счётные объединения множеств из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "G_{\\delta}"
    ]
  },
  ", и т.д.\nТакой подход является более естественным с точки зрения топологии, поскольку отрезки на прямой ничем не замечательны.\nМожно проверить, что разница между таким подходом и нашим определением невелика.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_152",
      "meta": {
        "n": 152
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "152"
            ]
          },
          ". ",
          "\nДокажите, что пересечение двух ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          "-множеств является ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          "-множеством\n(и вообще классы ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          ", а также классы следующих уровней, замкнуты относительно конечных объединений и пересечений).\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_153",
      "meta": {
        "n": 153
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "153"
            ]
          },
          ". ",
          "Докажите, что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          "- и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          "-множества лежат в классе ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\mathcal{B}_2"
            ]
          },
          " в соответствии с нашей классификацией.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_154",
      "meta": {
        "n": 154
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "154"
            ]
          },
          ". ",
          "Докажите, что всякое множество класса ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\mathcal{B}_2"
            ]
          },
          " отличается от некоторого ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          "- или ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          "-множества не более чем на счётное множество.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_155",
      "meta": {
        "n": 155
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "155"
            ]
          },
          ". ",
          "Докажите, что всякое множество класса ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\mathcal{B}_3"
            ]
          },
          " является счётным пересечением ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          "-множеств или счётным объединением ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          "-множеств и что аналогичное утверждение верно для более высоких уровней нашей иерархии.",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_156",
      "meta": {
        "n": 156
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "156"
            ]
          },
          ". ",
          "\nДокажите, что существует открытое множество на плоскости, среди вертикальных сечений которого встречаются все открытые подмножества прямой.\nДокажите, что существует ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          "-множество на плоскости, среди сечений которого встречаются все ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          "-подмножества прямой.\nДокажите аналогичные утверждения для следующих уровней.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_157",
      "meta": {
        "n": 157
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "157"
            ]
          },
          ". ",
          "\nПокажите, что существует ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          "-множество, не являющееся ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          "-множеством.\nПокажите, что существует счётное объединение ",
          {
            "name": "math",
            "props": {},
            "children": [
              "G_{\\delta}"
            ]
          },
          "-множеств, не являющееся счётным пересечением ",
          {
            "name": "math",
            "props": {},
            "children": [
              "F_{\\sigma}"
            ]
          },
          "-множеств и т.д.\n(Указание: воспользуйтесь предыдущей задачей.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nОрдиналы часто появляются при классификации элементов того или иного множества по «рангам».\nНапример, можно классифицировать элементы фундированного множества.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_45",
      "meta": {
        "n": 45
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 45"
        ]
      },
      ". ",
      "\nПусть ",
      {
        "name": "math",
        "props": {},
        "children": [
          "X"
        ]
      },
      " — фундированное множество.\nТогда существует и единственна функция ",
      {
        "name": "math",
        "props": {},
        "children": [
          "\\mathrm{rk}"
        ]
      },
      ", определённая на ",
      {
        "name": "math",
        "props": {},
        "children": [
          "X"
        ]
      },
      " и принимающая значения в классе ординалов, для которой\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\mathrm{rk}(x) = \\min\\{\\alpha \\ | \\ \\alpha > \\mathrm{rk}(y) \\ \\text{для любого} \\ y < x\\}\n"
        ]
      },
      "\n(при любом ",
      {
        "name": "math",
        "props": {},
        "children": [
          "x \\in X"
        ]
      },
      ").\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nОпределим множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\alpha}"
    ]
  },
  " рекурсией по ординалу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ": ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\alpha}"
    ]
  },
  " состоит из всех элементов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X"
    ]
  },
  ", для которых все меньшие их (в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ") элементы принадлежат ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\beta}"
    ]
  },
  " с меньшими индексами ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta"
    ]
  },
  ":\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\nx \\in X_{\\alpha} \\lrArr (\\forall y < x) (\\exists \\beta < \\alpha) (y \\in X_{\\beta}).\n"
    ]
  },
  "\nЗаметим, что здесь (как и в формулировке теоремы) знак ",
  {
    "name": "math",
    "props": {},
    "children": [
      "<"
    ]
  },
  " используется в двух разных смыслах: как порядок на ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  " и как порядок на ординалах.\n\n\nОчевидно, что с ростом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\alpha}"
    ]
  },
  " растёт (точнее, не убывает).\nДокажем, что при достаточно большом ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\alpha}"
    ]
  },
  " покрывает всё ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ".\nЕсли это не так, то из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\gamma"
    ]
  },
  " следует ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\beta} \\subsetneq X_{\\gamma}"
    ]
  },
  "\n(произвольный минимальный элемент, не лежащий в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\beta}"
    ]
  },
  ", принадлежит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\gamma}"
    ]
  },
  ").\nПоэтому отображение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha \\mapsto X_{\\alpha}"
    ]
  },
  " будет инъекцией, что невозможно\n(возьмём ординал, по мощности больший ",
  {
    "name": "math",
    "props": {},
    "children": [
      "P(X)"
    ]
  },
  "; предшествующих ему ординалов уже слишком много).\n\n\nТеперь определим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{rk}(x)"
    ]
  },
  " как минимальное значение ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ", для которого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X_{\\alpha}"
    ]
  },
  ".\nЕсли ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{rk}(x) = \\alpha"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{rk}(y) < \\alpha"
    ]
  },
  ".\n(В самом деле, по определению ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\alpha}"
    ]
  },
  " из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X_{\\alpha}"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  " следует, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y \\in X_{\\beta}"
    ]
  },
  " при некотором ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\alpha"
    ]
  },
  ".)\nНаоборот, если для некоторого ординала ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma"
    ]
  },
  " выполнено неравенство ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{rk}(y) < \\gamma"
    ]
  },
  " при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{rk}(x) \\leqslant \\gamma"
    ]
  },
  ".\nВ самом деле, тогда любой элемент ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y < x"
    ]
  },
  " принадлежит некоторому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X_{\\beta}"
    ]
  },
  " с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\gamma"
    ]
  },
  "\n(положим ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta = \\mathrm{rk}(y)"
    ]
  },
  ") и потому ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x \\in X_{\\gamma}"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{rk}(x) \\leqslant \\gamma"
    ]
  },
  ".\n\n\nИтак, построенная нами функция ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\mathrm{rk}"
    ]
  },
  " обладает требуемым свойством.\nЕдинственность доказать совсем легко: если есть две такие функции, рассмотрим минимальную точку в ",
  {
    "name": "math",
    "props": {},
    "children": [
      "X"
    ]
  },
  ", на которой они различаются, и сразу же получим противоречие.\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\nВ частности, счётные ординалы можно использовать для классификации деревьев, в которых нет бесконечных путей.\nМы будем рассматривать ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "корневые деревья с конечным или счётным ветвлением"
    ]
  },
  "\n(у каждой вершины конечное или счётное число сыновей),\nв которых нет бесконечной ветви (последовательности вершин, в которых каждая есть сын предыдущей).\n\n\nФормально такое дерево можно определить как подмножество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  " множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\N^*"
    ]
  },
  " конечных последовательностей натуральных чисел, замкнутое относительно взятия префикса\n(если последовательность принадлежит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  ", то любой её начальный отрезок принадлежит ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  ").\nЭлементы множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  " мы называем ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "вершинами"
    ]
  },
  " дерева;\nвершина ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  " есть ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "сын"
    ]
  },
  " вершины ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  " получается из ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " приписыванием справа какого-то одного числа.\nВершина ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  " является ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "потомком"
    ]
  },
  " вершины ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {},
    "children": [
      "y"
    ]
  },
  " получается добавлением к ",
  {
    "name": "math",
    "props": {},
    "children": [
      "x"
    ]
  },
  " одного или нескольких чисел.\n\n\nМы говорим, что в дереве ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  " ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "нет бесконечной ветви"
    ]
  },
  ", если не существует бесконечной последовательности натуральных чисел, все начала которой принадлежат ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  ".\nВ этом случае отношение порядка\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\ny < x \\lrArr y \\ \\text{есть потомок} \\ x\n"
    ]
  },
  "\nфундировано и можно применить предыдущую теорему, определив ранги всех вершин дерева ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  ".\nРанг его ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "корня"
    ]
  },
  " (последовательности длины 0) и будем называть ",
  {
    "name": "format.i",
    "props": {},
    "children": [
      "рангом дерева"
    ]
  },
  ".\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_tree-rang",
      "meta": {
        "n": 46
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 46"
        ]
      },
      ". ",
      "\n",
      {
        "name": "area",
        "props": {
          "key": "theorem_tree-rang-а"
        },
        "children": [
          "(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "а"
            ]
          },
          ") Ранг любого дерева (описанного вида) является счётным ординалом."
        ]
      },
      "\n",
      {
        "name": "area",
        "props": {
          "key": "theorem_tree-rang-б"
        },
        "children": [
          "(",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "б"
            ]
          },
          ") Всякий счётный ординал является рангом некоторого дерева."
        ]
      },
      "\n",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\n",
  {
    "name": "label",
    "props": {
      "ref": "theorem_tree-rang-а"
    },
    "children": [
      "(а)"
    ]
  },
  " Пусть ранг некоторого дерева, то есть ранг его корня, является несчётным ординалом.\nТогда ранг одного из сыновей корня также несчётен.\n(В самом деле, точная верхняя грань счётного множества счётных ординалов является счётным ординалом;\nэто становится ясным, если рассматривать эти ординалы как начальные отрезки большего — тогда точная верхняя грань будет объединением.)\nУ этого сына в свою очередь есть сын несчётного ранга и т.д.\nЭтот процесс не может оборваться, и мы получаем бесконечную ветвь в противоречии с предположением.\n\n\n",
  {
    "name": "label",
    "props": {
      "ref": "theorem_tree-rang-б"
    },
    "children": [
      "(б)"
    ]
  },
  " Это утверждение доказывается индукцией: пусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " — наименьший счётный ординал, для которого такого дерева нет.\nТогда для всех меньших ординалов деревья есть.\nВозьмём эти деревья и сделаем их поддеревьями с общим корнем (их корни станут сыновьями этого общего корня).\nНовое дерево также имеет счётное ветвление и ранг его корня равен ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  ".\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_158",
      "meta": {
        "n": 158
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "158"
            ]
          },
          ". ",
          "\nПусть имеется счётное дерево, не имеющее бесконечных ветвей.\nПредположим, что в каждом его листе находится отрезок или дополнение до отрезка, а в каждой внутренней вершине стоит знак пересечения или объединения.\nКак сопоставить такому дереву некоторое борелевское множество?\n(Указание: покажите, что в каждой вершине можно единственным образом написать некоторое множество, согласованное с пометками.)\nПокажите, что все борелевские множества могут быть получены таким способом.\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nДеревья с пометками, рассмотренные в этой задаче, представляют собой как бы бесконечные формулы, составленные из отрезков и дополнений к ним с помощью операций счётного объединения и пересечения\n(конечные деревья соответствовали бы конечным формулам).\nМожно условно сказать, что борелевские множества — это множества, выражающиеся с помощью таких формул.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_159",
      "meta": {
        "n": 159
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "159"
            ]
          },
          ". ",
          "\nДокажите, что семейство борелевских множеств имеет мощность континнума, используя «бесконечные формулы» — размеченные деревья, в которых нет бесконечных ветвей.\n(Это доказательство обходится без ординалов, трансфинитной индукции и даже леммы Цорна — хотя и использует аксиому выбора.)\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nВ заключение приведём скорее забавный, чем важный, пример использования трансфинитной рекурсии и ординалов.\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "theorem_47",
      "meta": {
        "n": 47
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Теорема 47"
        ]
      },
      ". ",
      "Существует множество точек на плоскости, которое пересекается с каждой прямой ровно в двух точках.",
      "\n        "
    ]
  },
  "\n        ",
  "\n\n\nДве параллельные прямые почти что удовлетворяют этому требованию (исключением являются лишь параллельные им прямые).\nНо избавиться от этого исключения не так просто.\n\n\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleleft"
    ]
  },
  "\nТребования к множеству можно сформулировать так: никакие три точки не лежат на одной прямой, но любая прямая пересекает его не менее чем в двух точках.\n\n\nБудем строить это множество трансфинитной рекурсией.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alpha"
    ]
  },
  " — минимальный ординал, имеющий мощность континуума.\n(Если континуум-гипотеза верна, то он совпадает с ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\alef_1"
    ]
  },
  ", но это нам не важно.)\nТогда множество всех меньших ординалов можно поставить во взаимно однозначное соответствие с множеством всех прямых на плоскости.\nПусть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l_{\\beta}"
    ]
  },
  " — прямая, соответствующая ординалу ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\alpha"
    ]
  },
  ".\n\n\nДля каждого ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\alpha"
    ]
  },
  " построим множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M_{\\beta}"
    ]
  },
  ", в котором никакие три точки не лежат на одной прямой, следующим образом.\nОбъединим все построенные ранее множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M_{\\gamma}"
    ]
  },
  " при всех ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma < \\beta"
    ]
  },
  ".\nМогут ли в этом множестве (обозначим его ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  ") какие-то три точки лежать на одной прямой?\nЕсли да, то эти точки берутся из каких-то множеств ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M_{\\gamma_1}, M_{\\gamma_2}, M_{\\gamma_3}"
    ]
  },
  ";\nвозьмём наибольший из ординалов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma_1, \\gamma_2, \\gamma_3"
    ]
  },
  ";\nв соответствующем множестве будут три точки, лежащие на одной прямой, что противоречит предположению индукции.\n\n\nПосмотрим, во скольких точках пересекает прямая ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l_{\\beta}"
    ]
  },
  " множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  ".\nТаких точек (по доказанному) не больше двух.\nЕсли их ровно две, то всё хорошо и мы новых точек не добавляем, считая, что ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M_{\\beta} = T"
    ]
  },
  ".\nЕсли их меньше, то мы должны добавить новые точки (до двух), но только так, чтобы при этом не образовалось трёх точек, лежащих на одной прямой.\nДругими словами, нельзя добавлять точки, которые лежат на пересечении ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l_{\\beta}"
    ]
  },
  " с прямыми, проходящими через пары уже имеющихся точек.\n\n\nСколько таких прямых (то есть сколько пар уже имеющихся точек)?\nПо построению видно, что все уже имеющиеся точки лежат по две на каждой прямой ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l_{\\gamma}"
    ]
  },
  " при ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\gamma < \\beta"
    ]
  },
  ".\n(Строго говоря, это следует включить в индуктивное предположение.)\nТаким образом, множество ",
  {
    "name": "math",
    "props": {},
    "children": [
      "T"
    ]
  },
  " по мощности есть ",
  {
    "name": "math",
    "props": {},
    "children": [
      "2 \\beta = \\beta"
    ]
  },
  ", а пар точек не больше ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta^2 = \\beta < \\frak{c}"
    ]
  },
  ".\nПоэтому запрещённые точки составляют лишь малую (по мощности) часть прямой ",
  {
    "name": "math",
    "props": {},
    "children": [
      "l_{\\beta}"
    ]
  },
  ", и можно выбрать две разрешённые точки.\n\n\nТеперь осталось объединить множества ",
  {
    "name": "math",
    "props": {},
    "children": [
      "M_{\\beta}"
    ]
  },
  " для всех ординалов ",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\beta < \\alpha"
    ]
  },
  " и получить искомое множество.\n(По условию три точки на одной прямой в нём появиться не могут, а всякая прямая будет рано или поздно рассмотрена и две точки на ней будут обеспечены.)\n",
  {
    "name": "math",
    "props": {},
    "children": [
      "\\vartriangleright"
    ]
  },
  "\n\n\n",
  "\n        ",
  {
    "name": "area",
    "props": {
      "key": "problem_160",
      "meta": {
        "n": 160
      }
    },
    "children": [
      "\n        ",
      {
        "name": "format.small",
        "props": {},
        "children": [
          "",
          {
            "name": "format.b",
            "props": {},
            "children": [
              "160"
            ]
          },
          ". ",
          "\nНайдите ошибку в следующем «опровержении гипотезы континуума»: пусть ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alef_1 = \\frak{c}"
            ]
          },
          ".\nУпорядочим отрезок ",
          {
            "name": "math",
            "props": {},
            "children": [
              "[0, 1]"
            ]
          },
          " по типу ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\alef_1"
            ]
          },
          ".\nРассмотрим функцию двух переменных, равную единице на паре ",
          {
            "name": "math",
            "props": {},
            "children": [
              "(x, y)"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x < y"
            ]
          },
          " (в смысле этого порядка), и нулю в остальных случаях.\nТогда при фиксированном ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          " функия ",
          {
            "name": "math",
            "props": {},
            "children": [
              "y \\mapsto f(x, y)"
            ]
          },
          " равна единице везде, кроме счётного множества, и потому интегрируема и ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\int f(x, y) dy = 1"
            ]
          },
          " при любом ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x"
            ]
          },
          ".\nС другой стороны, функция ",
          {
            "name": "math",
            "props": {},
            "children": [
              "x \\mapsto f(x, y)"
            ]
          },
          " равна нулю всюду, кроме счётного множества, так что ",
          {
            "name": "math",
            "props": {},
            "children": [
              "\\int f(x, y) dx = 0"
            ]
          },
          ".\nПолучаем противоречие с теоремой ",
          {
            "name": "label",
            "props": {
              "ref": "name_fubini"
            },
            "children": [
              "Фубини"
            ]
          },
          ", которая утверждает, что\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n\\int_0^1\\left(\\int_0^1 f(x, y)\\,dy\\right)\\,dx = \\int_0^1\\left(\\int_0^1 f(x, y)\\,dx\\right)\\,dy.\n"
            ]
          },
          "\n",
          ""
        ]
      },
      "\n        "
    ]
  },
  "\n        ",
  "\n",
  "\n",
  "\n\n\n",
  "\n",
  "\n            ",
  {
    "name": "area",
    "props": {
      "key": "lib"
    },
    "children": [
      "\n            ",
      {
        "name": "header",
        "props": {
          "level": 2
        },
        "children": [
          "Литература"
        ]
      },
      "\n            "
    ]
  },
  "\n            ",
  "\n",
  {
    "name": "area",
    "props": {
      "key": "lib_1"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "1"
        ]
      },
      "] П. С. Александров, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Введение в теорию множеств и общую топологию."
        ]
      },
      " М.: Наука, 1977.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_2"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "2"
        ]
      },
      "] Н. Бурбаки, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Начала математики. Первая часть. Основные\nструктуры анализа. Книга первая. Теория множеств."
        ]
      },
      " Перевод\nс французского Г. Н. Поварова и Ю. А.Шихановича под редакцией В. А. Успенского. М.: Мир, 1965. 456 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_3"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "3"
        ]
      },
      "] Т. Йех, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Теория множеств и метод форсинга."
        ]
      },
      " Перевод с английского В. И. Фуксона под редакцией В. Н. Гришина. М.: Мир,\n1973. 150 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_4"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "4"
        ]
      },
      "] Георг Кантор, Труды по теории множеств, перевод Ф. А. Медведева и А. П.Юшкевича, издание подготовили А. Н. Колмогоров, Ф. А. Медведев, А. П.Юшкевич, ответственные редакторы\nА. Н. Колмогоров, А. П.Юшкевич. М.: Наука, 1985. 431 с. (Серия\n«Классики науки».)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_5"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "5"
        ]
      },
      "] Пол Дж. Коэн, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Теория множеств и континуум-гипотеза."
        ]
      },
      " Перевод с английского А. С. Есенина-Вольпина, М.: Мир, 1969.\n347 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_6"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "6"
        ]
      },
      "] К. Куратовский, А. Мостовский, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Теория множеств."
        ]
      },
      " Перевод\nс английского М. И. Кратко под редакцией А. Д. Тайманова.\nМ.: Мир, 1970. 416 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_7"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "7"
        ]
      },
      "] И. А. Лавров, Л. Л. Максимова, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Задачи по теории множеств,\nматематической логике и теории алгоритмов."
        ]
      },
      " Издание второе, М.: Наука, 1984. 224 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_8"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "8"
        ]
      },
      "] Ю. И. Манин, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Доказуемое и недоказуемое."
        ]
      },
      " М.: Советское радио,\n1979. 168 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_9"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "9"
        ]
      },
      "] А. Мостовский, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Конструктивные множества и их приложения."
        ]
      },
      " Перевод с английского М. И. Кратко, Н. В. Белякина и\nМ. К. Валиева под редакцией А. Г. Драгалина и А. Д. Тайманова.\nМ.: Мир, 1973. 256 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_10"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "10"
        ]
      },
      "] ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Справочная книга по математической логике в четырёх частях под редакцией Дж. Барвайса. Часть II. Теория множеств."
        ]
      },
      " Перевод с английского В. Г. Кановея под редакцией\nВ. Н. Гришина. М.: Наука, 1982. 376 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_11"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "11"
        ]
      },
      "] А. А. Френкель, И. Бар-Хиллел, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Основания теории множеств."
        ]
      },
      "\nПеревод с английского Ю. А. Гастева под редакцией А. С. Есенина-Вольпина. М.: Мир, 1966. 556 с.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_12"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "12"
        ]
      },
      "] Ф. Хаусдорф, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Теория множеств."
        ]
      },
      " Под редакцией и с дополнениями П. С. Александрова и А. Н. Колмогорова. М. – Л.: ОНТИ,\n1937.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lib_13"
    },
    "children": [
      "\n[",
      {
        "name": "strong",
        "props": {},
        "children": [
          "13"
        ]
      },
      "] Дж.Шенфилд, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "Математическая логика"
        ]
      },
      ", перевод с английского И. А. Лаврова и И. А. Мальцева под редакцией Ю. Л. Ершова.\nМ.: Наука, 1975. 528 с.\n"
    ]
  },
  "\n",
  "\n\n\n",
  "\n",
  "\n            ",
  {
    "name": "area",
    "props": {},
    "children": [
      "\n            ",
      {
        "name": "header",
        "props": {
          "level": 2
        },
        "children": [
          "Указатель имён"
        ]
      },
      "\n            "
    ]
  },
  "\n            ",
  "\n",
  {
    "name": "area",
    "props": {
      "key": "name_banach"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Банах,_Стефан"
        },
        "children": [
          "Банах С. (Stefan Banach)"
        ]
      },
      ", 30.03.1892 (Krako´v, ныне в Польше) – 31.08.1945 (Львiв, ныне в Украине)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_bernstein"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Бернштейн,_Феликс"
        },
        "children": [
          "Бернштейн Ф. (Felix Bernstein)"
        ]
      },
      ", 24.02.1878, Halle (Германия) – 03.12.1956, Zurich (Швейцария)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_borel"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Борель,_Эмиль"
        },
        "children": [
          "Борель Э. (Fe´lix Edouard Justin E´mile Borel)"
        ]
      },
      ", 07.01.1871, Saint Affrique, A´veyron, Midi-Pyre´ne´es (Франция) – 03.02.1956, Paris (Франция)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_brouwer"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Брауэр,_Лёйтзен_Эгберт_Ян"
        },
        "children": [
          "Брауэр Л. Э. Я. (Luitzen Egbertus Jan Brouwer)"
        ]
      },
      ", 27.02.1881, Overschie (ныне в Роттердаме, Нидерланды) – 02.12.1966, Blaricum (Нидерланды)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_forti"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://en.wikipedia.org/wiki/Cesare_Burali-Forti"
        },
        "children": [
          "Бурали-Форти (Cesare Burali-Forti)"
        ]
      },
      ", 13.08.1861, Arezzo (Италия) – 21.01.1931, Turin (Италия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_wiener"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Винер,_Норберт"
        },
        "children": [
          "Винер Н. (Norbert Wiener)"
        ]
      },
      ", 26.11.1894, Columbia, Missouri (США) – 18.03.1964, Stockholm (Швеция)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_galilei"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Галилей,_Галилео"
        },
        "children": [
          "Галилей Г. (Galileo Galilei)"
        ]
      },
      ", 15.02.1564, Pisa (ныне в Италии) – 08.01.1642, Arcetri, рядом с Флоренцией (Италия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_hamel"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://en.wikipedia.org/wiki/Georg_Hamel"
        },
        "children": [
          "Гамель (Georg Karl Wilhelm Hamel)"
        ]
      },
      ", 12.09.1877, Düren, Rheinland (Германия) – 04.10.1954, Landshut (Германия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_godel"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Гёдель,_Курт"
        },
        "children": [
          "Гёдель К. (Kurt Gödel)"
        ]
      },
      ", 28.04.1906, Brünn, Австро-Венгрия (ныне Брно, Чехия) – 14.01.1978, Princeton (США)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_hilbert"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Гильберт,_Давид"
        },
        "children": [
          "Гильберт Д. (David Hilbert)"
        ]
      },
      ", 23.01.1862, Königsberg, Prussia (ныне Калиниград, Россия) – 14.02.1943, Göttingen (Германия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_dedekind"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Дедекинд,_Рихард"
        },
        "children": [
          "Дедекинд Р. (Julius Wilhelm Richard Dedekind)"
        ]
      },
      ", 06.10.1831, Braunschweig (ныне Германия) – 12.02.1916, Braunschweig (Германия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_euclid"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Евклид"
        },
        "children": [
          "Евклид Александрийский"
        ]
      },
      ", около 325 (?) до Р. Х. – около 265 (?) до Р. Х., Александрия (ныне Египет)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_cantor"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Кантор,_Георг"
        },
        "children": [
          "Кантор Г. (Georg Ferdinand Ludwig Philipp Cantor)"
        ]
      },
      ", 03.03.1845, Петербург (Россия) – 06.01.1918, Halle (Германия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_konig"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://en.wikipedia.org/wiki/Gyula_Kőnig"
        },
        "children": [
          "Кёниг Ю. (Julius König)"
        ]
      },
      ", 16.12.1849, Györ (Венгрия) – 08.04.1913, Budapest (Венгрия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_cohen"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Коэн,_Пол_Джозеф"
        },
        "children": [
          "Коэн П. Дж. (Paul Joseph Cohen)"
        ]
      },
      ", 02.04.1934, Long Branch, New Jersey (США) – 23.03.2007, Stanford, California (США)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_kuratowski"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Куратовский,_Казимеж"
        },
        "children": [
          "Куратовский К. (Kazimierz Kuratowski)"
        ]
      },
      ", 02.02.1896, Warsaw, Польша (Россия) – 18.06.1980, Warsaw (Польша)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_lindemann"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Линдеман,_Фердинанд_фон"
        },
        "children": [
          "Линдеман Ф. (Carl Louis Ferdinand von Lindemann)"
        ]
      },
      ", 12.04.1852, Hannover (ныне Германия) – 06.03.1939, Munich (Германия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_liouville"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Лиувилль,_Жозеф"
        },
        "children": [
          "Лиувилль Ж. (Joseph Liouville)"
        ]
      },
      ", 24.03.1809, Saint-Omer (Франция) – 08.09.1882, Paris (Франция)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_lobachevski"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Лобачевский,_Николай_Иванович"
        },
        "children": [
          "Лобачевский Николай Иванович"
        ]
      },
      ", 01.12.1792, Нижний Новгород (Россия) – 24.02.1856, Казань (Россия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_neumann"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Нейман,_Джон_фон"
        },
        "children": [
          "Нейман Дж. (John von Neumann)"
        ]
      },
      ", 28.12.1903, Budapest (Венгрия) – 08.02.1957, Washington, D.C. (США)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_newton"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Ньютон,_Исаак"
        },
        "children": [
          "Ньютон И. (Sir Isaac Newton)"
        ]
      },
      ", 04.01.1643, Woolsthorpe, Lincolnshire (Англия) – 31.03.1727, London (Англия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_peano"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Пеано,_Джузеппе"
        },
        "children": [
          "Пеано Дж. (Giuseppe Peano)"
        ]
      },
      ", 27.08.1858, Cuneo, Piemonte (Италия) – 20.04.1932, Turin (Италия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_ramsey"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Рамсей,_Фрэнк_Пламптон"
        },
        "children": [
          "Рамсей Ф. (Frank Plumpton Ramsey)"
        ]
      },
      ", 22.02.1903, Cambridge, Cambridgeshire (Англия) – 19.01.1930, London (Англия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_russell"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Рассел,_Бертран"
        },
        "children": [
          "Рассел Б. (Bertrand Arthur William Russell)"
        ]
      },
      ", 18.05.1872, Ravenscroft, Trelleck, Monmouthshire (Уэльс, Великобритания) – 02.02.1970, Penrhyndeudraeth, Merioneth (Уэльс, Великобритания)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_tarski"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Тарский,_Альфред"
        },
        "children": [
          "Тарский А. (Alfred Tarski)"
        ]
      },
      ", 14.01.1901, Warsaw (Россия, ныне Польша) – 26.10.1983, Berkeley, California (США)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_fraenkel"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Френкель,_Абрахам"
        },
        "children": [
          "Френкель А. А. (Adolf Abraham Halevi Fraenkel)"
        ]
      },
      ", 17.02.1891, Munich (Германия) – 15.10.1965, Jerusalem (Израиль)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_fubini"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Фубини,_Гвидо"
        },
        "children": [
          "Фубини Г. (Guido Fubini)"
        ]
      },
      ", 19.01.1879, Venice (Италия) – 06.06.1943, New York (США)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_zermelo"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Цермело,_Эрнст"
        },
        "children": [
          "Цермело Э. (Ernst Friedrich Ferdinand Zermelo)"
        ]
      },
      ", 27.07.1871, Berlin (Германия) – 21.05.1953, Freiburg im Breisgau (Германия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_zorn"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Цорн,_Макс_Август"
        },
        "children": [
          "Цорн М. (Max August Zorn)"
        ]
      },
      ", 06.06.1906, Krefeld (Германия) – 09.03.1993, Bloomington, Indiana (США)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_schroder"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Шрёдер,_Эрнст"
        },
        "children": [
          "Шрёдер Э. (Friedrich Wilhelm Karl Ernst Schröder)"
        ]
      },
      ", 25.11.1841, Mannheim (Германия) – 16.06.1902, Karlsruhe (Германия)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "name_hermite"
    },
    "children": [
      "\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Эрмит,_Шарль"
        },
        "children": [
          "Эрмит Ш. (Charles Hermite)"
        ]
      },
      ", 24.12.1822, Dieuze, Lorraine (Франция) – 14.01.1901, Paris (Франция)\n"
    ]
  },
  "\n",
  "\n\n"
]
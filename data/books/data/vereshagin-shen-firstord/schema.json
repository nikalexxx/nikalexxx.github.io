[
  {
    "name": "counter",
    "props": {
      "start": "chapter",
      "initial": 1
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "start": "problem"
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "start": "theorem",
      "initial": 1
    },
    "children": []
  },
  "ЛЕКЦИИ ПО МАТЕМАТИЧЕСКОЙ ЛОГИКЕ И ТЕОРИИ АЛГОРИТМОВ\n\n\n",
  {
    "name": "authors",
    "props": {},
    "children": [
      {
        "name": "link",
        "props": {
          "href": "http://lpcs.math.msu.su/~ver/"
        },
        "children": [
          "Н. К. Верещагин"
        ]
      },
      ",\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Шень,_Александр_Ханиевич"
        },
        "children": [
          "А.Шень"
        ]
      },
      "\n"
    ]
  },
  "\n",
  {
    "name": "title",
    "props": {},
    "children": [
      "Языки и исчисления"
    ]
  },
  "\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Электронная версия в процессе адаптации, это предупреждение будет убрано по окончанию (Николаичев А.С.)"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 2
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "end": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "end": "table"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "use": "chapter"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "table"
        },
        "children": []
      },
      ". ",
      "Логика высказываний"
    ]
  },
  "\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Высказывания и операции"
    ]
  },
  "\n\n«Если число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " рационально, то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " — алгебраическое число.\nНо оно не алгебраическое. Значит, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " не рационально.»\nМы не обязаны знать, что такое число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  ", какие числа называют рациональными и какие алгебраическими, чтобы признать, что это рассуждение правильно — в том смысле, что из двух сформулированных посылок действительно вытекает заключение.\nТакого рода ситуации — когда некоторое утверждение верно независимо от смысла входящих в него высказываний — составляют предмет ",
  {
    "name": "em",
    "props": {},
    "children": [
      "логики высказываний"
    ]
  },
  ".\n",
  "",
  "\n\n\nТакое начало (особенно если учесть, что курс логики входил в программу философского факультета, где также изучалась «диалектическая логика») настораживает, но на самом деле наши\n",
  "",
  "\nрассмотрения будут иметь вполне точный математический характер, хотя мы начнём с неформальных мотивировок.\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Высказывания"
    ]
  },
  "",
  " могут быть\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "истинными"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nи ",
  {
    "name": "em",
    "props": {},
    "children": [
      "ложными"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nНапример, «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{16}+1"
    ]
  },
  " — простое число» — истинное высказывание, а «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{32}+1"
    ]
  },
  " — простое число» — ложное (это число делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "641"
    ]
  },
  ").\nПро высказывание «существует бесконечно много простых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p+2"
    ]
  },
  " — также простое» никто не берётся сказать наверняка, истинно оно или ложно.\nЗаметим, что «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  "» в этом смысле не является высказыванием, пока не сказано, чему равно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "; при разных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " получаются разные высказывания, одни истинные (при чётном ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "), другие — ложные (при нечётном ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ").\n\n\nВысказывания можно соединять друг с другом с помощью «логических связок».\n",
  "",
  "\n",
  "",
  "\nЭти связки имеют довольно странные, но традиционные названия и обозначения (табл. ",
  {
    "name": "label",
    "props": {
      "ref": "logic-connectives-names"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "logic-connectives-names_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "table",
    "props": {
      "align": "center",
      "key": "logic-connectives-names",
      "name": "Логические связки, обозначения и названия."
    },
    "children": [
      "\n",
      {
        "name": "row",
        "props": {
          "head": true
        },
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " связка "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " обозначение "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " название"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " и ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\& B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\land B"
                ]
              },
              "\n\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\texttt{ and }B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "конъюнкция\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " или ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\lor B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\texttt{ or }B"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " дизъюнкция\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              "не ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " неверно\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\lnot A"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\sim\\!A"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\overline{A} "
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\texttt{not} A"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\nотрицание\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              "из ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " следует ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\nесли ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              ", то ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " влечёт ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              " — следствие ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\rightarrow B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\Rightarrow B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\supset B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\texttt{if }A\\texttt{ then }B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\nимпликация\n\nследование\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\n",
      "",
      "\n",
      "",
      "\n",
      {
        "name": "area",
        "props": {
          "inline": true
        },
        "children": [
          "Таблица ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "logic-connectives-names_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "last": "chapter"
                },
                "children": []
              },
              ".",
              {
                "name": "counter",
                "props": {
                  "use": "table",
                  "key": "logic-connectives-names_counter"
                },
                "children": []
              }
            ]
          },
          ". ",
          "Логические связки, обозначения и названия."
        ]
      }
    ]
  },
  "\n\n\nОтметим также, что в импликации ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\Rightarrow B"
    ]
  },
  " высказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "посылкой"
    ]
  },
  ",\n",
  "",
  "\nили ",
  {
    "name": "em",
    "props": {},
    "children": [
      "антецедентом импликации"
    ]
  },
  ",\n",
  "",
  "\nа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " — ",
  {
    "name": "em",
    "props": {},
    "children": [
      "заключением"
    ]
  },
  ",\n",
  "",
  "\nили ",
  {
    "name": "em",
    "props": {},
    "children": [
      "консеквентом"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\n\n\nГоворят также, что высказывание имеет ",
  {
    "name": "em",
    "props": {},
    "children": [
      "истинностное значение"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " (истина),\n",
  "",
  "\nесли оно истинно, или ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " (ложь),\n",
  "",
  "\nесли оно ложно.\nИногда вместо ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " употребляется буква ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "T"
    ]
  },
  " (true) или число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nа вместо ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " — буква ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "F"
    ]
  },
  " (false) или число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  ".\n(С первого взгляда идея произвольным образом выбрать числа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " кажется дикой — какая бы польза могла быть от, скажем, сложения истинностных значений?\nУдивительным образом в последние годы обнаружилось, что такая польза есть, и если оперировать с истиной и ложью как элементами конечного поля, можно получить много неожиданных результатов.\nНо это выходит за рамки нашей книги.)\n\n\nЛогические связки позволяют составлять сложные высказывания из простых.\nПри этом истинность составного высказывания определяется истинностью его частей в соответствии с таблицей ",
  {
    "name": "label",
    "props": {
      "ref": "truth-tables"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "truth-tables_link"
        },
        "children": []
      }
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "truth-tables"
    },
    "children": [
      {
        "name": "table",
        "props": {},
        "children": [
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A\\land B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A\\lor B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A \\to B"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n"
        ]
      },
      "\n\n",
      {
        "name": "table",
        "props": {},
        "children": [
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "\\lnot A"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  }
                ]
              }
            ]
          },
          "\n"
        ]
      },
      "\n\n",
      {
        "name": "area",
        "props": {
          "position": "center"
        },
        "children": [
          {
            "name": "format.small",
            "props": {},
            "children": [
              {
                "name": "format.i",
                "props": {},
                "children": [
                  "Таблица ",
                  {
                    "name": "area",
                    "props": {
                      "inline": true,
                      "key": "truth-tables_link"
                    },
                    "children": [
                      {
                        "name": "counter",
                        "props": {
                          "last": "chapter"
                        },
                        "children": []
                      },
                      ".",
                      {
                        "name": "counter",
                        "props": {
                          "use": "table"
                        },
                        "children": []
                      }
                    ]
                  },
                  ". Таблицы истинности для логических связок"
                ]
              },
              "\n"
            ]
          }
        ]
      }
    ]
  },
  "\n\nТе же правила можно изложить словесно.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\land B"
    ]
  },
  " истинно, если оба высказывания ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " истинны.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\lor B"
    ]
  },
  " истинно, если хотя бы одно из высказываний ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " истинно.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to B"
    ]
  },
  " ложно в единственном случае: если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " истинно, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " ложно.\nНаконец, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  " истинно в том и только том случае, когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " ложно.\n\n\nИз всех связок больше всего вопросов вызывает импликация.\nВ самом деле, не очень понятно, почему надо считать, скажем, высказывания «если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=5"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=4"
    ]
  },
  "» и «если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=5"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "3\\times 3=1"
    ]
  },
  "» истинными.\n(Именно так говорят наши таблицы: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "Л\\toИ = Л\\toЛ = И"
    ]
  },
  ".)\nНа самом деле  в таком определении есть свой резон.\nВсе согласны, что если число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ", то оно делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\nЭто означает, что высказывание\n\n\n(",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\to"
    ]
  },
  " (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ")\n\n\nистинно при всех ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ".\n\nПодставим сюда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=5"
    ]
  },
  ": обе части ложны, а утверждение в целом истинно.\nПри ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=6"
    ]
  },
  " посылка импликации ложна, а заключение истинно, и вся импликация истинна.\nНаконец, при ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=8"
    ]
  },
  " посылка и заключение истинны и импликация в целом истинна.\nС другой стороны, обратное утверждение (если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ") неверно, и число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " является контрпримером.\nПри этом посылка импликации истинна, заключение ложно, и сама импликация ложна.\nТаким образом, если считать, что истинность импликации определяется истинностью её частей (а не наличием между ними каких-то причинно-следственных связей), то все строки таблицы истинности обоснованы.\nЧтобы подчеркнуть такое узко-формальное понимание импликации, философски настроенные логики называют её «материальной импликацией».\n\n\nТеперь от неформальных разговоров перейдём к определениям.\nЭлементарные высказывания (из которых составляются более сложные) мы будем обозначать маленькими латинскими буквами и называть ",
  {
    "name": "em",
    "props": {},
    "children": [
      "пропозициональными переменными"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nИз них строятся ",
  {
    "name": "em",
    "props": {},
    "children": [
      "пропозициональные формулы"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nпо таким правилам:\n\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Всякая пропозициональная переменная есть формула."
        ]
      },
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " — пропозициональная формула, то ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot A"
            ]
          },
          " — пропозициональная формула."
        ]
      },
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          " — пропозициональные формулы, то ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\land B)"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\lor B)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to B)"
            ]
          },
          " — пропозициональные формулы."
        ]
      },
      "\n\n"
    ]
  },
  "\n\nМожно ещё сказать так: формулы образуют минимальное множество, обладающее указанными свойствами (слово «минимальное» здесь существенно: ведь если бы мы объявили любую последовательность переменных, скобок и связок формулой, то эти три свойства были бы тоже выполнены).\n\n\nПусть формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " содержит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " пропозициональных переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p_1,p_2,\\dots,p_n"
    ]
  },
  ".\nЕсли подставить вместо этих переменных истинностные значения (",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " или ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  "), то по таблицам можно вычислить истинностное значение формулы в целом.\nТаким образом, формула задаёт некоторую функцию от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов, каждый из которых может принимать значения ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " и ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  ".\nЗначения функции также лежат в множестве {",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  ", ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  "}, которое мы будем обозначать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B} "
    ]
  },
  ".\nМы будем следовать уже упоминавшейся традиции и отождествлять ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " с единицей, а ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " — с нулём, тем самым ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B} "
    ]
  },
  " есть ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\{0,1\\} "
    ]
  },
  ".\nФормула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " задаёт отображение типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}^n\\to\\Bbb{B} "
    ]
  },
  ".\nТакие отображения называют также ",
  {
    "name": "em",
    "props": {},
    "children": [
      "булевыми функциями ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Пример"
    ]
  },
  ". Рассмотрим формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\land (q\\land \\lnot r))"
    ]
  },
  ".\nОна истинна в единственном случае — когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинны, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "r"
    ]
  },
  " ложно (см. таблицу ",
  {
    "name": "label",
    "props": {
      "ref": "example-conjunct"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "example-conjunct_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "table",
    "props": {
      "key": "example-conjunct"
    },
    "children": [
      {
        "name": "row",
        "props": {
          "head": true
        },
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "p"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "q"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "r"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\lnot r"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(q \\land \\lnot r)"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(p\\land(q\\land\\lnot r))"
                ]
              },
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\nТаблица ",
      {
        "name": "area",
        "props": {
          "inline": true,
          "key": "example-conjunct_link"
        },
        "children": [
          {
            "name": "counter",
            "props": {
              "last": "chapter"
            },
            "children": []
          },
          ".",
          {
            "name": "counter",
            "props": {
              "use": "table"
            },
            "children": []
          }
        ]
      },
      ". Таблица истинности для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(p\\land(q\\land \\lnot r))"
        ]
      },
      ".\n"
    ]
  },
  "\n\nНекоторые формулы выражают логические законы — составные высказывания, истинные независимо от смысла их частей.\nТакие формулы (истинные при всех значениях входящих в них переменных) называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "тавтологиями"
    ]
  },
  ".\n",
  "",
  "\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Пример"
    ]
  },
  ". Формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p \\land q)\\to p)"
    ]
  },
  " является тавтологией (это можно проверить, например, составив таблицу).\nОна выражает такой логический закон: из конъюнкции утверждений следует первое из них.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Как выглядит симметричное утверждение для дизъюнкции и какая формула его выражает?\n"
    ]
  },
  "\n\n\nДве формулы называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "эквивалентными"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nесли они истинны при одних и тех же значениях переменных (другими словами, если они задают одну и ту же булеву функцию).\nНапример, легко проверить, что формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p \\land (p\\to q))"
    ]
  },
  " истинна лишь при ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p=q=И"
    ]
  },
  ", и потому эквивалентна формуле ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\land q)"
    ]
  },
  ".\n\n\nРассмотрим формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\land q)\\lor q)"
    ]
  },
  ".\nОна истинна, если переменная ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинна, и ложна, если переменная ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " ложна.\nХотелось бы сказать, что она эквивалентна формуле ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  ", но тут есть формальная трудность: она содержит две переменные и потому задаёт функцию от двух аргументов (типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}\\times\\Bbb{B}\\to\\Bbb{B} "
    ]
  },
  "), в то время как формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " задаёт функцию одного аргумента.\nМы не будем обращать на это внимания и будем считать эти формулы эквивалентными.\nВообще, если есть список переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p_1,\\dots,p_n"
    ]
  },
  ", содержащий все переменные некоторой формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " (и, возможно, ещё какие-то переменные), можно считать, что формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " задаёт функцию от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов, возможно, на деле зависящую не от всех аргументов (постоянную по некоторым аргументам)\n\n\nПосле сделанных оговорок легко проверить следующий факт: формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\psi"
    ]
  },
  " эквивалентны тогда и только тогда, когда формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((\\varphi\\to\\psi)\\land{(\\psi\\to\\varphi))} "
    ]
  },
  " является тавтологией.\nИспользуя сокращение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\leftrightarrow q)"
    ]
  },
  " для ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\to q)\\land{(q\\to p)})"
    ]
  },
  ", можно записывать утверждения об эквивалентности формул в виде тавтологий.\nВот несколько таких эквивалентностей:\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "Формулы\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{aligned}\n(p\\land q) &\\leftrightarrow (q \\land p);\\\\\n((p\\land q) \\land r) &\\leftrightarrow (p\\land (q \\land r));\\\\\n(p\\lor q) &\\leftrightarrow (q \\lor p);\\\\\n((p\\lor q) \\lor r) &\\leftrightarrow (p\\lor (q \\lor r));\\\\\n(p\\land(q\\lor r)) &\\leftrightarrow ((p\\land q)\\lor (p\\land r));\\\\\n(p\\lor(q\\land r)) &\\leftrightarrow ((p\\lor q)\\land (p\\lor r));\\\\\n\\lnot(p\\land q) &\\leftrightarrow (\\lnot p\\lor \\lnot q);\\\\\n\\lnot(p\\lor q) &\\leftrightarrow (\\lnot p\\land \\lnot q);\\\\\n(p\\lor (p \\land q)) &\\leftrightarrow p;\\\\\n(p\\land (p \\lor q)) &\\leftrightarrow p;\\\\\n(p\\to q) &\\leftrightarrow (\\lnot q\\to \\lnot p);\\\\\np &\\leftrightarrow \\lnot\\lnot p\n\\end{aligned}\n"
        ]
      },
      "\nявляются тавтологиями.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервые четыре эквивалентности выражают коммутативность и ассоциативность конъюнкции и дизъюнкции.\nПроверим, например, вторую: левая и правая части истинны в единственном случае (когда все переменные истинны), и потому эквивалентны.\n(Для дизъюнкции удобнее смотреть, когда она ложна.)\n\nДве следующие эквивалентности означают  дистрибутивность — заметим, что в отличие от сложения и умножения в кольцах здесь верны оба свойства дистрибутивности.\nПроверить эквивалентность легко, если отдельно рассмотреть случаи истинного и ложного ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ".\n\n\nСледующие два свойства, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "законы Де Моргана"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nлегко проверить, зная, что конъюнкция истинна, а дизъюнкция ложна лишь в одном случае.\nЭти свойства иногда выражают словами: «конъюнкция двойственна дизъюнкции».\n\n\nДалее следуют два очевидных ",
      {
        "name": "em",
        "props": {},
        "children": [
          "закона поглощения"
        ]
      },
      "\n",
      "",
      "\n(один из них мы уже упоминали).\n\n\nЗа ними идёт правило ",
      {
        "name": "em",
        "props": {},
        "children": [
          "контрапозиции"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nкоторое говорит, в частности, что утверждения «если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " совершенно, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " чётно» и «если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " нечётно, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " несовершенно»  равносильны.\nХотя оно и очевидно проверяется с помощью таблиц истинности, с ним связаны любопытные парадоксы.\nВот один из них.\n\n\nБиолог А выдвинул гипотезу: все вороны чёрные.\nПроверяя её, он вышел во двор и обнаружил на дереве ворону.\nОна оказалось чёрной.\nБиолог А радуется — гипотеза подтверждается.\nБиолог Б переформулировал гипотезу так: все не-чёрные предметы — не вороны (применив наше правило контрапозиции) и не стал выходить во двор, а открыл холодильник и нашёл там оранжевый предмет.\nОн оказался апельсином, а не вороной.\nБиолог Б обрадовался — гипотеза подтверждается — и позвонил биологу А.\nТот удивляется — у него тоже есть апельсин в холодильнике, но с его точки зрения никакого отношения к его гипотезе апельсин не имеет,",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\dots"
        ]
      },
      "\n\n\nДругой парадокс: с точки зрения формальной логики утверждения «кто не с нами, тот против нас» и «кто не против нас, тот с нами» равносильны.\n\n\nПоследнее (и очевидное) правило ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\leftrightarrow \\lnot\\lnot p"
        ]
      },
      " называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "снятием двойного отрицания"
        ]
      },
      ".\n",
      "",
      "\n",
      " ᐅ"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Перечисленные эквивалентности соответствуют свойствам операций на множествах: например, первая гарантирует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P\\cap Q=Q\\cap P"
        ]
      },
      " для любых множеств ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      ".\nКакие утверждения соответствуют остальным эквивалентностям?\n"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Две формулы, содержащие только переменные и связки ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot"
        ]
      },
      ", эквивалентны.\nДокажите, что они останутся эквивалентными, если всюду заменить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      " и наоборот.\n"
    ]
  },
  "\n\nДалеко не все тавтологии имеют ясный интуитивный смысл.\nНапример, формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\to q)\\lor(q\\to p)"
    ]
  },
  " является тавтологией (если одно из утверждений ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " ложно, то из него следует всё, что угодно; если оба истинны, то тем более формула истинна), хотя и отчасти противоречит нашей интуиции — почему, собственно, из двух никак не связанных утверждений одно влечёт другое?\nЕщё более загадочна тавтология\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n((p\\to q)\\to p)\\to p\n"
    ]
  },
  "\n(хотя её ничего не стоит проверить с помощью таблиц истинности).\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Отступление о пользе скобок"
    ]
  },
  ".\n",
  "",
  "\nНа самом деле наше определение истинности содержит серьёзный пробел.\nЧтобы обнаружить его, зададим себе вопрос: зачем нужны скобки в формулах?\nПредставим себе, что мы изменим определение формулы, и будем говорить, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "P \\land Q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "P \\lor Q"
    ]
  },
  " являются формулами для любых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "Q"
    ]
  },
  ".\nОстанутся ли наши рассуждения в силе?\n\n\nЛегко понять, что мы столкнёмся с трудностью при определении булевой функции, соответствующей формуле.\nВ этом определении мы подставляли нули и единицы на место переменных и затем вычисляли значение формулы с помощью таблиц истинности для связок.\nНо теперь, когда мы изменили определение формулы, формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land q \\lor r"
    ]
  },
  " может быть получена двумя способами — из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "r"
    ]
  },
  " с помощью операции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor"
    ]
  },
  " и из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q\\lor r"
    ]
  },
  " с помощью операции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land"
    ]
  },
  ".\nЭти два толкования дадут разный результат при попытке вычислить значение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0 \\land 0 \\lor 1"
    ]
  },
  ".\n\n\nИз сказанного ясно, что скобки нужны, чтобы гарантировать однозначность синтаксического разбора формулы.\nТочнее говоря, верно такое утверждение:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "однозначность разбора"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "однозначность разбора",
          ")",
          ". "
        ]
      },
      "",
      "\nПропозициональная формула, не являющаяся переменной, может быть представлена ровно в одном из четырёх видов ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\lor B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " или ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " — некоторые формулы, причём ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " (в первых трёх случаях) восстанавливаются однозначно.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nФормальное доказательство можно провести так: назовём ",
      {
        "name": "em",
        "props": {},
        "children": [
          "скобочным итогом"
        ]
      },
      "\n",
      "",
      "\nразницу между числом открывающихся и закрывающихся скобок.\nИндукцией по построению формулы легко доказать такую лемму:\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма"
        ]
      },
      ". Скобочный итог формулы равен нулю.\nСкобочный итог любого начала формулы неотрицателен и равен нулю, лишь если это начало совпадает со всей формулой, пусто или состоит из одних символов отрицания.\n\nСлова «индукцией по построению» означают, что мы проверяем утверждение для переменных, а также доказываем, что если оно верно для формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ", то оно верно и для формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\lor B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ".\n\nПосле того как лемма доказана, разбор формулы проводится так: если она начинается с отрицания, то может быть образована лишь по третьему правилу.\nЕсли же она начинается со скобки, то надо скобку удалить, а потом искать непустое начало, имеющее нулевой скобочный итог и не оканчивающееся на знак логической операции.\nТакое начало единственно (как легко проверить, используя лемму).\nЭто начало и будет первой частью формулы.\nТем самым формула разбирается однозначно.\n",
      " ᐅ"
    ]
  },
  "\n\n\nНет смысла вдаваться в подробности этого (несложного) рассуждения: вообще-то алгоритмы разбора формул — это отдельная большая и практически важная тема (в первую очередь в связи с компиляторами).\nПриведённый нами алгоритм далеко не оптимален.\nС другой стороны, мы вообще можем обойти эту проблему, потребовав, чтобы при записи формул левая и правая скобки, окружающие формулу, связывались линией — тогда однозначность разбора формулы не вызывает вопросов, и больше ничего нам не надо.\n\n\nВ дальнейшем мы будем опускать скобки, если они либо не играют роли (например, можно написать конъюнкцию трёх членов, не указывая порядок действий в силу ассоциативности), либо ясны из контекста.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Польский логик Лукасевич",
      "",
      " предлагал обходиться без скобок, записывая в формулах сначала знак операции, а потом операнды (без пробелов и разделителей).\nНапример, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)\\times(c+(d\\times e))"
        ]
      },
      " в его обозначениях запишется как ",
      {
        "name": "math",
        "props": {},
        "children": [
          "{{\\times}{+}ab{+}c{\\times}{d} {e}}"
        ]
      },
      ".\nЭту запись ещё называют ",
      {
        "name": "em",
        "props": {},
        "children": [
          "польской"
        ]
      },
      "\n",
      "",
      "\nзаписью.\n",
      {
        "name": "em",
        "props": {},
        "children": [
          "Обратная"
        ]
      },
      " польская запись отличается от неё тем, что знак операции идёт после операндов.\nПокажите, что в обоих случаях порядок действий восстанавливается однозначно.\n"
    ]
  },
  "\n",
  "\n\n",
  {
    "name": "header",
    "props": {
      "key": "complete-connectives",
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Полные системы связок"
    ]
  },
  "\n\n\nРассматриваемая нами система пропозициональных связок (в неё входят ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\to"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot"
    ]
  },
  ") ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полна"
    ]
  },
  "\n",
  "",
  "\nв следующем смысле:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "Полнота системы связок",
      "key": "completeness-connectives"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "completeness-connectives_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "completeness-connectives_link"
            },
            "children": []
          },
          " (",
          "Полнота системы связок",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nЛюбая булева функция (с любым числом аргументов) может быть записана в виде пропозициональной формулы.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПроще всего пояснить это на примере.\nПусть, например, булева функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p,q,r)"
        ]
      },
      " задана таблицей ",
      {
        "name": "label",
        "props": {
          "ref": "sample-truth-table"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "sample-truth-table_link"
            },
            "children": []
          }
        ]
      },
      ".\n\n\n",
      {
        "name": "table",
        "props": {
          "key": "sample-truth-table"
        },
        "children": [
          "\n",
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "p"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "q"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "r"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "\\varphi(p,q,r)"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n\n",
          {
            "name": "area",
            "props": {
              "align": "center"
            },
            "children": [
              {
                "name": "math",
                "props": {
                  "block": true
                },
                "children": [
                  "\n\\begin{aligned}\n     (\\lnot p \\land \\lnot q \\land \\lnot r) &\\lor\\\\\n  \\lor   (\\lnot p \\land q \\land r) &\\lor\\\\\n  \\lor   (p \\land q       \\land r)& \\phantom{\\lor} \\\\\n\\end{aligned}\n"
                ]
              },
              "\n"
            ]
          },
          "\n\nТаблица ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "sample-truth-table_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "last": "chapter"
                },
                "children": []
              },
              ".",
              {
                "name": "counter",
                "props": {
                  "use": "table"
                },
                "children": []
              }
            ]
          },
          ". Булева функция и задающая её формула.\n"
        ]
      },
      "\n\n\nВ таблице есть три строки с единицами в правой колонке — три случая, когда булева функция истинна (равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ").\nНапишем три конъюнкции, каждая из которых покрывает один случай (а в остальных строках ложна), и соединим их дизъюнкцией.\nНужная формула построена.\n\n\nЯсно, что аналогичная конструкция применима для любой таблицы (с любым числом переменных).\n",
      " ᐅ"
    ]
  },
  "\n\n\nДля формул подобного вида есть специальное название: формулы в ",
  {
    "name": "em",
    "props": {},
    "children": [
      "дизъюнктивной нормальной форме"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nБолее подробно:\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "литералом"
    ]
  },
  "\n",
  "",
  "\nназывается переменная или отрицание переменной,\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "конъюнктом"
    ]
  },
  "\n",
  "",
  "\nназывается произвольная конъюнкция литералов, а дизъюнктивной нормальной формой называется дизъюнкция конъюнктов.\nВ нашем случае в каждый конъюнкт входит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " литералов (где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " — число переменных), а число конъюнктов равно числу строк с единицами и может меняться от нуля (тогда, правда, получается не совсем формула, а «пустая дизъюнкция», и её можно заменить какой-нибудь всегда ложной формулой типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land \\lnot p"
    ]
  },
  ") до ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^n"
    ]
  },
  " (если булева функция всегда истинна).\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДлина построенной в доказательстве теоремы ",
      "",
      " формулы зависит от числа единиц: формула будет короткой, если единиц в таблице мало.\nА как написать (сравнительно) короткую формулу, если в таблице мало нулей, а в основном единицы?\n"
    ]
  },
  "\n\n\nИногда полезна двойственная ",
  {
    "name": "em",
    "props": {},
    "children": [
      "конъюнктивная нормальная форма"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nкоторая представляет собой конъюнкцию ",
  {
    "name": "em",
    "props": {},
    "children": [
      "дизъюнктов"
    ]
  },
  ".\n",
  "",
  "\nКаждый дизъюнкт состоит из литералов, соединённых дизъюнкциями.\nТеорему ",
  "",
  " можно теперь усилить так:\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "dnf-cnf"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "dnf-cnf_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "dnf-cnf_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nВсякая булева функция может быть выражена формулой, находящейся в дизъюнктивной нормальной форме, а также формулой, находящейся в конъюнктивной нормальной форме.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервая часть утверждения уже доказана.\nВторая часть аналогична первой, надо только для каждой строки с нулём написать подходящий дизъюнкт.\n\n\nМожно также представить функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot \\varphi"
        ]
      },
      " в дизъюнктивной нормальной форме, а затем воспользоваться законами Де Моргана,\n",
      "",
      "\nчтобы внести отрицание внутрь.\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Проведите второй вариант рассуждения подробно."
    ]
  },
  "\n\n\nВообще говоря, определение нормальной формы не требует, чтобы в каждом конъюнкте (или дизъюнкте) встречались все переменные.\n(Повторять переменную больше одного раза смысла нет; если, например, переменная и её отрицание входят в одну конъюнкцию, то эта конъюнкция всегда ложна и её можно выбросить.)\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Приведите пример булевой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "~аргументов, у которой любая дизъюнктивная или конъюнктивная нормальная форма содержит лишь члены длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n(Указание: рассмотрите функцию, которая меняет своё значение при изменении значения любой переменной.)\n"
    ]
  },
  "\n\n\nЗаметим, что при доказательстве теоремы ",
  "",
  " мы обошлись без импликации.\nЭто и не удивительно, так как она выражается через дизъюнкцию и отрицание:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\to q) \\ \\leftrightarrow \\ (\\lnot p \\lor q)\n"
    ]
  },
  "\n(проверьте!).\nМы могли бы обойтись только конъюнкцией и отрицанием, так как ",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\lor q) \\ \\leftrightarrow \\ \\lnot(\\lnot p \\land \\lnot q),\n"
    ]
  },
  "\nили только дизъюнкцией и отрицанием, так как ",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\land q) \\ \\leftrightarrow \\ \\lnot(\\lnot p \\lor \\lnot q)\n"
    ]
  },
  "\n(обе эквивалентности вытекают из законов Де Моргана; их легко проверить и непосредственно).\nКак говорят, система связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land, \\lnot"
    ]
  },
  ", а также система связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor, \\lnot"
    ]
  },
  " являются ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полными"
    ]
  },
  ".\n",
  "",
  "\n(По определению это означает, что с их помощью можно записать любую булеву функцию.)\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Докажите, что система связок ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot, \\to"
        ]
      },
      " полна.\n(Указание: как записать через них дизъюнкцию?)\n"
    ]
  },
  "\n\n\nА вот без отрицания обойтись нельзя.\nСистема связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land, \\lor,\\to"
    ]
  },
  " неполна — и по очень простой причине: если все переменные истинны, то любая их комбинация, содержащая только указанные связки, истинна.\n(Как говорят, все эти связки «сохраняют единицу».)\n",
  "",
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nЛюбая формула, составленная только с помощью связок ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      ", задаёт монотонную булеву функцию ",
      "",
      "\n",
      "",
      "\n(в том смысле, что от увеличения значения любого из аргументов значение функции может только возрасти — или остаться прежним).\nПокажите, что верно и обратное: любая монотонная булева функция либо постоянна (всюду истинна или всюду ложна), либо может быть выражена формулой, содержащей только ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi\\to\\psi"
        ]
      },
      " — тавтология.\nПокажите, что найдётся формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\tau"
        ]
      },
      ", которая включает в себя только общие для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " переменные, для которой формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\varphi\\to\\tau)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\tau\\to\\psi)"
        ]
      },
      " являются тавтологиями.\n(Более общий вариант этого утверждения, в котором рассматриваются формулы с кванторами, называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "леммой Крейга"
        ]
      },
      ".)\n",
      "",
      "\n",
      "",
      "\n"
    ]
  },
  "\n\n\nВ принципе мы не обязаны ограничиваться четырьмя рассмотренными связками.\nЛюбая булева функция может играть роль связки.\nНапример, можно рассмотреть связку ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p \\texttt{ notand } q)"
    ]
  },
  ",\n",
  "",
  "\nзадаваемую эквивалентностью\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p \\texttt{ notand } q) \\ \\leftrightarrow \\ \\lnot(p\\land q)\n"
    ]
  },
  "\n(словами: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\texttt{ notand }q)"
    ]
  },
  " ложно, лишь если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинны).\nЧерез неё выражается отрицание (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p \\texttt{ notand }p"
    ]
  },
  "), после чего можно выразить конъюнкцию, а затем, как мы знаем, и вообще любую функцию.\n(Знакомые с цифровыми логическими схемами малого уровня интеграции хорошо знакомы с этим утверждением: достаточно большой запас схем И-НЕ позволяет реализовать любую требуемую зависимость выхода от входов.)\n\n\nДругая интересная полная система связок — сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ", конъюнкция и константа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " (которую можно считать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  "-арной связкой, задающей функцию от нуля аргументов).\nПредставленные в этой системе булевы функции становятся полиномами с коэффициентами в кольце вычетов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\nИдея рассматривать булевы функции как полиномы (оказавшаяся неожиданно плодотворной в последние годы) была высказана в 1927~г. российским математиком Иваном Ивановичем Жегалкиным.\n",
  "",
  "\n\n\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "мономом"
    ]
  },
  "\n",
  "",
  "\nконъюнкцию любого набора переменных или константу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " (которую естественно рассматривать как конъюнкцию нуля переменных).\nНазвание это естественно, так как при наших соглашениях (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " обозначает истину, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " — ложь) конъюнкция соответствует умножению.\n\n\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полиномом"
    ]
  },
  "\n",
  "",
  "\nсумму таких мономов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " (это значит, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0\\oplus0 =0"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0\\oplus 1=1\\oplus 0=1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1\\oplus1=0"
    ]
  },
  ").\nЯсно, что два повторяющихся монома можно сократить (ведь сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  "), так что будем рассматривать только полиномы без повторяющихся мономов.\nПри этом, естественно, порядок членов в мономе (как и порядок мономов в полиноме) роли не играет, их можно переставлять.\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "о полиномах Жегалкина",
      "key": "polynomials-boolean-functions"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "polynomials-boolean-functions_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "polynomials-boolean-functions_link"
            },
            "children": []
          },
          " (",
          "о полиномах Жегалкина",
          ")",
          ". "
        ]
      },
      "",
      "\nВсякая булева функция однозначно представляется таким полиномом."
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nСуществование искомого полинома следует из теоремы ",
      "",
      ", так как конъюнкция есть умножение, отрицание — прибавление единицы, а дизъюнкцию можно через них выразить (получится ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p+q+pq"
        ]
      },
      ").\nНадо только заметить, что степени не нужны: переменные принимают значения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", так что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x^n"
        ]
      },
      " можно заменить на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      ".\n\n\nМожно также сослаться на известное из алгебры утверждение о том, что всякая функция с аргументами из конечного поля (в данном случае это двухэлементное поле вычетов по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") задаётся полиномом.\n(Так получается новое доказательство теоремы ",
      "",
      ".)\n\n\nДалее можно заметить, что полиномов столько же, сколько булевых функций, а именно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^n} "
        ]
      },
      ".\nВ самом деле, булева функция может принимать любое из двух значений в каждой из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " точек булева куба ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}^n"
        ]
      },
      ", а многочлен может включать или не включать любой из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " мономов.\n(Мономов ровно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      ", потому что каждый моном включает или не включает любую из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменных.)\nПоэтому избытка полиномов нет, и если любая функция представима полиномом, то единственным образом.\n\n\nМожно и не ссылаться на сведения из алгебры и теорему ",
      "",
      ", а дать явную конструкцию.\nЭто удобно сделать индукцией по ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\nПусть мы уже умеем представлять любую булеву функцию от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n-1"
        ]
      },
      " аргументов с помощью полинома.\nТогда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p_1,\\dots,p_n)"
        ]
      },
      " можно представить как\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\varphi(p_1,\\dots,p_n) =\n\\varphi(0, p_2,\\dots,p_{n})\n+[\\varphi(0,p_2,\\dots,p_{n})+\n\\varphi(1,p_2,\\dots,p_{n})]p_1\n"
        ]
      },
      "\n(проверьте).\nОстаётся заметить, что правую часть можно представить полиномом по предположению индукции.\n\n\nДля единственности также есть другое доказательство: пусть два многочлена (имеющие степень ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      " по каждой переменной) равны при всех значениях переменных.\nТогда их сумма (или разность —\nвычисления происходят по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") является ненулевым многочленом (содержит какие-то мономы), но тождественно равна нулю.\nТак не бывает, и это легко доказать по индукции.\nВ самом деле, любой многочлен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A(p_1,\\dots,p_n)"
        ]
      },
      " можно представить в виде\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\nA(p_1,\\dots,p_n)=B(p_2,\\dots,p_n)+p_1C(p_2,\\dots,p_n),\n"
        ]
      },
      "\nгде ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " — многочлены от меньшего числа переменных.\nПодставляя сначала ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1=0"
        ]
      },
      ", а затем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1=1"
        ]
      },
      ", убеждаемся,\nчто многочлены ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " равны нулю во всех точках, и потому (согласно предположению индукции) равны нулю как многочлены (не содержат мономов).\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " — произвольное поле.\n",
      "",
      "\nНазовём ",
      {
        "name": "em",
        "props": {},
        "children": [
          "мультилинейной"
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\nфункцией полином от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменных с коэффициентами из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ", в котором все показатели степеней равны либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\n(Таким образом, каждый моном в ней есть произведение коэффициента и некоторого набора переменных без повторений.) Будем рассматривать ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}=\\{0,1\\} "
        ]
      },
      " как подмножество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\nДокажите, что всякая булева функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}^n\\to\\Bbb{B} "
        ]
      },
      " однозначно продолжается до мультилинейной функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F^n\\to F"
        ]
      },
      ", и коэффициенты мультилинейной функции можно считать целыми числами.\n"
    ]
  },
  "\n\n\nЕсли рассматривать произвольные булевы функции в качестве связок, возникает вопрос: в каком случае набор булевых функций образует полный базис? (Это значит, что любая булева функция представляется в виде композиции функций из набора,  —е записывается в виде формулы, где связками служат функции набора.) Подобные вопросы вызывали в своё время большой интерес и были хорошо изучены.\nНачальным этапом явилось такое утверждение:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "критерий Поста"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "критерий Поста",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\nНабор булевых функций является полным тогда и только тогда, когда он не содержится целиком ни в одном из пяти следующих « предполных классов»:\n",
      "",
      "\n\n\n",
      {
        "name": "list",
        "props": {},
        "children": [
          {
            "name": "item",
            "props": {},
            "children": [
              "монотонные функции;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "функции, сохраняющие нуль;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "функции, сохраняющие единицу;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "линейные функции;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "самодвойственные функции."
            ]
          },
          "\n"
        ]
      },
      "\n\n\n(Функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "монотонна"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли она монотонно неубывает по каждому из своих аргументов.\nФункция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "сохраняет нуль/единицу"
        ]
      },
      ",\n",
      "",
      "\nесли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(0,\\dots,0)=0"
        ]
      },
      " (соответственно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(1,\\dots,1)=1"
        ]
      },
      ").\nФункция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "линейна"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли она представима многочленом, в котором все мономы содержат не более одной переменной.\nНаконец, функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "самодвойственной"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(1-p_1,\\dots,1-p_n)=1-f(p_1,\\dots,p_n)"
        ]
      },
      ".)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nЕсли набор содержится в одном из классов, то и все композиции также не выходят за пределы этого класса (легко проверить для каждого из классов в отдельности) и поэтому набор не является полным.\nДокажем обратное утверждение.\nПусть для каждого класса выбрана какая-то функция, в нём не лежащая.\nУбедимся, что с помощью комбинаций выбранных функций можно получить все булевы функции.\n\n\nУ нас есть функция, не сохраняющая нуль.\nПодставим вместо всех аргументов одну и ту же переменную.\nПолучится функция от одного аргумента, отображающая нуль в единицу, то есть либо константа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", либо отрицание.\nСделав то же самое с функцией, не сохраняющей единицу, получим либо константу нуль, либо отрицание.\nТаким образом, у нас либо есть отрицание, либо обе константы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\n\n\nЕсли есть обе константы, то всё равно можно получить отрицание.\nВозьмём немонотонную функцию.\nЛегко понять, что она должна менять значение с единицы на нуль при изменении какого-то одного аргумента с нуля на единицу (в самом деле, будем увеличивать аргументы по одному, в какой-то момент значение функции уменьшится.)\nЗафиксировав значения остальных аргументов (ведь мы считаем, что константы есть), получаем отрицание.\n\n\nИмея отрицание и несамодвойственную функцию, легко получить константы (если их не было).\nВ самом деле, несамодвойственность означает, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(x_1,\\dots,x_n)=f(1-x_1,\\dots,1-x_n)"
        ]
      },
      "\nдля каких-то значений ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n\\in\\{0,1\\} "
        ]
      },
      ".\nВместо нулевых значений переменных ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n"
        ]
      },
      " подставим ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ",\nвместо единиц подставим ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p"
        ]
      },
      ", получится одна из констант.\nВторая получится отрицанием.\n\n\nТеперь у нас есть константы, отрицание и нелинейная функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(p_1,\\dots,p_n)"
        ]
      },
      ".\nНелинейность означает, что в её представлении в виде многочлена есть моном, состоящий более чем из одной переменной.\nПусть, например, этот моном содержит переменные ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_2"
        ]
      },
      ".\nСгруппируем члены по четырём группам и получим выражение\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\np_1p_2 A(p_3,\\dots)+p_1B(p_3,\\dots)+p_2C(p_3,\\dots)+D(p_3,\\dots).\n"
        ]
      },
      "\nПри этом многочлен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A(p_3,\\dots)"
        ]
      },
      " заведомо отличен от нуля, поэтому можно так подставить константы вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_3,\\dots,p_n"
        ]
      },
      ", чтобы первое слагаемое не обратилось в нуль.\nТогда получим либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2 + p_1+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_2+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1+p_2+d"
        ]
      },
      ".\nСвободный член ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "d"
        ]
      },
      " можно менять, если нужно (у нас есть отрицание), так что получается либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2"
        ]
      },
      "\n(конъюнкция, и всё доказано), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1=p_1(p_2+1)= p_1\\land\\lnot p_2"
        ]
      },
      " (убираем отрицание, получаем конъюнкцию, всё доказано), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_2"
        ]
      },
      " (аналогично), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1+p_2= (1+p_1)(1+p_2)-1=\\lnot(\\lnot p_1\\land\\lnot p_2)=p_1\\lor p_2"
        ]
      },
      " (дизъюнкция, всё доказано).\n",
      " ᐅ"
    ]
  },
  "\n",
  "\n",
  "\n"
]
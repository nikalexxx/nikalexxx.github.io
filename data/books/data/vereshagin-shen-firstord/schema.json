[
  {
    "name": "counter",
    "props": {
      "start": "chapter",
      "initial": 1
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "start": "problem"
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "start": "theorem",
      "initial": 1
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "initial": "image"
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "initial": "lit"
    },
    "children": []
  },
  "ЛЕКЦИИ ПО МАТЕМАТИЧЕСКОЙ ЛОГИКЕ И ТЕОРИИ АЛГОРИТМОВ\n\n\n",
  {
    "name": "authors",
    "props": {},
    "children": [
      {
        "name": "link",
        "props": {
          "href": "http://lpcs.math.msu.su/~ver/"
        },
        "children": [
          "Н. К. Верещагин"
        ]
      },
      ",\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Шень,_Александр_Ханиевич"
        },
        "children": [
          "А.Шень"
        ]
      },
      "\n"
    ]
  },
  "\n",
  {
    "name": "title",
    "props": {},
    "children": [
      "Языки и исчисления"
    ]
  },
  "\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Электронная версия в процессе адаптации, это предупреждение будет убрано по окончанию (Николаичев А.С.)"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 2
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "end": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "end": "table"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "use": "chapter"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "table"
        },
        "children": []
      },
      ". ",
      "Логика высказываний"
    ]
  },
  "\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Высказывания и операции"
    ]
  },
  "\n\n«Если число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " рационально, то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " — алгебраическое число.\nНо оно не алгебраическое. Значит, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " не рационально.»\nМы не обязаны знать, что такое число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  ", какие числа называют рациональными и какие алгебраическими, чтобы признать, что это рассуждение правильно — в том смысле, что из двух сформулированных посылок действительно вытекает заключение.\nТакого рода ситуации — когда некоторое утверждение верно независимо от смысла входящих в него высказываний — составляют предмет ",
  {
    "name": "em",
    "props": {},
    "children": [
      "логики высказываний"
    ]
  },
  ".\n",
  "",
  "\n\n\nТакое начало (особенно если учесть, что курс логики входил в программу философского факультета, где также изучалась «диалектическая логика») настораживает, но на самом деле наши\n",
  "",
  "\nрассмотрения будут иметь вполне точный математический характер, хотя мы начнём с неформальных мотивировок.\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Высказывания"
    ]
  },
  "",
  " могут быть\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "истинными"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nи ",
  {
    "name": "em",
    "props": {},
    "children": [
      "ложными"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nНапример, «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{16}+1"
    ]
  },
  " — простое число» — истинное высказывание, а «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{32}+1"
    ]
  },
  " — простое число» — ложное (это число делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "641"
    ]
  },
  ").\nПро высказывание «существует бесконечно много простых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p+2"
    ]
  },
  " — также простое» никто не берётся сказать наверняка, истинно оно или ложно.\nЗаметим, что «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  "» в этом смысле не является высказыванием, пока не сказано, чему равно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "; при разных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " получаются разные высказывания, одни истинные (при чётном ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "), другие — ложные (при нечётном ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ").\n\n\nВысказывания можно соединять друг с другом с помощью «логических связок».\n",
  "",
  "\n",
  "",
  "\nЭти связки имеют довольно странные, но традиционные названия и обозначения (табл. ",
  {
    "name": "label",
    "props": {
      "ref": "logic-connectives-names"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "logic-connectives-names_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "table",
    "props": {
      "align": "center",
      "key": "logic-connectives-names",
      "name": "Логические связки, обозначения и названия."
    },
    "children": [
      "\n",
      {
        "name": "row",
        "props": {
          "head": true
        },
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " связка "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " обозначение "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " название"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " и ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\& B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\land B"
                ]
              },
              "\n\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\texttt{ and }B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "конъюнкция\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " или ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\lor B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\texttt{ or }B"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " дизъюнкция\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              "не ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " неверно\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\lnot A"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\sim\\!A"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\overline{A} "
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\texttt{not} A"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\nотрицание\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              "из ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " следует ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\nесли ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              ", то ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " влечёт ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              " — следствие ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\rightarrow B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\Rightarrow B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\supset B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\texttt{if }A\\texttt{ then }B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\nимпликация\n\nследование\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\n",
      "",
      "\n",
      "",
      "\n",
      {
        "name": "area",
        "props": {
          "inline": true
        },
        "children": [
          "Таблица ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "logic-connectives-names_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "last": "chapter"
                },
                "children": []
              },
              ".",
              {
                "name": "counter",
                "props": {
                  "use": "table",
                  "key": "logic-connectives-names_counter"
                },
                "children": []
              }
            ]
          },
          ". ",
          "Логические связки, обозначения и названия."
        ]
      }
    ]
  },
  "\n\n\nОтметим также, что в импликации ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\Rightarrow B"
    ]
  },
  " высказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "посылкой"
    ]
  },
  ",\n",
  "",
  "\nили ",
  {
    "name": "em",
    "props": {},
    "children": [
      "антецедентом импликации"
    ]
  },
  ",\n",
  "",
  "\nа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " — ",
  {
    "name": "em",
    "props": {},
    "children": [
      "заключением"
    ]
  },
  ",\n",
  "",
  "\nили ",
  {
    "name": "em",
    "props": {},
    "children": [
      "консеквентом"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\n\n\nГоворят также, что высказывание имеет ",
  {
    "name": "em",
    "props": {},
    "children": [
      "истинностное значение"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " (истина),\n",
  "",
  "\nесли оно истинно, или ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " (ложь),\n",
  "",
  "\nесли оно ложно.\nИногда вместо ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " употребляется буква ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "T"
    ]
  },
  " (true) или число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nа вместо ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " — буква ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "F"
    ]
  },
  " (false) или число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  ".\n(С первого взгляда идея произвольным образом выбрать числа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " кажется дикой — какая бы польза могла быть от, скажем, сложения истинностных значений?\nУдивительным образом в последние годы обнаружилось, что такая польза есть, и если оперировать с истиной и ложью как элементами конечного поля, можно получить много неожиданных результатов.\nНо это выходит за рамки нашей книги.)\n\n\nЛогические связки позволяют составлять сложные высказывания из простых.\nПри этом истинность составного высказывания определяется истинностью его частей в соответствии с таблицей ",
  {
    "name": "label",
    "props": {
      "ref": "truth-tables"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "truth-tables_link"
        },
        "children": []
      }
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "truth-tables"
    },
    "children": [
      {
        "name": "table",
        "props": {},
        "children": [
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A\\land B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A\\lor B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A \\to B"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n"
        ]
      },
      "\n\n",
      {
        "name": "table",
        "props": {},
        "children": [
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "\\lnot A"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  }
                ]
              }
            ]
          },
          "\n"
        ]
      },
      "\n\n",
      {
        "name": "area",
        "props": {
          "position": "center"
        },
        "children": [
          {
            "name": "format.small",
            "props": {},
            "children": [
              {
                "name": "format.i",
                "props": {},
                "children": [
                  "Таблица ",
                  {
                    "name": "area",
                    "props": {
                      "inline": true,
                      "key": "truth-tables_link"
                    },
                    "children": [
                      {
                        "name": "counter",
                        "props": {
                          "last": "chapter"
                        },
                        "children": []
                      },
                      ".",
                      {
                        "name": "counter",
                        "props": {
                          "use": "table"
                        },
                        "children": []
                      }
                    ]
                  },
                  ". Таблицы истинности для логических связок"
                ]
              },
              "\n"
            ]
          }
        ]
      }
    ]
  },
  "\n\nТе же правила можно изложить словесно.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\land B"
    ]
  },
  " истинно, если оба высказывания ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " истинны.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\lor B"
    ]
  },
  " истинно, если хотя бы одно из высказываний ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " истинно.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to B"
    ]
  },
  " ложно в единственном случае: если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " истинно, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " ложно.\nНаконец, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  " истинно в том и только том случае, когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " ложно.\n\n\nИз всех связок больше всего вопросов вызывает импликация.\nВ самом деле, не очень понятно, почему надо считать, скажем, высказывания «если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=5"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=4"
    ]
  },
  "» и «если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=5"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "3\\times 3=1"
    ]
  },
  "» истинными.\n(Именно так говорят наши таблицы: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "Л\\toИ = Л\\toЛ = И"
    ]
  },
  ".)\nНа самом деле  в таком определении есть свой резон.\nВсе согласны, что если число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ", то оно делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\nЭто означает, что высказывание\n\n\n(",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\to"
    ]
  },
  " (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ")\n\n\nистинно при всех ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ".\n\nПодставим сюда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=5"
    ]
  },
  ": обе части ложны, а утверждение в целом истинно.\nПри ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=6"
    ]
  },
  " посылка импликации ложна, а заключение истинно, и вся импликация истинна.\nНаконец, при ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=8"
    ]
  },
  " посылка и заключение истинны и импликация в целом истинна.\nС другой стороны, обратное утверждение (если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ") неверно, и число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " является контрпримером.\nПри этом посылка импликации истинна, заключение ложно, и сама импликация ложна.\nТаким образом, если считать, что истинность импликации определяется истинностью её частей (а не наличием между ними каких-то причинно-следственных связей), то все строки таблицы истинности обоснованы.\nЧтобы подчеркнуть такое узко-формальное понимание импликации, философски настроенные логики называют её «материальной импликацией».\n\n\nТеперь от неформальных разговоров перейдём к определениям.\nЭлементарные высказывания (из которых составляются более сложные) мы будем обозначать маленькими латинскими буквами и называть ",
  {
    "name": "em",
    "props": {},
    "children": [
      "пропозициональными переменными"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nИз них строятся ",
  {
    "name": "em",
    "props": {},
    "children": [
      "пропозициональные формулы"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nпо таким правилам:\n\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Всякая пропозициональная переменная есть формула."
        ]
      },
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " — пропозициональная формула, то ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot A"
            ]
          },
          " — пропозициональная формула."
        ]
      },
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          " — пропозициональные формулы, то ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\land B)"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\lor B)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to B)"
            ]
          },
          " — пропозициональные формулы."
        ]
      },
      "\n\n"
    ]
  },
  "\n\nМожно ещё сказать так: формулы образуют минимальное множество, обладающее указанными свойствами (слово «минимальное» здесь существенно: ведь если бы мы объявили любую последовательность переменных, скобок и связок формулой, то эти три свойства были бы тоже выполнены).\n\n\nПусть формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " содержит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " пропозициональных переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p_1,p_2,\\dots,p_n"
    ]
  },
  ".\nЕсли подставить вместо этих переменных истинностные значения (",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " или ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  "), то по таблицам можно вычислить истинностное значение формулы в целом.\nТаким образом, формула задаёт некоторую функцию от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов, каждый из которых может принимать значения ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " и ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  ".\nЗначения функции также лежат в множестве {",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  ", ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  "}, которое мы будем обозначать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B} "
    ]
  },
  ".\nМы будем следовать уже упоминавшейся традиции и отождествлять ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " с единицей, а ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " — с нулём, тем самым ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B} "
    ]
  },
  " есть ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\{0,1\\} "
    ]
  },
  ".\nФормула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " задаёт отображение типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}^n\\to\\Bbb{B} "
    ]
  },
  ".\nТакие отображения называют также ",
  {
    "name": "em",
    "props": {},
    "children": [
      "булевыми функциями ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Пример"
    ]
  },
  ". Рассмотрим формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\land (q\\land \\lnot r))"
    ]
  },
  ".\nОна истинна в единственном случае — когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинны, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "r"
    ]
  },
  " ложно (см. таблицу ",
  {
    "name": "label",
    "props": {
      "ref": "example-conjunct"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "example-conjunct_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "table",
    "props": {
      "key": "example-conjunct"
    },
    "children": [
      {
        "name": "row",
        "props": {
          "head": true
        },
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "p"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "q"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "r"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\lnot r"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(q \\land \\lnot r)"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(p\\land(q\\land\\lnot r))"
                ]
              },
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\nТаблица ",
      {
        "name": "area",
        "props": {
          "inline": true,
          "key": "example-conjunct_link"
        },
        "children": [
          {
            "name": "counter",
            "props": {
              "last": "chapter"
            },
            "children": []
          },
          ".",
          {
            "name": "counter",
            "props": {
              "use": "table"
            },
            "children": []
          }
        ]
      },
      ". Таблица истинности для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(p\\land(q\\land \\lnot r))"
        ]
      },
      ".\n"
    ]
  },
  "\n\nНекоторые формулы выражают логические законы — составные высказывания, истинные независимо от смысла их частей.\nТакие формулы (истинные при всех значениях входящих в них переменных) называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "тавтологиями"
    ]
  },
  ".\n",
  "",
  "\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Пример"
    ]
  },
  ". Формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p \\land q)\\to p)"
    ]
  },
  " является тавтологией (это можно проверить, например, составив таблицу).\nОна выражает такой логический закон: из конъюнкции утверждений следует первое из них.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Как выглядит симметричное утверждение для дизъюнкции и какая формула его выражает?\n"
    ]
  },
  "\n\n\nДве формулы называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "эквивалентными"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nесли они истинны при одних и тех же значениях переменных (другими словами, если они задают одну и ту же булеву функцию).\nНапример, легко проверить, что формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p \\land (p\\to q))"
    ]
  },
  " истинна лишь при ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p=q=И"
    ]
  },
  ", и потому эквивалентна формуле ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\land q)"
    ]
  },
  ".\n\n\nРассмотрим формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\land q)\\lor q)"
    ]
  },
  ".\nОна истинна, если переменная ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинна, и ложна, если переменная ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " ложна.\nХотелось бы сказать, что она эквивалентна формуле ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  ", но тут есть формальная трудность: она содержит две переменные и потому задаёт функцию от двух аргументов (типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}\\times\\Bbb{B}\\to\\Bbb{B} "
    ]
  },
  "), в то время как формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " задаёт функцию одного аргумента.\nМы не будем обращать на это внимания и будем считать эти формулы эквивалентными.\nВообще, если есть список переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p_1,\\dots,p_n"
    ]
  },
  ", содержащий все переменные некоторой формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " (и, возможно, ещё какие-то переменные), можно считать, что формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " задаёт функцию от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов, возможно, на деле зависящую не от всех аргументов (постоянную по некоторым аргументам)\n\n\nПосле сделанных оговорок легко проверить следующий факт: формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\psi"
    ]
  },
  " эквивалентны тогда и только тогда, когда формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((\\varphi\\to\\psi)\\land{(\\psi\\to\\varphi))} "
    ]
  },
  " является тавтологией.\nИспользуя сокращение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\leftrightarrow q)"
    ]
  },
  " для ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\to q)\\land{(q\\to p)})"
    ]
  },
  ", можно записывать утверждения об эквивалентности формул в виде тавтологий.\nВот несколько таких эквивалентностей:\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "Формулы\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{aligned}\n(p\\land q) &\\leftrightarrow (q \\land p);\\\\\n((p\\land q) \\land r) &\\leftrightarrow (p\\land (q \\land r));\\\\\n(p\\lor q) &\\leftrightarrow (q \\lor p);\\\\\n((p\\lor q) \\lor r) &\\leftrightarrow (p\\lor (q \\lor r));\\\\\n(p\\land(q\\lor r)) &\\leftrightarrow ((p\\land q)\\lor (p\\land r));\\\\\n(p\\lor(q\\land r)) &\\leftrightarrow ((p\\lor q)\\land (p\\lor r));\\\\\n\\lnot(p\\land q) &\\leftrightarrow (\\lnot p\\lor \\lnot q);\\\\\n\\lnot(p\\lor q) &\\leftrightarrow (\\lnot p\\land \\lnot q);\\\\\n(p\\lor (p \\land q)) &\\leftrightarrow p;\\\\\n(p\\land (p \\lor q)) &\\leftrightarrow p;\\\\\n(p\\to q) &\\leftrightarrow (\\lnot q\\to \\lnot p);\\\\\np &\\leftrightarrow \\lnot\\lnot p\n\\end{aligned}\n"
        ]
      },
      "\nявляются тавтологиями.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервые четыре эквивалентности выражают коммутативность и ассоциативность конъюнкции и дизъюнкции.\nПроверим, например, вторую: левая и правая части истинны в единственном случае (когда все переменные истинны), и потому эквивалентны.\n(Для дизъюнкции удобнее смотреть, когда она ложна.)\n\nДве следующие эквивалентности означают  дистрибутивность — заметим, что в отличие от сложения и умножения в кольцах здесь верны оба свойства дистрибутивности.\nПроверить эквивалентность легко, если отдельно рассмотреть случаи истинного и ложного ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ".\n\n\nСледующие два свойства, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "законы Де Моргана"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nлегко проверить, зная, что конъюнкция истинна, а дизъюнкция ложна лишь в одном случае.\nЭти свойства иногда выражают словами: «конъюнкция двойственна дизъюнкции».\n\n\nДалее следуют два очевидных ",
      {
        "name": "em",
        "props": {},
        "children": [
          "закона поглощения"
        ]
      },
      "\n",
      "",
      "\n(один из них мы уже упоминали).\n\n\nЗа ними идёт правило ",
      {
        "name": "em",
        "props": {},
        "children": [
          "контрапозиции"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nкоторое говорит, в частности, что утверждения «если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " совершенно, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " чётно» и «если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " нечётно, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " несовершенно»  равносильны.\nХотя оно и очевидно проверяется с помощью таблиц истинности, с ним связаны любопытные парадоксы.\nВот один из них.\n\n\nБиолог А выдвинул гипотезу: все вороны чёрные.\nПроверяя её, он вышел во двор и обнаружил на дереве ворону.\nОна оказалось чёрной.\nБиолог А радуется — гипотеза подтверждается.\nБиолог Б переформулировал гипотезу так: все не-чёрные предметы — не вороны (применив наше правило контрапозиции) и не стал выходить во двор, а открыл холодильник и нашёл там оранжевый предмет.\nОн оказался апельсином, а не вороной.\nБиолог Б обрадовался — гипотеза подтверждается — и позвонил биологу А.\nТот удивляется — у него тоже есть апельсин в холодильнике, но с его точки зрения никакого отношения к его гипотезе апельсин не имеет,",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\dots"
        ]
      },
      "\n\n\nДругой парадокс: с точки зрения формальной логики утверждения «кто не с нами, тот против нас» и «кто не против нас, тот с нами» равносильны.\n\n\nПоследнее (и очевидное) правило ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\leftrightarrow \\lnot\\lnot p"
        ]
      },
      " называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "снятием двойного отрицания"
        ]
      },
      ".\n",
      "",
      "\n",
      " ᐅ"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Перечисленные эквивалентности соответствуют свойствам операций на множествах: например, первая гарантирует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P\\cap Q=Q\\cap P"
        ]
      },
      " для любых множеств ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      ".\nКакие утверждения соответствуют остальным эквивалентностям?\n"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Две формулы, содержащие только переменные и связки ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot"
        ]
      },
      ", эквивалентны.\nДокажите, что они останутся эквивалентными, если всюду заменить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      " и наоборот.\n"
    ]
  },
  "\n\nДалеко не все тавтологии имеют ясный интуитивный смысл.\nНапример, формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\to q)\\lor(q\\to p)"
    ]
  },
  " является тавтологией (если одно из утверждений ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " ложно, то из него следует всё, что угодно; если оба истинны, то тем более формула истинна), хотя и отчасти противоречит нашей интуиции — почему, собственно, из двух никак не связанных утверждений одно влечёт другое?\nЕщё более загадочна тавтология\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n((p\\to q)\\to p)\\to p\n"
    ]
  },
  "\n(хотя её ничего не стоит проверить с помощью таблиц истинности).\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Отступление о пользе скобок"
    ]
  },
  ".\n",
  "",
  "\nНа самом деле наше определение истинности содержит серьёзный пробел.\nЧтобы обнаружить его, зададим себе вопрос: зачем нужны скобки в формулах?\nПредставим себе, что мы изменим определение формулы, и будем говорить, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "P \\land Q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "P \\lor Q"
    ]
  },
  " являются формулами для любых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "Q"
    ]
  },
  ".\nОстанутся ли наши рассуждения в силе?\n\n\nЛегко понять, что мы столкнёмся с трудностью при определении булевой функции, соответствующей формуле.\nВ этом определении мы подставляли нули и единицы на место переменных и затем вычисляли значение формулы с помощью таблиц истинности для связок.\nНо теперь, когда мы изменили определение формулы, формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land q \\lor r"
    ]
  },
  " может быть получена двумя способами — из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "r"
    ]
  },
  " с помощью операции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor"
    ]
  },
  " и из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q\\lor r"
    ]
  },
  " с помощью операции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land"
    ]
  },
  ".\nЭти два толкования дадут разный результат при попытке вычислить значение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0 \\land 0 \\lor 1"
    ]
  },
  ".\n\n\nИз сказанного ясно, что скобки нужны, чтобы гарантировать однозначность синтаксического разбора формулы.\nТочнее говоря, верно такое утверждение:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "однозначность разбора"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "однозначность разбора",
          ")",
          ". "
        ]
      },
      "",
      "\nПропозициональная формула, не являющаяся переменной, может быть представлена ровно в одном из четырёх видов ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\lor B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " или ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " — некоторые формулы, причём ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " (в первых трёх случаях) восстанавливаются однозначно.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nФормальное доказательство можно провести так: назовём ",
      {
        "name": "em",
        "props": {},
        "children": [
          "скобочным итогом"
        ]
      },
      "\n",
      "",
      "\nразницу между числом открывающихся и закрывающихся скобок.\nИндукцией по построению формулы легко доказать такую лемму:\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма"
        ]
      },
      ". Скобочный итог формулы равен нулю.\nСкобочный итог любого начала формулы неотрицателен и равен нулю, лишь если это начало совпадает со всей формулой, пусто или состоит из одних символов отрицания.\n\nСлова «индукцией по построению» означают, что мы проверяем утверждение для переменных, а также доказываем, что если оно верно для формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ", то оно верно и для формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\lor B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ".\n\nПосле того как лемма доказана, разбор формулы проводится так: если она начинается с отрицания, то может быть образована лишь по третьему правилу.\nЕсли же она начинается со скобки, то надо скобку удалить, а потом искать непустое начало, имеющее нулевой скобочный итог и не оканчивающееся на знак логической операции.\nТакое начало единственно (как легко проверить, используя лемму).\nЭто начало и будет первой частью формулы.\nТем самым формула разбирается однозначно.\n",
      " ᐅ"
    ]
  },
  "\n\n\nНет смысла вдаваться в подробности этого (несложного) рассуждения: вообще-то алгоритмы разбора формул — это отдельная большая и практически важная тема (в первую очередь в связи с компиляторами).\nПриведённый нами алгоритм далеко не оптимален.\nС другой стороны, мы вообще можем обойти эту проблему, потребовав, чтобы при записи формул левая и правая скобки, окружающие формулу, связывались линией — тогда однозначность разбора формулы не вызывает вопросов, и больше ничего нам не надо.\n\n\nВ дальнейшем мы будем опускать скобки, если они либо не играют роли (например, можно написать конъюнкцию трёх членов, не указывая порядок действий в силу ассоциативности), либо ясны из контекста.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Польский логик Лукасевич",
      "",
      " предлагал обходиться без скобок, записывая в формулах сначала знак операции, а потом операнды (без пробелов и разделителей).\nНапример, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)\\times(c+(d\\times e))"
        ]
      },
      " в его обозначениях запишется как ",
      {
        "name": "math",
        "props": {},
        "children": [
          "{{\\times}{+}ab{+}c{\\times}{d} {e}}"
        ]
      },
      ".\nЭту запись ещё называют ",
      {
        "name": "em",
        "props": {},
        "children": [
          "польской"
        ]
      },
      "\n",
      "",
      "\nзаписью.\n",
      {
        "name": "em",
        "props": {},
        "children": [
          "Обратная"
        ]
      },
      " польская запись отличается от неё тем, что знак операции идёт после операндов.\nПокажите, что в обоих случаях порядок действий восстанавливается однозначно.\n"
    ]
  },
  "\n",
  "\n\n",
  {
    "name": "header",
    "props": {
      "key": "complete-connectives",
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Полные системы связок"
    ]
  },
  "\n\n\nРассматриваемая нами система пропозициональных связок (в неё входят ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\to"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot"
    ]
  },
  ") ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полна"
    ]
  },
  "\n",
  "",
  "\nв следующем смысле:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "Полнота системы связок",
      "key": "completeness-connectives"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "completeness-connectives_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "completeness-connectives_link"
            },
            "children": []
          },
          " (",
          "Полнота системы связок",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nЛюбая булева функция (с любым числом аргументов) может быть записана в виде пропозициональной формулы.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПроще всего пояснить это на примере.\nПусть, например, булева функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p,q,r)"
        ]
      },
      " задана таблицей ",
      {
        "name": "label",
        "props": {
          "ref": "sample-truth-table"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "sample-truth-table_link"
            },
            "children": []
          }
        ]
      },
      ".\n\n\n",
      {
        "name": "table",
        "props": {
          "key": "sample-truth-table"
        },
        "children": [
          "\n",
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "p"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "q"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "r"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "\\varphi(p,q,r)"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n\n",
          {
            "name": "area",
            "props": {
              "align": "center"
            },
            "children": [
              {
                "name": "math",
                "props": {
                  "block": true
                },
                "children": [
                  "\n\\begin{aligned}\n     (\\lnot p \\land \\lnot q \\land \\lnot r) &\\lor\\\\\n  \\lor   (\\lnot p \\land q \\land r) &\\lor\\\\\n  \\lor   (p \\land q       \\land r)& \\phantom{\\lor} \\\\\n\\end{aligned}\n"
                ]
              },
              "\n"
            ]
          },
          "\n\nТаблица ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "sample-truth-table_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "last": "chapter"
                },
                "children": []
              },
              ".",
              {
                "name": "counter",
                "props": {
                  "use": "table"
                },
                "children": []
              }
            ]
          },
          ". Булева функция и задающая её формула.\n"
        ]
      },
      "\n\n\nВ таблице есть три строки с единицами в правой колонке — три случая, когда булева функция истинна (равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ").\nНапишем три конъюнкции, каждая из которых покрывает один случай (а в остальных строках ложна), и соединим их дизъюнкцией.\nНужная формула построена.\n\n\nЯсно, что аналогичная конструкция применима для любой таблицы (с любым числом переменных).\n",
      " ᐅ"
    ]
  },
  "\n\n\nДля формул подобного вида есть специальное название: формулы в ",
  {
    "name": "em",
    "props": {},
    "children": [
      "дизъюнктивной нормальной форме"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nБолее подробно:\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "литералом"
    ]
  },
  "\n",
  "",
  "\nназывается переменная или отрицание переменной,\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "конъюнктом"
    ]
  },
  "\n",
  "",
  "\nназывается произвольная конъюнкция литералов, а дизъюнктивной нормальной формой называется дизъюнкция конъюнктов.\nВ нашем случае в каждый конъюнкт входит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " литералов (где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " — число переменных), а число конъюнктов равно числу строк с единицами и может меняться от нуля (тогда, правда, получается не совсем формула, а «пустая дизъюнкция», и её можно заменить какой-нибудь всегда ложной формулой типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land \\lnot p"
    ]
  },
  ") до ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^n"
    ]
  },
  " (если булева функция всегда истинна).\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДлина построенной в доказательстве теоремы ",
      "",
      " формулы зависит от числа единиц: формула будет короткой, если единиц в таблице мало.\nА как написать (сравнительно) короткую формулу, если в таблице мало нулей, а в основном единицы?\n"
    ]
  },
  "\n\n\nИногда полезна двойственная ",
  {
    "name": "em",
    "props": {},
    "children": [
      "конъюнктивная нормальная форма"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nкоторая представляет собой конъюнкцию ",
  {
    "name": "em",
    "props": {},
    "children": [
      "дизъюнктов"
    ]
  },
  ".\n",
  "",
  "\nКаждый дизъюнкт состоит из литералов, соединённых дизъюнкциями.\nТеорему ",
  "",
  " можно теперь усилить так:\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "dnf-cnf"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "dnf-cnf_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "dnf-cnf_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nВсякая булева функция может быть выражена формулой, находящейся в дизъюнктивной нормальной форме, а также формулой, находящейся в конъюнктивной нормальной форме.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервая часть утверждения уже доказана.\nВторая часть аналогична первой, надо только для каждой строки с нулём написать подходящий дизъюнкт.\n\n\nМожно также представить функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot \\varphi"
        ]
      },
      " в дизъюнктивной нормальной форме, а затем воспользоваться законами Де Моргана,\n",
      "",
      "\nчтобы внести отрицание внутрь.\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Проведите второй вариант рассуждения подробно."
    ]
  },
  "\n\n\nВообще говоря, определение нормальной формы не требует, чтобы в каждом конъюнкте (или дизъюнкте) встречались все переменные.\n(Повторять переменную больше одного раза смысла нет; если, например, переменная и её отрицание входят в одну конъюнкцию, то эта конъюнкция всегда ложна и её можно выбросить.)\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Приведите пример булевой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "~аргументов, у которой любая дизъюнктивная или конъюнктивная нормальная форма содержит лишь члены длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n(Указание: рассмотрите функцию, которая меняет своё значение при изменении значения любой переменной.)\n"
    ]
  },
  "\n\n\nЗаметим, что при доказательстве теоремы ",
  "",
  " мы обошлись без импликации.\nЭто и не удивительно, так как она выражается через дизъюнкцию и отрицание:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\to q) \\ \\leftrightarrow \\ (\\lnot p \\lor q)\n"
    ]
  },
  "\n(проверьте!).\nМы могли бы обойтись только конъюнкцией и отрицанием, так как ",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\lor q) \\ \\leftrightarrow \\ \\lnot(\\lnot p \\land \\lnot q),\n"
    ]
  },
  "\nили только дизъюнкцией и отрицанием, так как ",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\land q) \\ \\leftrightarrow \\ \\lnot(\\lnot p \\lor \\lnot q)\n"
    ]
  },
  "\n(обе эквивалентности вытекают из законов Де Моргана; их легко проверить и непосредственно).\nКак говорят, система связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land, \\lnot"
    ]
  },
  ", а также система связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor, \\lnot"
    ]
  },
  " являются ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полными"
    ]
  },
  ".\n",
  "",
  "\n(По определению это означает, что с их помощью можно записать любую булеву функцию.)\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Докажите, что система связок ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot, \\to"
        ]
      },
      " полна.\n(Указание: как записать через них дизъюнкцию?)\n"
    ]
  },
  "\n\n\nА вот без отрицания обойтись нельзя.\nСистема связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land, \\lor,\\to"
    ]
  },
  " неполна — и по очень простой причине: если все переменные истинны, то любая их комбинация, содержащая только указанные связки, истинна.\n(Как говорят, все эти связки «сохраняют единицу».)\n",
  "",
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nЛюбая формула, составленная только с помощью связок ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      ", задаёт монотонную булеву функцию ",
      "",
      "\n",
      "",
      "\n(в том смысле, что от увеличения значения любого из аргументов значение функции может только возрасти — или остаться прежним).\nПокажите, что верно и обратное: любая монотонная булева функция либо постоянна (всюду истинна или всюду ложна), либо может быть выражена формулой, содержащей только ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi\\to\\psi"
        ]
      },
      " — тавтология.\nПокажите, что найдётся формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\tau"
        ]
      },
      ", которая включает в себя только общие для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " переменные, для которой формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\varphi\\to\\tau)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\tau\\to\\psi)"
        ]
      },
      " являются тавтологиями.\n(Более общий вариант этого утверждения, в котором рассматриваются формулы с кванторами, называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "леммой Крейга"
        ]
      },
      ".)\n",
      "",
      "\n",
      "",
      "\n"
    ]
  },
  "\n\n\nВ принципе мы не обязаны ограничиваться четырьмя рассмотренными связками.\nЛюбая булева функция может играть роль связки.\nНапример, можно рассмотреть связку ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p \\texttt{ notand } q)"
    ]
  },
  ",\n",
  "",
  "\nзадаваемую эквивалентностью\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p \\texttt{ notand } q) \\ \\leftrightarrow \\ \\lnot(p\\land q)\n"
    ]
  },
  "\n(словами: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\texttt{ notand }q)"
    ]
  },
  " ложно, лишь если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинны).\nЧерез неё выражается отрицание (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p \\texttt{ notand }p"
    ]
  },
  "), после чего можно выразить конъюнкцию, а затем, как мы знаем, и вообще любую функцию.\n(Знакомые с цифровыми логическими схемами малого уровня интеграции хорошо знакомы с этим утверждением: достаточно большой запас схем И-НЕ позволяет реализовать любую требуемую зависимость выхода от входов.)\n\n\nДругая интересная полная система связок — сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ", конъюнкция и константа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " (которую можно считать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  "-арной связкой, задающей функцию от нуля аргументов).\nПредставленные в этой системе булевы функции становятся полиномами с коэффициентами в кольце вычетов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\nИдея рассматривать булевы функции как полиномы (оказавшаяся неожиданно плодотворной в последние годы) была высказана в 1927~г. российским математиком Иваном Ивановичем Жегалкиным.\n",
  "",
  "\n\n\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "мономом"
    ]
  },
  "\n",
  "",
  "\nконъюнкцию любого набора переменных или константу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " (которую естественно рассматривать как конъюнкцию нуля переменных).\nНазвание это естественно, так как при наших соглашениях (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " обозначает истину, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " — ложь) конъюнкция соответствует умножению.\n\n\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полиномом"
    ]
  },
  "\n",
  "",
  "\nсумму таких мономов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " (это значит, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0\\oplus0 =0"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0\\oplus 1=1\\oplus 0=1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1\\oplus1=0"
    ]
  },
  ").\nЯсно, что два повторяющихся монома можно сократить (ведь сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  "), так что будем рассматривать только полиномы без повторяющихся мономов.\nПри этом, естественно, порядок членов в мономе (как и порядок мономов в полиноме) роли не играет, их можно переставлять.\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "о полиномах Жегалкина",
      "key": "polynomials-boolean-functions"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "polynomials-boolean-functions_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "polynomials-boolean-functions_link"
            },
            "children": []
          },
          " (",
          "о полиномах Жегалкина",
          ")",
          ". "
        ]
      },
      "",
      "\nВсякая булева функция однозначно представляется таким полиномом."
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nСуществование искомого полинома следует из теоремы ",
      "",
      ", так как конъюнкция есть умножение, отрицание — прибавление единицы, а дизъюнкцию можно через них выразить (получится ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p+q+pq"
        ]
      },
      ").\nНадо только заметить, что степени не нужны: переменные принимают значения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", так что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x^n"
        ]
      },
      " можно заменить на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      ".\n\n\nМожно также сослаться на известное из алгебры утверждение о том, что всякая функция с аргументами из конечного поля (в данном случае это двухэлементное поле вычетов по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") задаётся полиномом.\n(Так получается новое доказательство теоремы ",
      "",
      ".)\n\n\nДалее можно заметить, что полиномов столько же, сколько булевых функций, а именно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^n} "
        ]
      },
      ".\nВ самом деле, булева функция может принимать любое из двух значений в каждой из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " точек булева куба ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}^n"
        ]
      },
      ", а многочлен может включать или не включать любой из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " мономов.\n(Мономов ровно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      ", потому что каждый моном включает или не включает любую из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменных.)\nПоэтому избытка полиномов нет, и если любая функция представима полиномом, то единственным образом.\n\n\nМожно и не ссылаться на сведения из алгебры и теорему ",
      "",
      ", а дать явную конструкцию.\nЭто удобно сделать индукцией по ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\nПусть мы уже умеем представлять любую булеву функцию от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n-1"
        ]
      },
      " аргументов с помощью полинома.\nТогда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p_1,\\dots,p_n)"
        ]
      },
      " можно представить как\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\varphi(p_1,\\dots,p_n) =\n\\varphi(0, p_2,\\dots,p_{n})\n+[\\varphi(0,p_2,\\dots,p_{n})+\n\\varphi(1,p_2,\\dots,p_{n})]p_1\n"
        ]
      },
      "\n(проверьте).\nОстаётся заметить, что правую часть можно представить полиномом по предположению индукции.\n\n\nДля единственности также есть другое доказательство: пусть два многочлена (имеющие степень ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      " по каждой переменной) равны при всех значениях переменных.\nТогда их сумма (или разность —\nвычисления происходят по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") является ненулевым многочленом (содержит какие-то мономы), но тождественно равна нулю.\nТак не бывает, и это легко доказать по индукции.\nВ самом деле, любой многочлен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A(p_1,\\dots,p_n)"
        ]
      },
      " можно представить в виде\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\nA(p_1,\\dots,p_n)=B(p_2,\\dots,p_n)+p_1C(p_2,\\dots,p_n),\n"
        ]
      },
      "\nгде ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " — многочлены от меньшего числа переменных.\nПодставляя сначала ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1=0"
        ]
      },
      ", а затем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1=1"
        ]
      },
      ", убеждаемся,\nчто многочлены ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " равны нулю во всех точках, и потому (согласно предположению индукции) равны нулю как многочлены (не содержат мономов).\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " — произвольное поле.\n",
      "",
      "\nНазовём ",
      {
        "name": "em",
        "props": {},
        "children": [
          "мультилинейной"
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\nфункцией полином от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменных с коэффициентами из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ", в котором все показатели степеней равны либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\n(Таким образом, каждый моном в ней есть произведение коэффициента и некоторого набора переменных без повторений.) Будем рассматривать ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}=\\{0,1\\} "
        ]
      },
      " как подмножество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\nДокажите, что всякая булева функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}^n\\to\\Bbb{B} "
        ]
      },
      " однозначно продолжается до мультилинейной функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F^n\\to F"
        ]
      },
      ", и коэффициенты мультилинейной функции можно считать целыми числами.\n"
    ]
  },
  "\n\n\nЕсли рассматривать произвольные булевы функции в качестве связок, возникает вопрос: в каком случае набор булевых функций образует полный базис? (Это значит, что любая булева функция представляется в виде композиции функций из набора,  —е записывается в виде формулы, где связками служат функции набора.) Подобные вопросы вызывали в своё время большой интерес и были хорошо изучены.\nНачальным этапом явилось такое утверждение:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "критерий Поста"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "критерий Поста",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\nНабор булевых функций является полным тогда и только тогда, когда он не содержится целиком ни в одном из пяти следующих « предполных классов»:\n",
      "",
      "\n\n\n",
      {
        "name": "list",
        "props": {},
        "children": [
          {
            "name": "item",
            "props": {},
            "children": [
              "монотонные функции;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "функции, сохраняющие нуль;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "функции, сохраняющие единицу;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "линейные функции;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "самодвойственные функции."
            ]
          },
          "\n"
        ]
      },
      "\n\n\n(Функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "монотонна"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли она монотонно неубывает по каждому из своих аргументов.\nФункция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "сохраняет нуль/единицу"
        ]
      },
      ",\n",
      "",
      "\nесли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(0,\\dots,0)=0"
        ]
      },
      " (соответственно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(1,\\dots,1)=1"
        ]
      },
      ").\nФункция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "линейна"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли она представима многочленом, в котором все мономы содержат не более одной переменной.\nНаконец, функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "самодвойственной"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(1-p_1,\\dots,1-p_n)=1-f(p_1,\\dots,p_n)"
        ]
      },
      ".)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nЕсли набор содержится в одном из классов, то и все композиции также не выходят за пределы этого класса (легко проверить для каждого из классов в отдельности) и поэтому набор не является полным.\nДокажем обратное утверждение.\nПусть для каждого класса выбрана какая-то функция, в нём не лежащая.\nУбедимся, что с помощью комбинаций выбранных функций можно получить все булевы функции.\n\n\nУ нас есть функция, не сохраняющая нуль.\nПодставим вместо всех аргументов одну и ту же переменную.\nПолучится функция от одного аргумента, отображающая нуль в единицу, то есть либо константа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", либо отрицание.\nСделав то же самое с функцией, не сохраняющей единицу, получим либо константу нуль, либо отрицание.\nТаким образом, у нас либо есть отрицание, либо обе константы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\n\n\nЕсли есть обе константы, то всё равно можно получить отрицание.\nВозьмём немонотонную функцию.\nЛегко понять, что она должна менять значение с единицы на нуль при изменении какого-то одного аргумента с нуля на единицу (в самом деле, будем увеличивать аргументы по одному, в какой-то момент значение функции уменьшится.)\nЗафиксировав значения остальных аргументов (ведь мы считаем, что константы есть), получаем отрицание.\n\n\nИмея отрицание и несамодвойственную функцию, легко получить константы (если их не было).\nВ самом деле, несамодвойственность означает, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(x_1,\\dots,x_n)=f(1-x_1,\\dots,1-x_n)"
        ]
      },
      "\nдля каких-то значений ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n\\in\\{0,1\\} "
        ]
      },
      ".\nВместо нулевых значений переменных ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n"
        ]
      },
      " подставим ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ",\nвместо единиц подставим ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p"
        ]
      },
      ", получится одна из констант.\nВторая получится отрицанием.\n\n\nТеперь у нас есть константы, отрицание и нелинейная функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(p_1,\\dots,p_n)"
        ]
      },
      ".\nНелинейность означает, что в её представлении в виде многочлена есть моном, состоящий более чем из одной переменной.\nПусть, например, этот моном содержит переменные ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_2"
        ]
      },
      ".\nСгруппируем члены по четырём группам и получим выражение\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\np_1p_2 A(p_3,\\dots)+p_1B(p_3,\\dots)+p_2C(p_3,\\dots)+D(p_3,\\dots).\n"
        ]
      },
      "\nПри этом многочлен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A(p_3,\\dots)"
        ]
      },
      " заведомо отличен от нуля, поэтому можно так подставить константы вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_3,\\dots,p_n"
        ]
      },
      ", чтобы первое слагаемое не обратилось в нуль.\nТогда получим либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2 + p_1+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_2+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1+p_2+d"
        ]
      },
      ".\nСвободный член ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "d"
        ]
      },
      " можно менять, если нужно (у нас есть отрицание), так что получается либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2"
        ]
      },
      "\n(конъюнкция, и всё доказано), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1=p_1(p_2+1)= p_1\\land\\lnot p_2"
        ]
      },
      " (убираем отрицание, получаем конъюнкцию, всё доказано), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_2"
        ]
      },
      " (аналогично), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1+p_2= (1+p_1)(1+p_2)-1=\\lnot(\\lnot p_1\\land\\lnot p_2)=p_1\\lor p_2"
        ]
      },
      " (дизъюнкция, всё доказано).\n",
      " ᐅ"
    ]
  },
  "\n",
  "\n\n",
  "\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Схемы из функциональных элементов"
    ]
  },
  "\n",
  "",
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img1.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img1.png"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img2.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img2.png"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img3.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img3.png"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img4.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img4.png"
    },
    "children": []
  },
  "\n\nФормулы представляют собой способ записи композиции функций.\nНапример, если мы сначала применяем функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  ", а потом функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "g"
    ]
  },
  ", это можно записать формулой ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "g(f(x))"
    ]
  },
  ".\nНо есть и другой способ: можно изобразить каждую функцию в виде прямоугольника с « входом» и « выходом» и соединить выход функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  " со входом функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "g"
    ]
  },
  " (рис. ",
  {
    "name": "label",
    "props": {
      "ref": "scheme-1"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "scheme-1_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n",
  {
    "name": "image",
    "props": {
      "src": "/img1.png",
      "key": "scheme-1",
      "height": 0.5
    },
    "children": [
      {
        "name": "area",
        "props": {
          "inline": true
        },
        "children": [
          "Рис. ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "scheme-1_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "image",
                  "key": "scheme-1_counter"
                },
                "children": []
              }
            ]
          },
          ". ",
          "Два способа изобразить композицию ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "g\\circ f"
            ]
          },
          ".\n"
        ]
      }
    ]
  },
  "\n\n\nТакое представление отнюдь не является чисто теоретическим.\nУже больше полувека электронная промышленность выпускает микросхемы, которые выполняют логические операции.\nТакая микросхема имеет электрические контакты, напряжение на которых кодирует логические значения ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " и ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  ".\nКонкретное напряжение зависит от типа схемы, но обычно это несколько вольт, и высокий потенциал (относительно заземления) считается единицей, а низкий нулём.\n\n\nОдной из типичных схем является схема И-НЕ, она имеет два входа и один выход.\nСигнал на выходе является отрицанием конъюнкции сигналов на входе.\nДругими словами, на выходе появляется высокий потенциал (сигнал ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ") тогда и только тогда, когда на одном из входов потенциал низкий (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  ").\nИз такой схемы легко получить схему НЕ (изменяющую уровень сигнала на противоположный), соединив проводом два входа.\nПри этом на оба входа поступает один и тот же сигнал, и операция И его не меняет (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land p=p"
    ]
  },
  "), а НЕ меняет на противоположный.\nВзяв два элемента И-НЕ и используя второй из них в качестве элемента НЕ, инвертирующего сигнал с выхода первого элемента, получаем схему, которая реализует функцию И.\nА если поставить два элемента НЕ перед каждым из входов элемента И-НЕ, получим схему, реализующую функцию ИЛИ: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot (\\lnot p\\land\\lnot q) \\leftrightarrow (p\\lor q)"
    ]
  },
  ".\n\n\nТеорема ",
  {
    "name": "label",
    "props": {
      "ref": "completeness-connectives"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "completeness-connectives_link"
        },
        "children": []
      }
    ]
  },
  " о полноте системы связок ",
  "",
  "\nтеперь гарантирует, что любую булеву функцию можно реализовать в виде схемы.\nНадо иметь в виду, однако, что предлагаемая в её доказательстве конструкция (дизъюнктивная нормальная форма)\n",
  "",
  "\nимеет скорее теоретический интерес, поскольку приводит к схемам очень большого размера даже для простых функций (если число аргументов велико).\nНапример, схема, сравнивающая два ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "16"
    ]
  },
  "-битных числа, должна иметь ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "32"
    ]
  },
  " входа и поэтому в её реализации с помощью дизъюнктивной нормальной формы будет порядка ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{32} "
    ]
  },
  "\nэлементов— что мало реально. (Между тем такую схему можно построить гораздо проще, из нескольких сотен элементов.)\n\n\nПоэтому вопрос о том, сколько элементов нужно для реализации той или иной функции, представляет большой интерес— как практический, так и философский.\n(Одна из центральных проблем математики и информатики, так называемая « проблема перебора», ",
  "",
  "\nможет быть сформулирована в этих терминах.)\n\n\nМы сейчас дадим более формальное определение схемы и реализуемой ей булевой функции.\nНо прежде всего ответим на такой вопрос— почему мы вообще говорим о схемах? Ведь можно записать композицию булевых функций в виде формулы, не будет ли это то же самое?\n\n\nОказывается, не совсем, и разницу легко увидеть на примере (рис. ",
  {
    "name": "label",
    "props": {
      "ref": "scheme-2"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "scheme-2_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "image",
    "props": {
      "src": "/img2.png",
      "key": "scheme-2",
      "height": 0.5
    },
    "children": [
      {
        "name": "area",
        "props": {
          "inline": true
        },
        "children": [
          "Рис. ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "scheme-2_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "image",
                  "key": "scheme-2_counter"
                },
                "children": []
              }
            ]
          },
          ". ",
          "Элемент входит в формулу дважды."
        ]
      }
    ]
  },
  "\n\nЗдесь один и тот же элемент схемы (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  ") приходится указывать в формуле дважды, поскольку его выход используется в качестве входа двух других элементов.\nСхемы, в которых такого ветвления нет (на практике ветвление вполне возможно, хотя и ограничено « нагрузочной способностью выхода», как говорят инженеры), как раз и соответствуют формулам.\nНо в общем случае полученная из данной схемы формула может быть длинной, даже если схема содержит небольшое число элементов, поскольку число копий может расти экспоненциально с ростом глубины схемы.\n\n\nХотя идея построения схемы из функциональных элементов, реализующих булевы функции, достаточно наглядна, дадим более формальное определение.\nФиксируем некоторый набор булевых функций ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ".\nПусть имеется ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " булевых (принимающих значения ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ")\nпеременных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x_1,\\dots,x_n"
    ]
  },
  ", называемых ",
  {
    "name": "em",
    "props": {},
    "children": [
      "входами"
    ]
  },
  ".\n",
  "",
  "\nПусть также имеется некоторое число булевых переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_1,\\dots,y_m"
    ]
  },
  ", называемых ",
  {
    "name": "em",
    "props": {},
    "children": [
      "проводниками"
    ]
  },
  ".\n",
  "",
  "\nПусть для каждого проводника схемы задана булева функция из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ", выражающая его значение через другие проводники и входы.\nПри этом требуется, чтобы не было циклов (цикл образуется, когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_i"
    ]
  },
  " зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_j"
    ]
  },
  ", которое зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_k"
    ]
  },
  ", dots, которое зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_i"
    ]
  },
  ").\nПусть, кроме того, среди проводников выделен один, называемый ",
  {
    "name": "em",
    "props": {},
    "children": [
      "выходом"
    ]
  },
  ".\n",
  "",
  "\nВ таком случае говорят, что задана ",
  {
    "name": "em",
    "props": {},
    "children": [
      "схема из функциональных элементов в базисе ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      }
    ]
  },
  "\n",
  "",
  "\nс ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " входами.\nЧисло ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "m"
    ]
  },
  " называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "размером"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nсхемы.\n(С точки зрения инженера размер— это число использованных элементов, а базис ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "— это ассортимент доступных ему элементов.)\n\n\nОтсутствие циклов гарантирует, что есть проводник, зависящий только от входов (иначе можно было бы найти цикл: возьмём какой-то проводник, затем возьмём тот проводник, от которого он зависит и т.д.).\nЗначение этого проводника, таким образом, однозначно определяется сигналами на входах.  Среди оставшихся проводников также нет цикла, поэтому можно найти один из них, зависящий только от уже известных, и определить его значение.\nПеренумеровав проводники в таком порядке, мы можем записать последовательность присваиваний\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{aligned}\n    y_1&:= f_1(\\dots);\\\\\n    y_2&:= f_2(\\dots);\\\\\n       \\dots\\\\\n    y_m&:= f_m(\\dots),\\\\\n\\end{aligned}\n"
    ]
  },
  "\nв правых частях которых стоят функции из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ", применённые ко входам и уже найденным значениям.\nПри этом можно считать, что результат схемы есть ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_m"
    ]
  },
  "\n(как только результат получен, дальнейшие присваивания уже не нужны).\nТакая программа определяет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_m"
    ]
  },
  " при известных значениях входов, и тем самым ",
  {
    "name": "em",
    "props": {},
    "children": [
      "вычисляет"
    ]
  },
  "\n",
  "",
  "\nнекоторую булеву функцию.\n\n\nТеперь набор булевых функций ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " можно назвать ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полным"
    ]
  },
  ", ",
  "",
  "\nесли любая булева функция может быть задана схемой из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "-элементов (существует программа, её вычисляющая, при этом в правых частях присваиваний стоят функции из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ").\nЯсно, что это определение полноты равносильно прежнему, то есть возможности записать булеву функцию в виде формулы со связками из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " (как мы говорили, разница только в том, что один и тот же элемент будет фигурировать в формуле многократно).\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Сложностью"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nбулевой функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  " относительно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " называют минимальный размер схемы из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "-элементов, вычисляющей функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  ".\nЕго обозначают ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}_B(f)"
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "size-invariant"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "size-invariant_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "size-invariant_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_2"
        ]
      },
      "— два полных набора булевых функций.\nТогда соответствующие меры сложности отличаются не более чем на постоянный множитель:\nнайдётся такое число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ", что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{size}_{B_1}(f)\\le C\\text{size}_{B_2}(f)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{size}_{B_2}(f)\\le C\\text{size}_{B_1}(f)"
        ]
      },
      "\nдля любой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nУтверждение почти очевидно: поскольку наборы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_2"
        ]
      },
      " полны, то каждая функция одного из наборов может быть вычислена какой-то схемой, составленной из элементов другого набора.\nТеперь можно взять в качестве ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " наибольший размер таких схем, и неравенства будут выполняться: каждую строку программы можно заменить на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " (или меньше) строк с использованием функций другого набора.\n",
      " ᐅ"
    ]
  },
  "\n\nЧто можно сказать о сложности произвольной булевой функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "\nаргументов? Следующая теорема показывает, что она экспоненциально зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " (для «наугад взятой» функции).\n",
  "",
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "generic-size"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "generic-size_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "generic-size_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ") Пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c>2"
        ]
      },
      ".\nТогда сложность любой булевой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов не превосходит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c^n"
        ]
      },
      " для всех достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ") Пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c<2"
        ]
      },
      ".\nТогда сложность большинства булевых функций ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c^n"
        ]
      },
      " для всех достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПрежде всего заметим, что по предыдущей теореме не имеет значения, какой полный базис выбрать (изменение значения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      " более существенно, чем умножение сложности на константу).\n\nПервое утверждение теоремы очевидно: размер схемы, реализующей дизъюнктивную нормальную форму ",
      "",
      "\nс ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменными, есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n2^n)"
        ]
      },
      ", поскольку имеется не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " конъюнктов размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ". (Напомним смысл ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O"
        ]
      },
      "-обозначений: ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n2^n)"
        ]
      },
      " означает, что существует верхняя оценка вида ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Cn2^n"
        ]
      },
      " для некоторой константы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ".) Осталось заметить, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n2^n)<c^n"
        ]
      },
      " при достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " (напомним, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c>2"
        ]
      },
      ").\n\nЧтобы доказать второе утверждение, оценим число различных схем (скажем, в базисе И, ИЛИ, НЕ) размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументами.\nКаждая такая схема может быть описана последовательностью из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N"
        ]
      },
      " присваиваний, выражающих одну из переменных через предыдущие.\nДля каждого присваивания есть не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3(N+n)^2"
        ]
      },
      " вариантов (три типа операций— конъюнкция, дизъюнкция, отрицание, и каждый из не более чем двух аргументов выбирается среди не более чем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N+n"
        ]
      },
      " вариантов).\nОтсюда легко получить оценку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{O(N\\log N)} "
        ]
      },
      " на число всех функций сложности не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N"
        ]
      },
      " (считая ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N\\ge n"
        ]
      },
      ").\n\nВсего булевых функций с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументами имеется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^n} "
        ]
      },
      ".\nИз сравнения этих формул видно, что что при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c<2"
        ]
      },
      " и при достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " булевы функции сложности меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c^n"
        ]
      },
      " составляют меньшинство, так как ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{O(c^n\\log c^n)} "
        ]
      },
      " много меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^n} "
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПроведите вторую часть рассуждения более подробно и покажите, что при некотором ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varepsilon>0} "
        ]
      },
      " сложность большинства булевых функций с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументами не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon2^n/n"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\nВерхнюю оценку теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "generic-size"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "generic-size_link"
        },
        "children": []
      }
    ]
  },
  " можно усилить и показать, что сложность любой булевой функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов не превосходит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(2^n/n)"
    ]
  },
  ".\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ") Покажите, что можно построить схему размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^m)"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^m"
        ]
      },
      " выходами, реализующую все ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^m"
        ]
      },
      " возможных конъюнктов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "m"
        ]
      },
      " (для каждого— свой выход). (Указание:\nтакую схему можно построить индуктивно.)\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ") Покажите, что можно построить схему размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^{2^m})"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^m} "
        ]
      },
      " выходами, реализующую все ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^m} "
        ]
      },
      "\nбулевых функций ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "m"
        ]
      },
      " аргументов. (Указание: эту схему также можно построить индуктивно.)\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "в"
        ]
      },
      ") Пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(x_1,\\dots,x_k,y_1,\\dots,y_l)"
        ]
      },
      "—\nбулева функция, аргументы которой разбиты на две группы.\nПокажите, что её можно записать в виде дизъюнкции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^k"
        ]
      },
      " членов, каждый из которых имеет вид ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C(x_1,\\dots,x_k)\\land D(y_1,\\dots,y_l)"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      "— конъюнкт, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "D"
        ]
      },
      "— произвольная булева функция.\nВывести отсюда упомянутую выше оценку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^n/n)"
        ]
      },
      ". (Указание: разумно положить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k={n-\\log n+c} "
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "l={\\log n-c} "
        ]
      },
      ".\nСм. также ",
      {
        "name": "label",
        "props": {
          "ref": "gindikin"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "gindikin_link"
            },
            "children": []
          }
        ]
      },
      " и ",
      {
        "name": "label",
        "props": {
          "ref": "cyber"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "cyber_link"
            },
            "children": []
          }
        ]
      },
      ".)\n"
    ]
  },
  "\n\n\nТеорема ",
  {
    "name": "label",
    "props": {
      "ref": "generic-size"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "generic-size_link"
        },
        "children": []
      }
    ]
  },
  ", однако, ничего не говорит о сложности конкретных булевых функций.\nСитуация здесь такова.\nЕсть разнообразные методы и приёмы получения верхних оценок.\nНо про нижние оценки неизвестно практически ничего.\nПро многие функции мы подозреваем, что их сложность велика (экспоненциально зависит от числа входов), но доказать это пока не удаётся.\nВесьма нетривиальные идеи позволяют доказывать экспоненциальные нижние оценки для некоторых специальных классов схем, например, схем из монотонных элементов или схем ограниченной глубины (использующих элементы И и ИЛИ с произвольным числом входов).\nПолучение экспоненциальных оценок для более общих схем— один из возможных подходов к знаменитой ",
  {
    "name": "em",
    "props": {},
    "children": [
      "проблеме перебора"
    ]
  },
  ", ",
  "",
  "\nцентральной проблеме теории сложности вычислений.\n\n\nМы не будем углубляться в эту теорию, а приведём лишь несколько верхних оценок для конкретных задач.\nПри этом мы не претендуем на полноту, а хотим лишь показать несколько интересных идей и приёмов.\n\n\nРассмотрим функцию сравнения ",
  "",
  "\n",
  "",
  "\nдвух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-битовых чисел.\nОна имеет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  " аргументов (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " для одного числа и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " для другого); её значение равно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ", если первое число больше второго, и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " в противном случае.\n\n\nОбозначим эту функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{Comp}_n"
    ]
  },
  ".\n",
  "",
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "recursive-comparing"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "recursive-comparing_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "recursive-comparing_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      "— полный набор функций.\nСуществует такая константа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ", что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{size}_B(\\text{Comp}_n)\\le Cn"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nЗаметим, что поскольку в формулировке теоремы оценка размера проводится с точностью до константы, то выбор конкретного базиса не имеет значения.\nДругими словами, мы можем предполагать, что любое конечное число необходимых нам функций в этом базисе есть.\n\n\nСхема сравнения чисел будет рекурсивной (чтобы сравнить два числа, мы отдельно сравниваем их левые и правые половины, а затем объединяем результаты).\nПри этом, как часто бывает, надо усилить утверждение, чтобы индукция прошла.\nА именно, мы будем строить схему с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2n"
        ]
      },
      " входами ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n,y_1,\\dots,y_n"
        ]
      },
      " и двумя выходами, которая указывает, какой из трёх случаев ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x<y"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x=y"
        ]
      },
      " или ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x>y"
        ]
      },
      " имеет место. (Здесь ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x,y"
        ]
      },
      "— числа, записываемое в двоичной системе как ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1\\dots x_n"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_1,\\dots,y_n"
        ]
      },
      ".) Два выходных бита кодируют четыре возможности, а нужно только три, так что есть некоторый запас.\nДля определённости можно считать, что первый выходной бит истинен, если числа равны, а второй— если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x<y"
        ]
      },
      ".\nТогда возможны три варианта сигналов на выходе: ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "10"
        ]
      },
      " (равенство), ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "01"
        ]
      },
      "\n(при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x<y"
        ]
      },
      ") и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "00"
        ]
      },
      " (при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x>y)"
        ]
      },
      ".\n\n\nОбъясним теперь, как собрать, скажем, схему сравнения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "16"
        ]
      },
      "-разрядных чисел.\nСоберём отдельно схему сравнения старших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      " разрядов и младших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      " разрядов.\nКаждая из них даст ответ в форме двух битов.\nТеперь из этих четырёх битов надо собрать два. (Если в старших разрядах неравенство, то оно определяет результат сравнения; если старшие разряды равны, то результат сравнения определяется младшими разрядами.) Написанная в скобках фраза определяет булеву функцию с четырьмя битами на входе и двумя битами на выходе, и может быть реализована некоторой схемой фиксированного размера.\nТаким образом, если через ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(n)"
        ]
      },
      " обозначить размер схемы, сравнивающей ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовые числа, то получаем оценку\n",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2n)\\le 2T(n)+c"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      "— некоторая константа, зависящая от выбора базиса.\nОтсюда следует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2^k)\\le c'2^k"
        ]
      },
      " при некотором ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c'"
        ]
      },
      ".\nВ самом деле, для достаточно большого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c'"
        ]
      },
      " можно доказать по индукции, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2^k) \\le c'2^k - c"
        ]
      },
      "\n(мы должны усилить неравенство, вычтя из правой части ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      ", чтобы индуктивный шаг прошёл; база индукции остается верной, если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c'"
        ]
      },
      " достаточно велико).\n\n\nТу же самую оценку можно объяснить и наглядно.\nНаша схема имеет вид иерархического дерева.\nНа каждом уровне из двух двухбитовых сигналов получается один.\nОстаётся вспомнить, что в полном двоичном дереве число внутренних вершин (которое определяет размер схемы)\nна единицу меньше числа листьев. (В турнире по олимпийской системе число игр на единицу меньше числа команд, так как после каждой игры одна команда выбывает.)\n\n\nВсе внутренние вершины и все листья (где сравниваются два бита) представляют собой схемы ограниченного размера, откуда и вытекает оценка ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2^k)\\le c'2^k"
        ]
      },
      ".\n\n\nОсталось лишь сказать, что делать, если размер чисел (который мы обозначали через ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ") не есть точная степень двойки.\nВ этом случае можно увеличить размер до ближайшей сверху степени двойки (не более чем в два раза) и подать на старшие разряды входов нули.\nОба действия приводят к увеличению размера схемы не более чем в константу раз.\n",
      " ᐅ"
    ]
  },
  "\n\n\nПерейдём к сложению двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных чисел.\n",
  "",
  "\n(Строго говоря, тут возникает не булева функция, а функция ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}^n\\times\\Bbb{B}^n\\to\\Bbb{B}^{n+1} "
    ]
  },
  ", но все наши определения очевидно переносятся на этот случай.)\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "sequential-addition"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "sequential-addition_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "sequential-addition_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ", осуществляющая сложение двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНапомним смысл обозначения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ": нам надо построить схему сложения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел, имеющую размер не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Cn"
        ]
      },
      " для некоторого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " и для всех ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n\n\nВспомним, как складывают числа в столбик:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{rrrrr}\n    &        0 &        1 &        1 & \\\\\n    &        1 &        0 &        0 &1\\\\\n    &        1 &        0 &        1 &1\\\\\n\\hline 1   &        0 &        1 &        0 &0\\\\\n\\end{array}\n"
        ]
      },
      "\nВерхняя строка— биты переноса, нижняя— результат.\nЗаметим, что каждый из битов переноса или результата определяется тремя другими битами (бит результата равен сумме двух  битов слагаемых и бита переноса по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ", а бит переноса равен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", если хотя бы два из этих трёх битов равны ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ").\nПоэтому можно составить схему, которая вычисляет эти биты справа налево и имеет размер ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\nЗаметим, что теорему ",
  {
    "name": "label",
    "props": {
      "ref": "recursive-comparing"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "recursive-comparing_link"
        },
        "children": []
      }
    ]
  },
  " легко вывести из теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "sequential-addition"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "sequential-addition_link"
        },
        "children": []
      }
    ]
  },
  ": чтобы сравнить числа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y"
    ]
  },
  ", сложим число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(2^n-1)-x"
    ]
  },
  " (то есть число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ", в котором все единицы заменены нулями и наоборот) и число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y"
    ]
  },
  ".\nЕсли в старшем разряде появится единица, то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y>x"
    ]
  },
  ", а если нет, то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y\\le x"
    ]
  },
  ".\nОстаётся заметить, что и сложение, и обращение битов в числе ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "\nтребуют схем линейного размера.\nТаким образом, сравнение чисел сводится к вычислению бита переноса.\nВерно и обратное:\nвычисление бита переноса сводится к сравнению двух чисел (обратим в одном из слагаемых все биты).\n\n\nТем не менее конструкция, использованная при доказательстве теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "recursive-comparing"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "recursive-comparing_link"
        },
        "children": []
      }
    ]
  },
  ", имеет некоторые преимущества.\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "глубиной"
    ]
  },
  "\n  ",
  "",
  "\n  ",
  "",
  "\nсхемы максимальное число элементов на пути от входа к выходу.\nЕсли представить себе, что сигнал на выходе элемента появляется не сразу после подачи сигналов на входы, а с некоторой задержкой, то глубина схемы определяет суммарную задержку.\nЛегко понять, что рекурсивная схема сравнения имела глубину ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  " (число уровней пропорционально логарифму размера входа), в то время как построенная только что схема сложения имеет глубину,   ",
  "",
  "\nпропорциональную ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " (биты переноса вычисляются последовательно, справа налево).\nНо можно соединить эти два результата:\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "carry-save-adder"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "carry-save-adder_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "carry-save-adder_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема сложения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nКак мы видели, проблема в том, что биты переноса вычисляются последовательно, а не параллельно.\nЕсли удастся их все вычислить схемой размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", дальнейшее очевидно.\n\nВычисление битов переноса равносильно сравнению, так что для доказательства теоремы достаточно научиться сравнивать параллельно все « суффиксы» двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1\\dots x_n"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_1\\dots y_n"
        ]
      },
      ", —е для каждого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "i"
        ]
      },
      " сравнить числа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_ix_{i+1}\\dots x_n"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_iy_{i+1}\\dots y_n"
        ]
      },
      ".\n\nВспомним, что мы делали при сравнении чисел (скажем, длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      ").\nНа нижнем уровне мы сравнивали биты:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{cccccccc}\nx_1 & x_2 & x_3 & x_4 & x_5 & x_6 & x_7 & x_8 \\\\\ny_1 & y_2 & y_3 & y_4 & y_5 & y_6 & y_7 & y_8\n\\end{array}\n"
        ]
      },
      "\nНа следующем уровне мы сравнивали двузначные числа\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{cccc}\nx_1 x_2 & x_3 x_4 & x_5 x_6 & x_7 x_8 \\\\\ny_1 y_2 & y_3 y_4 & y_5 y_6 & y_7 y_8\n\\end{array}\n"
        ]
      },
      "\nзатем четырёхзначные\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{cc}\nx_1  x_2   x_3  x_4 & x_5   x_6   x_7   x_8 \\\\\n{y_1} {y_2} {y_3} {y_4} &\n{y_5} {y_6} {y_7} {y_8}\n\\end{array}\n"
        ]
      },
      "\nи, наконец, восьмизначные:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{c}\nx_1  x_2   x_3  x_4  x_5   x_6   x_7   x_8 \\\\\n{y_1} {y_2} {y_3} {y_4}\n{y_5} {y_6} {y_7} {y_8}\n\\end{array}\n"
        ]
      },
      "\nТаким образом, для суффиксов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "4"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      "\nрезультаты сравнения уже есть.\nДля суффикса длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "6"
        ]
      },
      " результат можно получить, комбинируя результат сравнения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_3x_4 ? y_3y_4"
        ]
      },
      "\nи ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_5x_6x_7x_8 ? y_5y_6y_7y_8"
        ]
      },
      ".\nПосле этого у нас есть информация о суффиксах всех чётных длин, и соединяя её с информацией с первого этапа, получаем сведения про все суффиксы.\nНапример, для сравнения суффиксов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "7"
        ]
      },
      ", то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_2\\dots x_8"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_2\\dots y_8"
        ]
      },
      ", мы соединяем результаты сравнения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_2"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_2"
        ]
      },
      " с результатами сравнения суффиксов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "6"
        ]
      },
      ", то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_3\\dots x_8"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_3\\dots y_8"
        ]
      },
      ".\n\nВ общем случае картина такая: после «сужающегося дерева» мы строим «расширяющееся»; за ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      " шагов до конца мы знаем результаты сравнения всех суффиксов, длины которых кратны ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^k"
        ]
      },
      ".\nЭто дерево имеет размер ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубину ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", что завершает доказательство.\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПокажите, что вычитание двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      "\nвыполняется схемой размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n(Указание: вычитание легко сводится к сложению, если заменить нули на единицы и наоборот.)\n"
    ]
  },
  "\n\nТеперь займёмся умножением.\nСхема умножения двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных   ",
  "",
  "\nчисел имеет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  " входов (по ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " для каждого множителя) и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  "\nвыходов для произведения.\n\n\nПосмотрим, какие оценки даёт обычный способ умножения чисел столбиком.\nВ нём умножение двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных чисел сводится к сложению ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " копий первого числа (частично заменённых на нули в зависимости от цифр второго числа) со сдвигами.\n\n\nПолучение этих копий требует схемы размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n^2)"
    ]
  },
  " (общее число цифр в копиях) и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(1)"
    ]
  },
  ".\nСложение двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  "-разрядных чисел мы можем выполнить с помощью схемы размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n)"
    ]
  },
  " и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  ", так что необходимые ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n-1"
    ]
  },
  " сложений можно выполнить схемой размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n^2)"
    ]
  },
  " и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log^2 n)"
    ]
  },
  " (если складывать сначала попарно, потом результаты снова попарно и т.д.).\nОказывается, этот результат можно улучшить.\nНаиболее экономные способы основаны на преобразовании Фурье (о них можно прочесть в книге ",
  {
    "name": "label",
    "props": {
      "ref": "aho-hopcroft-ullman"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "aho-hopcroft-ullman_link"
        },
        "children": []
      }
    ]
  },
  ").\nС их помощью, например, можно построить схему умножения ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-битовых чисел, имеющую размер ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n\\log^c n"
    ]
  },
  ".\n\n\nЭти методы далеко выходят за рамки нашего обсуждения, но два улучшения мы приведём.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "fast-multiplication"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "fast-multiplication_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "fast-multiplication_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема умножения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nКак мы уже говорили, умножение двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел сводится к сложению ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " таких чисел, и остаётся выполнить такое сложение схемой размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\nКлючевым моментом здесь является сведение сложения трёх чисел к сложению двух с помощью простой схемы размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      ".\nВ самом деле, пусть есть три числа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "z"
        ]
      },
      ".\nЕсли мы будем складывать отдельно в каждом разряде, то в разряде может накопиться любая сумма от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      ", то есть в двоичной записи от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "00"
        ]
      },
      " до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "11"
        ]
      },
      ".\nСформируем из младших битов этих двухбитовых сумм число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u"
        ]
      },
      ", а из старших (сдвинутых влево)— число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "v"
        ]
      },
      ".\nТогда, очевидно, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x+y+z=u+v"
        ]
      },
      ".\nПолучение цифр числа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "v"
        ]
      },
      " происходит параллельно во всех разрядах и требует размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      ".\n\nТеперь, если надо сложить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " чисел, можно разбить их на тройки и из каждых трёх чисел получить по два.\nВ следующий круг, таким образом, выйдут ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(2/3)n"
        ]
      },
      " чисел (примерно— граничные эффекты большой роли не играют).\nИх снова можно сгруппировать по тройкам и т.д. С каждым уровнем число слагаемых убывает в полтора раза, так что глубина схемы будет логарифмической.\nКаждое преобразование трёх слагаемых в два требует схемы размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      "\nи уменьшает число слагаемых на единицу, так что потребуется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "\nтаких преобразований.\nИтак, эта конструкция имеет общий размер ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " и глубину ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\nНадо только отметить, что в конце у нас получается не одно число, а два, и их напоследок надо сложить— что мы умеем делать с глубиной ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " и размером ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДокажите, что схема, вычисляющая булеву функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "\nаргументов, у которой ни один аргумент не является фиктивным, имеет размер не менее ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "cn"
        ]
      },
      " и глубину не менее ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c\\log n"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c>0"
        ]
      },
      "— некоторая константа, зависящая от выбранного набора элементов. (Аргумент функции называют ",
      {
        "name": "em",
        "props": {},
        "children": [
          "фиктивным"
        ]
      },
      ", ",
      "",
      "\n",
      "",
      "\nесли от него значение функции не зависит.)\n"
    ]
  },
  "\n\n\nЭта задача показывает, что если по ходу умножения двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных чисел мы суммируем ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " слагаемых размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  ", то оценки ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n^2)"
    ]
  },
  " для размера и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  " для глубины, полученные при доказательстве теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "fast-multiplication"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "fast-multiplication_link"
        },
        "children": []
      }
    ]
  },
  ", существенно улучшить нельзя.\n\n\nОднако никто не обязывает нас следовать традиционному способу умножения столбиком— отказавшись от него, мы можем уменьшить размер схемы.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "recursive-multiplication"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "recursive-multiplication_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "recursive-multiplication_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема умножения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^{\\log_2 3})"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log^2 n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНачнём с такого замечания.\nВычисляя произведение двух комплексных чисел\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(a+bi)(c+di)=(ac-bd)+(ad+bc)i\n"
        ]
      },
      "\nобычным способом, мы делаем четыре умножения.\nНо можно обойтись и тремя с помощью трюка: вычислить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "ac"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "bd"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)(c+d)"
        ]
      },
      ", а потом найти ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "ad+bc"
        ]
      },
      " как разность ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)(c+d)-ac-bd"
        ]
      },
      ".\n\nАналогичный фокус можно проделать и для целых чисел.\nРазобьём ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2n"
        ]
      },
      "-битовое число на две ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовые части, то есть представим его в виде ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "a2^n+b"
        ]
      },
      ".\nТеперь запишем произведение двух таких чисел:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(a2^n+b)(c2^n+d)=ac2^{2n}+(ad+bc)2^n+bd.\n"
        ]
      },
      "\nТеперь видно, что достаточно найти три произведения, а именно, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "ac"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "bd"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)(c+d)"
        ]
      },
      ", чтобы определить все три слагаемых в правой части равенства.\nПолучается, что умножение двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2n"
        ]
      },
      "-разрядных чисел сводится к трём умножениям ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных и к нескольким сложениям и вычитаниям. (На самом деле при умножении ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)"
        ]
      },
      " на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(c+d)"
        ]
      },
      "\nсомножители могут быть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(n+1)"
        ]
      },
      "-разрядными, но это не страшно, так как обработка лишнего разряда сводится к нескольким сложениям.)\n\nДля размера схемы это даёт рекурсивную оценку\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\nS(2n)\\le 3S(n)+O(n)\n"
        ]
      },
      "\n, из которой следует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S(n)=O(n^{\\log_2 3})"
        ]
      },
      ".\nВ самом деле, для умножения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел требуется дерево рекурсивных вызовов глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log_2 n"
        ]
      },
      " и степени ветвления ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      ".\nЗаметим, что размер схемы в вершине пропорционален числу складываемых битов.\nПри переходе от одного уровня к следующему (более близкому к корню) размер слагаемых растёт вдвое, а число вершин уменьшается втрое, поэтому общее число элементов на этом уровне уменьшается в полтора раза.\nТаким образом, при движении по уровням от листьев к корню получается убывающая геометрическая прогрессия со знаменателем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2/3"
        ]
      },
      ", сумма которой всего лишь втрое превосходит её первый член.\nОстаётся заметить, что число листьев равно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3^{\\log_2 n}=n^{\\log_2 3} "
        ]
      },
      ".\n\nОценка глубины также очевидна: на каждом уровне мы имеем схему сложения глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", а число уровней есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\nНа этом мы завершаем знакомство со схемами из функциональных элементов, выполняющими арифметические операции.\nО них можно прочесть в главе 29 учебника Кормена, ",
  "",
  "\nЛейзерсона ",
  "",
  "\nи Ривеста ",
  {
    "name": "label",
    "props": {
      "ref": "cormen-leiserson-rivest"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "cormen-leiserson-rivest_link"
        },
        "children": []
      }
    ]
  },
  "\n",
  "",
  "\nи в книге Ахо, ",
  "",
  "\nХопкрофта ",
  "",
  "\nи Ульмана ",
  {
    "name": "label",
    "props": {
      "ref": "aho-hopcroft-ullman"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "aho-hopcroft-ullman_link"
        },
        "children": []
      }
    ]
  },
  ".\n",
  "",
  "\n\n\nРассмотрим теперь функцию «голосования» ",
  "",
  "\n",
  "",
  " (majority).\n",
  "",
  "\nОна имеет нечётное число аргументов, и значение её равно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " в зависимости от того, какое из двух значений чаще встречается среди входов.\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nДля функции голосования существует схема размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n\\log\\log n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНа самом деле можно даже вычислить общее число единиц среди входов.\nЭто делается рекурсивно: считаем отдельно для каждой половины, потом складываем.\nПолучается логарифмическое число уровней.\nНа верхнем уровне надо складывать числа размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log n"
        ]
      },
      ", на следующем— размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{(\\log n -1)} "
        ]
      },
      " и так до самого низа, где складываются однобитовые числа (то есть биты входа).\nКакой средний размер складываемых чисел? Половина вершин в дереве приходится на нижний уровень (числа длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      "), четверть— на следующий (числа длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") и т.д. Вспоминая, что ряд ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\sum (k/2^k)"
        ]
      },
      " сходится, видим, что средний размер складываемых чисел есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      " и общий размер схемы есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ".\nА общая глубина есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n \\log\\log n)"
        ]
      },
      ", так как на каждом из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log n"
        ]
      },
      "\nуровней стоит схема глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log\\log n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\nЗаметим, что хотя функция голосования монотонна, построенная схема её вычисления содержит немонотонные элементы (поскольку операция сложения не монотонна).\nМы уже говорили, что всякую монотонную функцию можно составить из конъюнкций и дизъюнкций.\nДля функции голосования есть очевидный способ это сделать: написать дизъюнкцию всех конъюнкций размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(n+1)/2"
    ]
  },
  " (напомним, что число входов ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " предполагается нечётным).\nОднако при этом получится схема экспоненциального по ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " размера.\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^c)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", составленная только из элементов И и ИЛИ (с двумя входами), вычисляющая функцию голосования.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nДля начала заметим, что ограничение на размер является следствием ограничения на глубину, так как элементы И и ИЛИ имеют только два входа и число элементов в схеме глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "d"
        ]
      },
      " есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^d)"
        ]
      },
      ".\n\nСхема будет строиться из элементов большинства с тремя входами.\n(Каждый из них можно собрать из конъюнкций и дизъюнкций по формуле ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a\\land b)\\lor (a\\land c)\\lor (b\\land c)"
        ]
      },
      ".)\nВыход схемы будет большинством из трёх значений, каждое из которых есть большинство из трёх значений и т.д. (рис. ",
      {
        "name": "label",
        "props": {
          "ref": "majority-scheme"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "majority-scheme_link"
            },
            "children": []
          }
        ]
      },
      ").\n\n",
      {
        "name": "image",
        "props": {
          "src": "/img3.png",
          "key": "majority-scheme",
          "height": 0.5
        },
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true
            },
            "children": [
              "Рис. ",
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "majority-scheme_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "image",
                      "key": "majority-scheme_counter"
                    },
                    "children": []
                  }
                ]
              },
              ". ",
              "Дерево из элементов ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "3"
                ]
              },
              "-большинства.\n"
            ]
          }
        ]
      },
      "\n\nПродолжая эту конструкцию на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      " уровнях, мы получим схему с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3^k"
        ]
      },
      " входами. (Отметим, что эта схема не будет вычислять большинство среди своих входов— по той же причине, по которой результат непрямого голосования может отличаться от мнения большинства.) Но мы сделаем вот какую странную вещь: возьмём ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      "\nравным ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c\\log n"
        ]
      },
      " при достаточно большом коэффициенте пропорциональности ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      " (число входов такой схемы будет полиномиально зависеть от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ") и напишем на входах случайно выбранные переменные из данного нам набора ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n"
        ]
      },
      ".\n(Переменные, записываемые на разных входах, выбираются независимо.) Оказывается, что с ненулевой вероятностью эта схема будет вычислять функцию большинства среди ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n"
        ]
      },
      ", если константа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      "\nдостаточно велика.\nСледовательно, искомая схема существует.\n\n\nОбратите внимание: нам удастся доказать существование интересующей нас схемы, не предъявив её явно. (Такое использование вероятностных методов в комбинаторных рассуждениях часто бывает полезно.)\n\n\nИтак, почему же схема с положительной вероятностью вычисляет функцию большинства? Это доказывается так: рассмотрим какой-то один набор значений на входах и докажем, что на этом конкретном наборе случайная схема выдаёт правильный ответ с вероятностью, очень близкой к единице (равной ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-\\varepsilon"
        ]
      },
      " при очень малом ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon"
        ]
      },
      ").\n\n\nЕсли число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon"
        ]
      },
      " настолько мало, что остаётся меньшим единицы даже после умножения на число возможных входов (",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      "), то получаем требуемое (каждое из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " событий имеет вероятность не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-\\varepsilon"
        ]
      },
      ", значит их пересечение имеет вероятность не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-2^n\\varepsilon>0"
        ]
      },
      ").\n\n\nИтак, осталось оценить вероятность того, что случайная схема даст правильный ответ на данном входе.\nПусть доля единиц среди всех входов равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ".\nТогда на каждый входной провод схемы подаётся единица с вероятностью ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " и нуль с вероятностью ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-p"
        ]
      },
      "\n(выбор случайной переменной даёт единицу с вероятностью ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      "), причём сигналы на всех входах независимы.\n\n\nЕсли на трёх входах элемента ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-большинства сигналы независимы, и вероятность появления единицы на каждом входе есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ", то вероятность появления единицы на выходе есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p)=3p^2(1-p)+p^3=3p^2-2p^3"
        ]
      },
      ".\nНа следующих уровнях вероятность появления единицы будет равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(\\varphi(p)),\\varphi(\\varphi(\\varphi(p))),\\dots"
        ]
      },
      " График функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(x)"
        ]
      },
      " на отрезке ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "[0,1]"
        ]
      },
      "\n(рис. ",
      {
        "name": "label",
        "props": {
          "ref": "iterations-majority"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "iterations-majority_link"
            },
            "children": []
          }
        ]
      },
      ") показывает, что при итерациях функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " дисбаланс (отклонение от середины) нарастает и последовательность стремится к краю отрезка.\nНадо только оценить число шагов.\n\n",
      {
        "name": "image",
        "props": {
          "src": "/img4.png",
          "key": "iterations-majority",
          "height": 0.5
        },
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true
            },
            "children": [
              "Рис. ",
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "iterations-majority_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "image",
                      "key": "iterations-majority_counter"
                    },
                    "children": []
                  }
                ]
              },
              ". ",
              "Итерируемая функция ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\varphi"
                ]
              },
              ".\n"
            ]
          }
        ]
      },
      "\n\nЕсли вначале единицы составляют большинство из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов (напомним, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " нечётно), то их как минимум ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(n+1)/2"
        ]
      },
      ", так что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\ge (n+1)/2n=1/2+1/(2n)"
        ]
      },
      ".\nТаким образом, начальный дисбаланс составляет как минимум ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2n"
        ]
      },
      ".\nА в конце нам нужно приблизиться к краю отрезка на расстояние ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{-n} "
        ]
      },
      ".\n\n\nИтак, нам осталось доказать такую лемму (относящуюся скорее к математическому анализу):\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма"
        ]
      },
      ".\nПусть последовательность ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_k\\in[0,1]"
        ]
      },
      " задана рекуррентной формулой ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_{k+1}=\\varphi(x_k)"
        ]
      },
      ", где\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\varphi(x)=3x^2-2x^3.\n"
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_0\\ge1/2+1/(2n)"
        ]
      },
      ".\nТогда последовательность ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_k"
        ]
      },
      " монотонно возрастает и приближается к ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      " на расстояние ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{-n} "
        ]
      },
      " за ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " шагов. [Симметричное утверждение верно и при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_0\\le 1/2-1/(2n)"
        ]
      },
      ".]\n\nИдея доказательства: посмотрим на функцию вблизи точки ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2"
        ]
      },
      " и у краёв отрезка.\nВ точке ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2"
        ]
      },
      " производная больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", поэтому удаление от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2"
        ]
      },
      " растёт как геометрическая прогрессия, и точка перейдёт какую-то фиксированную границу (например, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0{,}51"
        ]
      },
      ") не позднее чем за ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " шагов.\nЗатем потребуется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      " шагов, чтобы дойти, скажем, до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0{,}99"
        ]
      },
      ".\nВ единице первая производная функции равна нулю, поэтому расстояние до единицы каждый раз примерно возводится в квадрат, и потому для достижения погрешности ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{-n} "
        ]
      },
      " потребуется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " шагов (как в методе Ньютона отыскания корня).\nВсего получается ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)+O(1)+O(\\log n)"
        ]
      },
      " шагов, что и требовалось.\n",
      " ᐅ"
    ]
  },
  "\n\n\nНа самом деле справедливо гораздо более сильное утверждение:\nсуществует схема размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n\\log n)"
    ]
  },
  " и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  ", состоящая только из элементов И и ИЛИ, которая имеет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " входов и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " выходов и осуществляет сортировку последовательности ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " нулей и единиц (это означает, что на выходе столько же единиц, сколько на входе, причём выходная последовательность всегда невозрастающая).\nЯсно, что средний бит выхода в такой ситуации реализует функцию большинства.\n\n\nПри кажущейся простоте формулировки единственная известная конструкция такой схемы (сортирующая сеть AKS, придуманная Айтаи, ",
  "",
  "\nКомлошом ",
  "",
  "\nи Сцемереди ",
  "",
  "\nв 1983 году)\nвесьма сложна, и появление какой-то более простой конструкции (с логарифмической глубиной!) было бы замечательным достижением.\nНо разрешив большую глубину, мы сильно упрощаем задачу: для глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log^2 n)"
    ]
  },
  " уже есть несколько сравнительно простых конструкций, а для глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n)"
    ]
  },
  " годится совсем простая сеть.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПостройте сортирующую сеть глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " элементов И и ИЛИ.  (Указание.\nДва элемента И и ИЛИ вместе образуют сортирующую сеть для двух входов.\nВспомнив сортировку пузырьком, придумайте, как из таких сетей собрать искомую, на каждом шаге группируя переменные в пары.\nОбратите внимание, что доказательство оценки на глубину не вполне тривиально.)\n"
    ]
  },
  "\n\n\nМногие нетривиальные результаты теории алгоритмов можно переформулировать в терминах сложности каких-то булевых функций.\nНапример, есть вероятностный алгоритм проверки простоты ",
  "",
  "\nбольшого числа (применяемый в системах шифрования для проверки простоты чисел из нескольких тысяч цифр).\nИспользуя этот алгоритм, можно доказать такой факт: существует схема проверки простоты ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-битового числа (на вход подаются ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "\nцифр, на выходе появляется единица, если число простое, и нуль, если число составное), размер которой ограничен полиномом от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  ".\n\n\nВернёмся к общим утверждениям о схемах и формулах.\nМы уже говорили, что с точки зрения измерения размера схемы и формулы—\nэто разные вещи (схемы экономичнее, так как в них одинаковые подформулы учитываются только один раз).\nОказывается, что размер формулы можно связать с глубиной схемы.\n",
  "",
  "\n",
  "",
  "\n\n\nБудем называть ",
  {
    "name": "em",
    "props": {},
    "children": [
      "размером"
    ]
  },
  "\n",
  "",
  "\nформулы число логических связок в ней.\nМы предполагаем, что формула использует конъюнкции, дизъюнкции и отрицания, и в схемах будем использовать такие же элементы.\nНапомним, что размером схемы ",
  "",
  "\n",
  "",
  "\nмы называли число элементов, а сложностью ",
  "",
  "\n",
  "",
  "\nбулевой функции— минимальный размер схемы, её вычисляющей.\nСложность функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "h"
    ]
  },
  " обозначалась ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}(h)"
    ]
  },
  " (точнее ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}_B(h)"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "— набор разрешённых функциональных элементов, но сейчас мы договорились использовать конъюнкции, дизъюнкции и отрицания и опускаем индекс ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ").\n\n\nМинимальный размер формулы, выражающей функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "h"
    ]
  },
  ", будем обозначать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{fsize}(h)"
    ]
  },
  ".\nОчевидно, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}(h)\\le\\text{fsize}(h)"
    ]
  },
  ".\nБолее интересно, однако, следующее утверждение, связывающее размер схемы с глубиной формулы.\nОбозначим через ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{depth}(h)"
    ]
  },
  "\nминимальную глубину схемы, вычисляющей функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "h"
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "formula-size-depth"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "formula-size-depth_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "formula-size-depth_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nИмеют место оценки ",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\text{fsize}(h)\\le c_1^{\\text{depth}(h)} \\quad\\text{и}\\quad \\text{depth}(h)\\le c_2\\log\\text{fsize}(h)\n"
        ]
      },
      " (для некоторых констант ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c_2"
        ]
      },
      " и для всех ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      ").\nДругими словами, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{depth} "
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log\\text{fsize} "
        ]
      },
      " отличаются не более чем в константу раз.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервая оценка очевидна: если мы скопируем повторяющиеся фрагменты схемы, чтобы развернуть её в дерево, то глубина не изменится.\nЕсли она равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      ", то в полученном дереве будет не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^k-1"
        ]
      },
      " элементов и соответствующая формула имеет размер не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{2^k-1} "
        ]
      },
      ". (Напомним, что элементами являются конъюнкции, дизъюнкции и отрицания, и потому ветвление не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ".)\n\n\nТо же самое можно сказать индуктивно.\nПусть глубина схемы равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      ".\nВыход схемы является выходом некоторого элемента.\nТогда на его входы подаются булевы функции глубины не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k-1"
        ]
      },
      ".\nПо предположению индукции их можно записать формулами размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{k-1}-1"
        ]
      },
      ".\nТаких формул максимум две, так что общий размер не превосходит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2(2^{k-1}-1)+1=2^k-1"
        ]
      },
      ".\n\n\nВторая оценка сложнее.\nЕсли мы будем преобразовывать формулу в схему естественным образом (введя вспомогательную переменную для каждой подформулы), то глубина получившейся схемы может быть близка к размеру формулы, а не к его логарифму.\nНапример, если формула имеет вид ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\ldots((p_1\\land p_2)\\land p_3)\\land\\dots p_n)"
        ]
      },
      ", то у нас получится цепочка элементов И, у которых каждый следующий подвешен к левому входу предыдущего, и глубина равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{n-1} "
        ]
      },
      ".\nКонечно, если использовать ассоциативность конъюнкции, скобки можно переставить и получить более сбалансированное дерево глубины примерно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log n"
        ]
      },
      ", как и требуется.\nНо как выполнить такое преобразование в случае произвольной формулы?\n\n\nОбозначим данную нам формулу через ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\nВыберем у неё некоторую подформулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " (как именно, мы объясним позже).\nРассмотрим формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0"
        ]
      },
      ", которая получится, если вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " подставить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      "\n(ложь), а также формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_1"
        ]
      },
      ", которая получится, если подставить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\nЛегко понять, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " равносильна формуле ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "((F_0 \\land\\lnot G)\\lor (F_1\\land G))"
        ]
      },
      ".\nЕсли теперь удастся заменить формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0, F_1, G"
        ]
      },
      " схемами глубины не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      ", то для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " получится схема глубины не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k+3"
        ]
      },
      ".\n\n\nТакое преобразование полезно, если все три формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_1, F_0, G"
        ]
      },
      "\nимеют заметно меньший размер, чем исходная формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма"
        ]
      },
      ".\nУ любой формулы достаточно большого размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "\nесть подформула размера от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n/4"
        ]
      },
      " до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3n/4"
        ]
      },
      ".\n\n\nДоказательство.\nКаждая формула есть конъюнкция двух подформул, дизъюнкция двух подформул или отрицание подформулы.\nНачав со всей формулы, будем переходить к её подформулам, на каждом шаге выбирая из двух подформул наибольшую.\nТогда на каждом шаге размер убывает не более чем в два раза, и потому мы не можем миновать промежуток ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "[n/4, 3n/4]"
        ]
      },
      ", концы которого отличаются втрое. (На самом деле тут есть небольшая неточность: размер формулы может убывать чуть быстрее, чем вдвое, так как размер формулы на единицу больше суммы размеров частей, но у нас есть запас, поскольку концы промежутка отличаются втрое, а не вдвое.) Лемма доказана.\n\n\nВыбирая подформулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " с помощью этой леммы, мы гарантируем, что размер всех трёх формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0,F_1,G"
        ]
      },
      " не превосходит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3/4"
        ]
      },
      "\nразмера исходной формулы (подстановка нуля или единицы может только уменьшить размер формулы— некоторые части можно будет выбросить).\n\n\nПрименим ко всем трём формулам ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " тот же приём, выделим в них подформулы среднего размера и так далее, пока мы не спустимся до формул малого размера, которые можно записать в виде схем как угодно.\nВ итоге получится дерево с логарифмическим числом уровней, на каждом из которых стоят схемы глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      ", а в листьях находятся схемы глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      ".\n\n\nДругими словами, индукцией по длине формулы, выражающей функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      ", мы доказываем, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{depth}(h)=O(\\log\\text{fsize}(h))"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nОпределим глубину формулы как максимальное число вложенных пар скобок; для единообразия будем окружать отрицание скобками и писать ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\lnot A)"
        ]
      },
      " вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ".\nПокажите, что при этом не получится ничего нового: минимальная глубина формулы, записывающей некоторую функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      ", совпадает с минимальной глубиной схемы, вычисляющей ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\nОпределение формульной сложности ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{fsize}(h)"
    ]
  },
  " зависит от выбора базиса.\nОказывается, что здесь (в отличие от схемной сложности) выбор базиса может изменить ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{fsize}(h)"
    ]
  },
  " более чем в константу раз.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nОбъясните, почему доказательство теоремы ",
      {
        "name": "label",
        "props": {
          "ref": "size-invariant"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "size-invariant_link"
            },
            "children": []
          }
        ]
      },
      "\nне переносится на случай формул.\n"
    ]
  },
  "\n\n\nТак происходит с функцией ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "{p_1\\oplus p_2\\oplus\\ldots\\oplus p_n} "
    ]
  },
  " (знак ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\oplus"
    ]
  },
  " обозначает сложение по\n",
  "",
  "\nмодулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ").\nЭта функция имеет формульную сложность ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n)"
    ]
  },
  ", если сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " входит в базис.\nОднако в базисе И, ИЛИ, НЕ она имеет большую сложность, как доказала Б.А.Субботовская.\n",
  "",
  "\nИдея доказательства такова: если заменить случайно выбранную переменную в формуле с конъюнкциями и дизъюнкциями на случайно выбранное значение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ", то формула упростится (не только эта переменная пропадёт, но с некоторой вероятностью пропадут и другие).\nЕсли делать так многократно, то от формулы останется небольшая часть— с другой стороны, эта часть всё равно должна реализовывать сложение оставшихся аргументов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДокажите, что функция большинства может быть вычислена не только схемой, но и формулой полиномиального размера, содержащей только связки И и ИЛИ.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДокажите, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{fsize}_1(h)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{fsize}_2(h)"
        ]
      },
      " для одной булевой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      " и двух полных базисов полиномиально связаны: существует полином ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      " (зависящий от выбора базисов), для которого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{fsize}_2 (h) \\le P(\\text{fsize}_1(h))"
        ]
      },
      " при всех ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      ".\n(Указание: использовать теорему ",
      {
        "name": "label",
        "props": {
          "ref": "formula-size-depth"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "formula-size-depth_link"
            },
            "children": []
          }
        ]
      },
      ".)\n"
    ]
  },
  "\n",
  "\n",
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 2
    },
    "children": [
      "Литература"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "aho-hopcroft-ullman"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "aho-hopcroft-ullman_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "aho-hopcroft-ullman_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Ахо, Дж.Ульман, Дж.Хопкрофт. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Построение и анализ\nвычислительных алгоритмов"
            ]
          },
          ", пер. с англ. А.О.Слисенко\nпод редакцией Ю.В.Матиясевича. М.:Мир, 1979.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "boolos-jeffrey"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "boolos-jeffrey_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "boolos-jeffrey_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Дж.Булос, Р.Джеффри. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Вычислимость и логика"
            ]
          },
          ",\nпер. с англ. В.А.Душского и Е.Ю.Ногиной под\nредакцией С.Н.Артёмова.\nМ.:Мир, 1994. 396 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "bourbaki"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "bourbaki_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "bourbaki_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Н.Бурбаки.  ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Начала математики.   Первая часть.  Основные\nструктуры анализа. Книга первая. Теория множеств"
            ]
          },
          ",\nпер. с французского Г.Н.Поварова и\nЮ.А.Шихановича под редакцией В.А.Успенского.\nМ.:Мир, 1965.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "vanderwaerden"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "vanderwaerden_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "vanderwaerden_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "\nБ.Л. ван дер Варден. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Алгебра"
            ]
          },
          ", перевод с немецкого\nА.А.Бельского. Под редакцией Ю.И.Мерзлякова. М.:Наука,\nглавная редакция физико-математической литературы, 1976.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "computable-functions"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "computable-functions_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "computable-functions_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Н.К.Верещагин, А.Шень. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Лекции по математической логике и\nтеории алгоритмов. Часть 3. Вычислимые функции"
            ]
          },
          ". 3-е изд.\nМ.:МЦНМО, 2008.\n176 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "naive-set-theory"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "naive-set-theory_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "naive-set-theory_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Н.К.Верещагин, А.Шень. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Лекции по математической логике и\nтеории алгоритмов. Часть 1. Начала теории множеств"
            ]
          },
          ". 3-изд.\nМ.:МЦНМО, 2008. 128 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "heyting"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "heyting_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "heyting_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Гейтинг. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Интуиционизм. Введение"
            ]
          },
          ", пер. с\nангл. В.А.Янкова под редакцией и с комментариями\nА.А.Маркова. М.:Мир, 1965. 200 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "hilbert-bernays"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "hilbert-bernays_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "hilbert-bernays_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Д.Гильберт, П.Бернайс. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Основания математики.\nЛогические исчисления и формализация арифметики"
            ]
          },
          ", перевод с\nнемецкого Н.М.Нагорного под редакцией С.И.Адяна.\nМ.:Наука, главная редакция физико-математической литературы,\n1979. 560 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "gindikin"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "gindikin_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "gindikin_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.Г.Гиндикин. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Алгебра логики в задачах"
            ]
          },
          ". М.:Наука,\nглавная редакция физико-математической литературы, 1972.\n288 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "gladky-textbook"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "gladky-textbook_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "gladky-textbook_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.В.Гладкий. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ". М.:Российский\nгосударственный гуманитарный университет, 1998. 479 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "davis-nonstandard"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "davis-nonstandard_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "davis-nonstandard_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "М.Дэвис. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Прикладной нестандартный анализ"
            ]
          },
          ", перевод с\nангл. С.Ф.Сопрунова под редакцией и с предисловием\nВ.А.Успенского. М.:Мир, 1980. 236 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "ershov-palyutin"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "ershov-palyutin_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "ershov-palyutin_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Ю.Л.Ершов, Е.А.Палютин. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ". 2-е изд.\nМ.:Наука, главная редакция физико-математической литературы,\n1987. 336 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "keisler-chang"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "keisler-chang_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "keisler-chang_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Г.Кейслер, Ч.Ч.Чэн. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Теория моделей"
            ]
          },
          ",\nперевод с англ. С.С.Гончарова, С.Д.Денисова,\nВ.А.Душского и Д.И.Свириденко. Под редакцией\nЮ.Л.Ершова и А.Д.Тайманова. М.:Мир, 1977. 614 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kurosh"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kurosh_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kurosh_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Г.Курош. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Лекции по общей алгебре"
            ]
          },
          ", 2-е изд.\nМ.:Наука, главная редакция физико-математической литературы,\n1973. 399 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kleene-metamathematics"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kleene-metamathematics_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kleene-metamathematics_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.К.Клини. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в метаматематику"
            ]
          },
          ", перевод с английского\nА.С.Есенина-Вольпина под редакцией В.А.Успенского. М.:Издательство\nиностранной литературы, 1957. 526 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kleene-logic"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kleene-logic_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kleene-logic_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.К.Клини. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ", перевод с английского\nЮ.А.Гастева под редакцией Г.Е.Минца. М.:Мир, 1973. 480 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kleene-vesley"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kleene-vesley_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kleene-vesley_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.Клини, Р.Весли. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Основания интуиционистской\nматематики с точки зрения теории рекурсивных функций"
            ]
          },
          ", перевод с\nанглийского Ф.А.Кабакова и Б.А.Кушнера.\nМ.:Наука, главная редакция физико-математической литературы,\n1978. 272 с. (Серия: Математическая логика и основания математики.)\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "cormen-leiserson-rivest"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "cormen-leiserson-rivest_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "cormen-leiserson-rivest_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Т.Кормен, Ч.Лейзерсон, Р.Ривест. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Алгоритмы:\nпостроение и анализ"
            ]
          },
          ", пер. с англ. К.Белова,\nЮ.Боравлёва, Д.Ботина, В.Горелика, Д.Дерягина,\nЮ.Калнишкана, А.Катановой, С.Львовского,\nА.Ромащенко, К.Сонина, К.Трушкина, М.Ушакова,\nА.Шеня, В.Шувалова, М.Юдашкина под ред. А.Шеня,\nВ.Ященко. М.:МЦНМО, 1999. 960 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lavrov-maksimova"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "lavrov-maksimova_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "lavrov-maksimova_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "И.А.Лавров, Л.Л.Максимова. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Задачи по теории\nмножеств, математической логике и теории алгоритмов"
            ]
          },
          ", издание\nвторое. М.:Наука, 1984. 224 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lyndon"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "lyndon_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "lyndon_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Р.Линдон. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Заметки по логике"
            ]
          },
          ", пер. с английского\nЮ.А.Гастева под редакцией И.М.Яглома. М.:Мир, 1968.\n128 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "manin"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "manin_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "manin_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Ю.И.Манин. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Доказуемое и недоказуемое"
            ]
          },
          ".\nМ.:Советское радио, 1979. 168 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "robinson"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "robinson_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "robinson_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Робинсон. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в теорию моделей и метаматематику\nалгебры"
            ]
          },
          ", пер. с англ. А.Б.Волынского под редакцией\nА.Д.Тайманова. М.:Наука, главная редакция физикод\nматематической литературы, 1967. 376 с. (Серия: Математическая\nлогика и основания математики.)\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "smullyan-informal"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "smullyan-informal_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "smullyan-informal_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Рэймонд М.Смаллиан. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Как же называется эта книга?"
            ]
          },
          ",\nпер. с англ. Ю.А.Данилова. М.:Мир, 1981. 240 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "smullyan-formal"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "smullyan-formal_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "smullyan-formal_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Р.Смальян.\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Теория формальных систем"
            ]
          },
          ", перевод с английского\nН.К.Косовского под редакцией Н.А.Шанина. М.:Наука,\nглавная редакция физико-математической литературы, 1981.\n207 с. (Серия: Математическая логика и основания математики.)\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "handbook-sets"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "handbook-sets_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "handbook-sets_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Справочная книга по математической логике в четырёх частях\nпод ред. Дж.Барвайса. Часть II. Теория множеств"
            ]
          },
          ",\nпер. с англ. В.Г.Кановея под редакцией\nВ.Н.Гришина. М.:Наука, 1982. 376 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "handbook-recursion"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "handbook-recursion_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "handbook-recursion_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Справочная книга по математической логике в четырёх частях под\nред. Дж.Барвайса. Часть III. Теория рекурсии"
            ]
          },
          ",\nпер. с английского  С.Г.Дворникова, И.А.Лаврова.\nПод ред. Ю.Л.Ершова.\nМ.:Наука, 1982. 360 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "uspensky-nonstandard"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "uspensky-nonstandard_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "uspensky-nonstandard_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "В.А.Успенский. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Что такое нестандартный анализ?"
            ]
          },
          "\nМ.:Наука, главн. ред. физико-математической литературы,\n1987. 128 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "uspensky-nonstandard-small"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "uspensky-nonstandard-small_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "uspensky-nonstandard-small_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "В.А.Успенский.  ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Нестандартный, или неархимедов, анализ"
            ]
          },
          ".  М.:Знание, 1983. 61 с. (Новое в жизни, науке, технике.\nМатематика, кибернетика, №8.)\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "freudenthal"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "freudenthal_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "freudenthal_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Х.Фрейденталь. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Язык логики"
            ]
          },
          ", перевод с английского Ю.А.Петрова\nпод редакцией Ю.А.Гастева. М.:Наука, главная редакция физикод\nматематической литературы, 1969. 136 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "church"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "church_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "church_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Чёрч. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в математическую логику. I"
            ]
          },
          ",\nперевод с английского В.С.Чернявского под ред.\nВ.А.Успенского. М.:Издательство иностранной литературы,\n1960. 484 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "shoenfield"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "shoenfield_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "shoenfield_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Дж.Шенфилд. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ",\nперевод с английского И.А.Лаврова и И.А.Мальцева\nпод редакцией Ю.Л.Ершова. М.:Наука, 1975. 528 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "engeler"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "engeler_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "engeler_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Э.Энгелер. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Метаматематика элементарной математики"
            ]
          },
          ",\nперевод с немецкого Г.Е.Минца под редакцией А.О.Слисенко.\nМ:Мир, 1987. 128 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "cyber"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "cyber_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "cyber_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.В.Яблонский. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в дискретную математику"
            ]
          },
          ",\nиздание второе. М.:Наука, 1986. 384 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "keisler-nonstandard"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "keisler-nonstandard_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "keisler-nonstandard_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "H.J.Keisler. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Elementary Calculus"
            ]
          },
          ".\nWeber and Sсhmidt, Prindle, 1976.\n"
        ]
      }
    ]
  },
  "\n",
  "\n"
]
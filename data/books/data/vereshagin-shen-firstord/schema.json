[
  {
    "name": "counter",
    "props": {
      "start": "chapter",
      "initial": 1
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "start": "problem"
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "start": "theorem",
      "initial": 1
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "initial": "image"
    },
    "children": []
  },
  {
    "name": "counter",
    "props": {
      "initial": "lit"
    },
    "children": []
  },
  "ЛЕКЦИИ ПО МАТЕМАТИЧЕСКОЙ ЛОГИКЕ И ТЕОРИИ АЛГОРИТМОВ\n\n\n",
  {
    "name": "authors",
    "props": {},
    "children": [
      {
        "name": "link",
        "props": {
          "href": "http://lpcs.math.msu.su/~ver/"
        },
        "children": [
          "Н. К. Верещагин"
        ]
      },
      ",\n",
      {
        "name": "link",
        "props": {
          "href": "https://ru.wikipedia.org/wiki/Шень,_Александр_Ханиевич"
        },
        "children": [
          "А.Шень"
        ]
      },
      "\n"
    ]
  },
  "\n",
  {
    "name": "title",
    "props": {},
    "children": [
      "Языки и исчисления"
    ]
  },
  "\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Электронная версия в процессе адаптации, это предупреждение будет убрано по окончанию (Николаичев А.С.)"
    ]
  },
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 2
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "end": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "end": "table"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "use": "chapter"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "table"
        },
        "children": []
      },
      ". ",
      "Логика высказываний"
    ]
  },
  "\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Высказывания и операции"
    ]
  },
  "\n\n«Если число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " рационально, то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " — алгебраическое число.\nНо оно не алгебраическое. Значит, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  " не рационально.»\nМы не обязаны знать, что такое число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\pi"
    ]
  },
  ", какие числа называют рациональными и какие алгебраическими, чтобы признать, что это рассуждение правильно — в том смысле, что из двух сформулированных посылок действительно вытекает заключение.\nТакого рода ситуации — когда некоторое утверждение верно независимо от смысла входящих в него высказываний — составляют предмет ",
  {
    "name": "em",
    "props": {},
    "children": [
      "логики высказываний"
    ]
  },
  ".\n",
  "",
  "\n\n\nТакое начало (особенно если учесть, что курс логики входил в программу философского факультета, где также изучалась «диалектическая логика») настораживает, но на самом деле наши\n",
  "",
  "\nрассмотрения будут иметь вполне точный математический характер, хотя мы начнём с неформальных мотивировок.\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Высказывания"
    ]
  },
  "",
  " могут быть\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "истинными"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nи ",
  {
    "name": "em",
    "props": {},
    "children": [
      "ложными"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nНапример, «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{16}+1"
    ]
  },
  " — простое число» — истинное высказывание, а «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{32}+1"
    ]
  },
  " — простое число» — ложное (это число делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "641"
    ]
  },
  ").\nПро высказывание «существует бесконечно много простых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p+2"
    ]
  },
  " — также простое» никто не берётся сказать наверняка, истинно оно или ложно.\nЗаметим, что «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  "» в этом смысле не является высказыванием, пока не сказано, чему равно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "; при разных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " получаются разные высказывания, одни истинные (при чётном ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "), другие — ложные (при нечётном ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ").\n\n\nВысказывания можно соединять друг с другом с помощью «логических связок».\n",
  "",
  "\n",
  "",
  "\nЭти связки имеют довольно странные, но традиционные названия и обозначения (табл. ",
  {
    "name": "label",
    "props": {
      "ref": "logic-connectives-names"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "logic-connectives-names_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "table",
    "props": {
      "align": "center",
      "key": "logic-connectives-names",
      "name": "Логические связки, обозначения и названия."
    },
    "children": [
      "\n",
      {
        "name": "row",
        "props": {
          "head": true
        },
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " связка "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " обозначение "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " название"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " и ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\& B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\land B"
                ]
              },
              "\n\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\texttt{ and }B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "конъюнкция\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " или ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\lor B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\texttt{ or }B"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " дизъюнкция\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              "не ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " неверно\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\lnot A"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\sim\\!A"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\overline{A} "
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\texttt{not} A"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\nотрицание\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              "из ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " следует ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\nесли ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              ", то ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              " влечёт ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B"
                ]
              },
              " — следствие ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\rightarrow B"
                ]
              },
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\Rightarrow B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A\\supset B"
                ]
              },
              "\n\n",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\texttt{if }A\\texttt{ then }B"
                ]
              },
              "\n"
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              "\nимпликация\n\nследование\n",
              "",
              "\n"
            ]
          }
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\n",
      "",
      "\n",
      "",
      "\n",
      {
        "name": "area",
        "props": {
          "inline": true
        },
        "children": [
          "Таблица ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "logic-connectives-names_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "last": "chapter"
                },
                "children": []
              },
              ".",
              {
                "name": "counter",
                "props": {
                  "use": "table",
                  "key": "logic-connectives-names_counter"
                },
                "children": []
              }
            ]
          },
          ". ",
          "Логические связки, обозначения и названия."
        ]
      }
    ]
  },
  "\n\n\nОтметим также, что в импликации ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\Rightarrow B"
    ]
  },
  " высказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "посылкой"
    ]
  },
  ",\n",
  "",
  "\nили ",
  {
    "name": "em",
    "props": {},
    "children": [
      "антецедентом импликации"
    ]
  },
  ",\n",
  "",
  "\nа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " — ",
  {
    "name": "em",
    "props": {},
    "children": [
      "заключением"
    ]
  },
  ",\n",
  "",
  "\nили ",
  {
    "name": "em",
    "props": {},
    "children": [
      "консеквентом"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\n\n\nГоворят также, что высказывание имеет ",
  {
    "name": "em",
    "props": {},
    "children": [
      "истинностное значение"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\n",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " (истина),\n",
  "",
  "\nесли оно истинно, или ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " (ложь),\n",
  "",
  "\nесли оно ложно.\nИногда вместо ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " употребляется буква ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "T"
    ]
  },
  " (true) или число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nа вместо ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " — буква ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "F"
    ]
  },
  " (false) или число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  ".\n(С первого взгляда идея произвольным образом выбрать числа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " кажется дикой — какая бы польза могла быть от, скажем, сложения истинностных значений?\nУдивительным образом в последние годы обнаружилось, что такая польза есть, и если оперировать с истиной и ложью как элементами конечного поля, можно получить много неожиданных результатов.\nНо это выходит за рамки нашей книги.)\n\n\nЛогические связки позволяют составлять сложные высказывания из простых.\nПри этом истинность составного высказывания определяется истинностью его частей в соответствии с таблицей ",
  {
    "name": "label",
    "props": {
      "ref": "truth-tables"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "truth-tables_link"
        },
        "children": []
      }
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "truth-tables"
    },
    "children": [
      {
        "name": "table",
        "props": {},
        "children": [
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A\\land B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A\\lor B"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A \\to B"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n"
        ]
      },
      "\n\n",
      {
        "name": "table",
        "props": {},
        "children": [
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "A"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "\\lnot A"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "И"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "format.b",
                    "props": {},
                    "children": [
                      "Л"
                    ]
                  }
                ]
              }
            ]
          },
          "\n"
        ]
      },
      "\n\n",
      {
        "name": "area",
        "props": {
          "position": "center"
        },
        "children": [
          {
            "name": "format.small",
            "props": {},
            "children": [
              {
                "name": "format.i",
                "props": {},
                "children": [
                  "Таблица ",
                  {
                    "name": "area",
                    "props": {
                      "inline": true,
                      "key": "truth-tables_link"
                    },
                    "children": [
                      {
                        "name": "counter",
                        "props": {
                          "last": "chapter"
                        },
                        "children": []
                      },
                      ".",
                      {
                        "name": "counter",
                        "props": {
                          "use": "table"
                        },
                        "children": []
                      }
                    ]
                  },
                  ". Таблицы истинности для логических связок"
                ]
              },
              "\n"
            ]
          }
        ]
      }
    ]
  },
  "\n\nТе же правила можно изложить словесно.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\land B"
    ]
  },
  " истинно, если оба высказывания ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " истинны.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\lor B"
    ]
  },
  " истинно, если хотя бы одно из высказываний ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " истинно.\nВысказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to B"
    ]
  },
  " ложно в единственном случае: если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " истинно, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " ложно.\nНаконец, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  " истинно в том и только том случае, когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " ложно.\n\n\nИз всех связок больше всего вопросов вызывает импликация.\nВ самом деле, не очень понятно, почему надо считать, скажем, высказывания «если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=5"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=4"
    ]
  },
  "» и «если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2\\times 2=5"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "3\\times 3=1"
    ]
  },
  "» истинными.\n(Именно так говорят наши таблицы: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "Л\\toИ = Л\\toЛ = И"
    ]
  },
  ".)\nНа самом деле  в таком определении есть свой резон.\nВсе согласны, что если число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ", то оно делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\nЭто означает, что высказывание\n\n\n(",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\to"
    ]
  },
  " (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ")\n\n\nистинно при всех ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ".\n\nПодставим сюда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=5"
    ]
  },
  ": обе части ложны, а утверждение в целом истинно.\nПри ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=6"
    ]
  },
  " посылка импликации ложна, а заключение истинно, и вся импликация истинна.\nНаконец, при ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x=8"
    ]
  },
  " посылка и заключение истинны и импликация в целом истинна.\nС другой стороны, обратное утверждение (если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " делится на ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "4"
    ]
  },
  ") неверно, и число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " является контрпримером.\nПри этом посылка импликации истинна, заключение ложно, и сама импликация ложна.\nТаким образом, если считать, что истинность импликации определяется истинностью её частей (а не наличием между ними каких-то причинно-следственных связей), то все строки таблицы истинности обоснованы.\nЧтобы подчеркнуть такое узко-формальное понимание импликации, философски настроенные логики называют её «материальной импликацией».\n\n\nТеперь от неформальных разговоров перейдём к определениям.\nЭлементарные высказывания (из которых составляются более сложные) мы будем обозначать маленькими латинскими буквами и называть ",
  {
    "name": "em",
    "props": {},
    "children": [
      "пропозициональными переменными"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nИз них строятся ",
  {
    "name": "em",
    "props": {},
    "children": [
      "пропозициональные формулы"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nпо таким правилам:\n\n",
  {
    "name": "list",
    "props": {},
    "children": [
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Всякая пропозициональная переменная есть формула."
        ]
      },
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " — пропозициональная формула, то ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot A"
            ]
          },
          " — пропозициональная формула."
        ]
      },
      "\n\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          " — пропозициональные формулы, то ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\land B)"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\lor B)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to B)"
            ]
          },
          " — пропозициональные формулы."
        ]
      },
      "\n\n"
    ]
  },
  "\n\nМожно ещё сказать так: формулы образуют минимальное множество, обладающее указанными свойствами (слово «минимальное» здесь существенно: ведь если бы мы объявили любую последовательность переменных, скобок и связок формулой, то эти три свойства были бы тоже выполнены).\n\n\nПусть формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " содержит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " пропозициональных переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p_1,p_2,\\dots,p_n"
    ]
  },
  ".\nЕсли подставить вместо этих переменных истинностные значения (",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " или ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  "), то по таблицам можно вычислить истинностное значение формулы в целом.\nТаким образом, формула задаёт некоторую функцию от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов, каждый из которых может принимать значения ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " и ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  ".\nЗначения функции также лежат в множестве {",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  ", ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  "}, которое мы будем обозначать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B} "
    ]
  },
  ".\nМы будем следовать уже упоминавшейся традиции и отождествлять ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " с единицей, а ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " — с нулём, тем самым ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B} "
    ]
  },
  " есть ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\{0,1\\} "
    ]
  },
  ".\nФормула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " задаёт отображение типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}^n\\to\\Bbb{B} "
    ]
  },
  ".\nТакие отображения называют также ",
  {
    "name": "em",
    "props": {},
    "children": [
      "булевыми функциями ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Пример"
    ]
  },
  ". Рассмотрим формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\land (q\\land \\lnot r))"
    ]
  },
  ".\nОна истинна в единственном случае — когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинны, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "r"
    ]
  },
  " ложно (см. таблицу ",
  {
    "name": "label",
    "props": {
      "ref": "example-conjunct"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "example-conjunct_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "table",
    "props": {
      "key": "example-conjunct"
    },
    "children": [
      {
        "name": "row",
        "props": {
          "head": true
        },
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "p"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "q"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "r"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\lnot r"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(q \\land \\lnot r)"
                ]
              },
              " "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(p\\land(q\\land\\lnot r))"
                ]
              },
              "\n"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1"
            ]
          }
        ]
      },
      "\n",
      {
        "name": "row",
        "props": {},
        "children": [
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 1 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0 "
            ]
          },
          {
            "name": "cell",
            "props": {},
            "children": [
              " 0"
            ]
          }
        ]
      },
      "\nТаблица ",
      {
        "name": "area",
        "props": {
          "inline": true,
          "key": "example-conjunct_link"
        },
        "children": [
          {
            "name": "counter",
            "props": {
              "last": "chapter"
            },
            "children": []
          },
          ".",
          {
            "name": "counter",
            "props": {
              "use": "table"
            },
            "children": []
          }
        ]
      },
      ". Таблица истинности для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(p\\land(q\\land \\lnot r))"
        ]
      },
      ".\n"
    ]
  },
  "\n\nНекоторые формулы выражают логические законы — составные высказывания, истинные независимо от смысла их частей.\nТакие формулы (истинные при всех значениях входящих в них переменных) называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "тавтологиями"
    ]
  },
  ".\n",
  "",
  "\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Пример"
    ]
  },
  ". Формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p \\land q)\\to p)"
    ]
  },
  " является тавтологией (это можно проверить, например, составив таблицу).\nОна выражает такой логический закон: из конъюнкции утверждений следует первое из них.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Как выглядит симметричное утверждение для дизъюнкции и какая формула его выражает?\n"
    ]
  },
  "\n\n\nДве формулы называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "эквивалентными"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nесли они истинны при одних и тех же значениях переменных (другими словами, если они задают одну и ту же булеву функцию).\nНапример, легко проверить, что формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p \\land (p\\to q))"
    ]
  },
  " истинна лишь при ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p=q=И"
    ]
  },
  ", и потому эквивалентна формуле ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\land q)"
    ]
  },
  ".\n\n\nРассмотрим формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\land q)\\lor q)"
    ]
  },
  ".\nОна истинна, если переменная ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинна, и ложна, если переменная ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " ложна.\nХотелось бы сказать, что она эквивалентна формуле ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  ", но тут есть формальная трудность: она содержит две переменные и потому задаёт функцию от двух аргументов (типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}\\times\\Bbb{B}\\to\\Bbb{B} "
    ]
  },
  "), в то время как формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " задаёт функцию одного аргумента.\nМы не будем обращать на это внимания и будем считать эти формулы эквивалентными.\nВообще, если есть список переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p_1,\\dots,p_n"
    ]
  },
  ", содержащий все переменные некоторой формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " (и, возможно, ещё какие-то переменные), можно считать, что формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " задаёт функцию от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов, возможно, на деле зависящую не от всех аргументов (постоянную по некоторым аргументам)\n\n\nПосле сделанных оговорок легко проверить следующий факт: формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\psi"
    ]
  },
  " эквивалентны тогда и только тогда, когда формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((\\varphi\\to\\psi)\\land{(\\psi\\to\\varphi))} "
    ]
  },
  " является тавтологией.\nИспользуя сокращение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\leftrightarrow q)"
    ]
  },
  " для ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\to q)\\land{(q\\to p)})"
    ]
  },
  ", можно записывать утверждения об эквивалентности формул в виде тавтологий.\nВот несколько таких эквивалентностей:\n\n\n",
  {
    "name": "area",
    "props": {
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "Формулы\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{aligned}\n(p\\land q) &\\leftrightarrow (q \\land p);\\\\\n((p\\land q) \\land r) &\\leftrightarrow (p\\land (q \\land r));\\\\\n(p\\lor q) &\\leftrightarrow (q \\lor p);\\\\\n((p\\lor q) \\lor r) &\\leftrightarrow (p\\lor (q \\lor r));\\\\\n(p\\land(q\\lor r)) &\\leftrightarrow ((p\\land q)\\lor (p\\land r));\\\\\n(p\\lor(q\\land r)) &\\leftrightarrow ((p\\lor q)\\land (p\\lor r));\\\\\n\\lnot(p\\land q) &\\leftrightarrow (\\lnot p\\lor \\lnot q);\\\\\n\\lnot(p\\lor q) &\\leftrightarrow (\\lnot p\\land \\lnot q);\\\\\n(p\\lor (p \\land q)) &\\leftrightarrow p;\\\\\n(p\\land (p \\lor q)) &\\leftrightarrow p;\\\\\n(p\\to q) &\\leftrightarrow (\\lnot q\\to \\lnot p);\\\\\np &\\leftrightarrow \\lnot\\lnot p\n\\end{aligned}\n"
        ]
      },
      "\nявляются тавтологиями.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервые четыре эквивалентности выражают коммутативность и ассоциативность конъюнкции и дизъюнкции.\nПроверим, например, вторую: левая и правая части истинны в единственном случае (когда все переменные истинны), и потому эквивалентны.\n(Для дизъюнкции удобнее смотреть, когда она ложна.)\n\nДве следующие эквивалентности означают  дистрибутивность — заметим, что в отличие от сложения и умножения в кольцах здесь верны оба свойства дистрибутивности.\nПроверить эквивалентность легко, если отдельно рассмотреть случаи истинного и ложного ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ".\n\n\nСледующие два свойства, ",
      {
        "name": "em",
        "props": {},
        "children": [
          "законы Де Моргана"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nлегко проверить, зная, что конъюнкция истинна, а дизъюнкция ложна лишь в одном случае.\nЭти свойства иногда выражают словами: «конъюнкция двойственна дизъюнкции».\n\n\nДалее следуют два очевидных ",
      {
        "name": "em",
        "props": {},
        "children": [
          "закона поглощения"
        ]
      },
      "\n",
      "",
      "\n(один из них мы уже упоминали).\n\n\nЗа ними идёт правило ",
      {
        "name": "em",
        "props": {},
        "children": [
          "контрапозиции"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nкоторое говорит, в частности, что утверждения «если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " совершенно, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " чётно» и «если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " нечётно, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      " несовершенно»  равносильны.\nХотя оно и очевидно проверяется с помощью таблиц истинности, с ним связаны любопытные парадоксы.\nВот один из них.\n\n\nБиолог А выдвинул гипотезу: все вороны чёрные.\nПроверяя её, он вышел во двор и обнаружил на дереве ворону.\nОна оказалось чёрной.\nБиолог А радуется — гипотеза подтверждается.\nБиолог Б переформулировал гипотезу так: все не-чёрные предметы — не вороны (применив наше правило контрапозиции) и не стал выходить во двор, а открыл холодильник и нашёл там оранжевый предмет.\nОн оказался апельсином, а не вороной.\nБиолог Б обрадовался — гипотеза подтверждается — и позвонил биологу А.\nТот удивляется — у него тоже есть апельсин в холодильнике, но с его точки зрения никакого отношения к его гипотезе апельсин не имеет,",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\dots"
        ]
      },
      "\n\n\nДругой парадокс: с точки зрения формальной логики утверждения «кто не с нами, тот против нас» и «кто не против нас, тот с нами» равносильны.\n\n\nПоследнее (и очевидное) правило ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\leftrightarrow \\lnot\\lnot p"
        ]
      },
      " называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "снятием двойного отрицания"
        ]
      },
      ".\n",
      "",
      "\n",
      " ᐅ"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Перечисленные эквивалентности соответствуют свойствам операций на множествах: например, первая гарантирует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P\\cap Q=Q\\cap P"
        ]
      },
      " для любых множеств ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      ".\nКакие утверждения соответствуют остальным эквивалентностям?\n"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Две формулы, содержащие только переменные и связки ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot"
        ]
      },
      ", эквивалентны.\nДокажите, что они останутся эквивалентными, если всюду заменить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      " и наоборот.\n"
    ]
  },
  "\n\nДалеко не все тавтологии имеют ясный интуитивный смысл.\nНапример, формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\to q)\\lor(q\\to p)"
    ]
  },
  " является тавтологией (если одно из утверждений ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " ложно, то из него следует всё, что угодно; если оба истинны, то тем более формула истинна), хотя и отчасти противоречит нашей интуиции — почему, собственно, из двух никак не связанных утверждений одно влечёт другое?\nЕщё более загадочна тавтология\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n((p\\to q)\\to p)\\to p\n"
    ]
  },
  "\n(хотя её ничего не стоит проверить с помощью таблиц истинности).\n\n\n",
  {
    "name": "format.pre",
    "props": {},
    "children": [
      "Отступление о пользе скобок"
    ]
  },
  ".\n",
  "",
  "\nНа самом деле наше определение истинности содержит серьёзный пробел.\nЧтобы обнаружить его, зададим себе вопрос: зачем нужны скобки в формулах?\nПредставим себе, что мы изменим определение формулы, и будем говорить, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "P \\land Q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "P \\lor Q"
    ]
  },
  " являются формулами для любых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "Q"
    ]
  },
  ".\nОстанутся ли наши рассуждения в силе?\n\n\nЛегко понять, что мы столкнёмся с трудностью при определении булевой функции, соответствующей формуле.\nВ этом определении мы подставляли нули и единицы на место переменных и затем вычисляли значение формулы с помощью таблиц истинности для связок.\nНо теперь, когда мы изменили определение формулы, формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land q \\lor r"
    ]
  },
  " может быть получена двумя способами — из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "r"
    ]
  },
  " с помощью операции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor"
    ]
  },
  " и из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q\\lor r"
    ]
  },
  " с помощью операции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land"
    ]
  },
  ".\nЭти два толкования дадут разный результат при попытке вычислить значение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0 \\land 0 \\lor 1"
    ]
  },
  ".\n\n\nИз сказанного ясно, что скобки нужны, чтобы гарантировать однозначность синтаксического разбора формулы.\nТочнее говоря, верно такое утверждение:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "однозначность разбора",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "однозначность разбора",
          ")",
          ". "
        ]
      },
      "",
      "\nПропозициональная формула, не являющаяся переменной, может быть представлена ровно в одном из четырёх видов ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\lor B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " или ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " — некоторые формулы, причём ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " (в первых трёх случаях) восстанавливаются однозначно.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nФормальное доказательство можно провести так: назовём ",
      {
        "name": "em",
        "props": {},
        "children": [
          "скобочным итогом"
        ]
      },
      "\n",
      "",
      "\nразницу между числом открывающихся и закрывающихся скобок.\nИндукцией по построению формулы легко доказать такую лемму:\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма"
        ]
      },
      ". Скобочный итог формулы равен нулю.\nСкобочный итог любого начала формулы неотрицателен и равен нулю, лишь если это начало совпадает со всей формулой, пусто или состоит из одних символов отрицания.\n\nСлова «индукцией по построению» означают, что мы проверяем утверждение для переменных, а также доказываем, что если оно верно для формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ", то оно верно и для формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\lor B)"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ".\n\nПосле того как лемма доказана, разбор формулы проводится так: если она начинается с отрицания, то может быть образована лишь по третьему правилу.\nЕсли же она начинается со скобки, то надо скобку удалить, а потом искать непустое начало, имеющее нулевой скобочный итог и не оканчивающееся на знак логической операции.\nТакое начало единственно (как легко проверить, используя лемму).\nЭто начало и будет первой частью формулы.\nТем самым формула разбирается однозначно.\n",
      " ᐅ"
    ]
  },
  "\n\n\nНет смысла вдаваться в подробности этого (несложного) рассуждения: вообще-то алгоритмы разбора формул — это отдельная большая и практически важная тема (в первую очередь в связи с компиляторами).\nПриведённый нами алгоритм далеко не оптимален.\nС другой стороны, мы вообще можем обойти эту проблему, потребовав, чтобы при записи формул левая и правая скобки, окружающие формулу, связывались линией — тогда однозначность разбора формулы не вызывает вопросов, и больше ничего нам не надо.\n\n\nВ дальнейшем мы будем опускать скобки, если они либо не играют роли (например, можно написать конъюнкцию трёх членов, не указывая порядок действий в силу ассоциативности), либо ясны из контекста.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Польский логик Лукасевич",
      "",
      " предлагал обходиться без скобок, записывая в формулах сначала знак операции, а потом операнды (без пробелов и разделителей).\nНапример, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)\\times(c+(d\\times e))"
        ]
      },
      " в его обозначениях запишется как ",
      {
        "name": "math",
        "props": {},
        "children": [
          "{{\\times}{+}ab{+}c{\\times}{d} {e}}"
        ]
      },
      ".\nЭту запись ещё называют ",
      {
        "name": "em",
        "props": {},
        "children": [
          "польской"
        ]
      },
      "\n",
      "",
      "\nзаписью.\n",
      {
        "name": "em",
        "props": {},
        "children": [
          "Обратная"
        ]
      },
      " польская запись отличается от неё тем, что знак операции идёт после операндов.\nПокажите, что в обоих случаях порядок действий восстанавливается однозначно.\n"
    ]
  },
  "\n",
  "\n\n",
  {
    "name": "header",
    "props": {
      "key": "complete-connectives",
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Полные системы связок"
    ]
  },
  "\n\n\nРассматриваемая нами система пропозициональных связок (в неё входят ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\to"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot"
    ]
  },
  ") ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полна"
    ]
  },
  "\n",
  "",
  "\nв следующем смысле:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "Полнота системы связок",
      "key": "completeness-connectives",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "completeness-connectives_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "completeness-connectives_link"
            },
            "children": []
          },
          " (",
          "Полнота системы связок",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nЛюбая булева функция (с любым числом аргументов) может быть записана в виде пропозициональной формулы.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПроще всего пояснить это на примере.\nПусть, например, булева функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p,q,r)"
        ]
      },
      " задана таблицей ",
      {
        "name": "label",
        "props": {
          "ref": "sample-truth-table"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "sample-truth-table_link"
            },
            "children": []
          }
        ]
      },
      ".\n\n\n",
      {
        "name": "table",
        "props": {
          "key": "sample-truth-table"
        },
        "children": [
          "\n",
          {
            "name": "row",
            "props": {
              "head": true
            },
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "p"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "q"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "r"
                    ]
                  },
                  " "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " ",
                  {
                    "name": "math",
                    "props": {
                      "block": false
                    },
                    "children": [
                      "\\varphi(p,q,r)"
                    ]
                  }
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 0"
                ]
              }
            ]
          },
          "\n",
          {
            "name": "row",
            "props": {},
            "children": [
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1 "
                ]
              },
              {
                "name": "cell",
                "props": {},
                "children": [
                  " 1"
                ]
              }
            ]
          },
          "\n\n",
          {
            "name": "area",
            "props": {
              "align": "center"
            },
            "children": [
              {
                "name": "math",
                "props": {
                  "block": true
                },
                "children": [
                  "\n\\begin{aligned}\n     (\\lnot p \\land \\lnot q \\land \\lnot r) &\\lor\\\\\n  \\lor   (\\lnot p \\land q \\land r) &\\lor\\\\\n  \\lor   (p \\land q       \\land r)& \\phantom{\\lor} \\\\\n\\end{aligned}\n"
                ]
              },
              "\n"
            ]
          },
          "\n\nТаблица ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "sample-truth-table_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "last": "chapter"
                },
                "children": []
              },
              ".",
              {
                "name": "counter",
                "props": {
                  "use": "table"
                },
                "children": []
              }
            ]
          },
          ". Булева функция и задающая её формула.\n"
        ]
      },
      "\n\n\nВ таблице есть три строки с единицами в правой колонке — три случая, когда булева функция истинна (равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ").\nНапишем три конъюнкции, каждая из которых покрывает один случай (а в остальных строках ложна), и соединим их дизъюнкцией.\nНужная формула построена.\n\n\nЯсно, что аналогичная конструкция применима для любой таблицы (с любым числом переменных).\n",
      " ᐅ"
    ]
  },
  "\n\n\nДля формул подобного вида есть специальное название: формулы в ",
  {
    "name": "em",
    "props": {},
    "children": [
      "дизъюнктивной нормальной форме"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\nБолее подробно:\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "литералом"
    ]
  },
  "\n",
  "",
  "\nназывается переменная или отрицание переменной,\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "конъюнктом"
    ]
  },
  "\n",
  "",
  "\nназывается произвольная конъюнкция литералов, а дизъюнктивной нормальной формой называется дизъюнкция конъюнктов.\nВ нашем случае в каждый конъюнкт входит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " литералов (где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " — число переменных), а число конъюнктов равно числу строк с единицами и может меняться от нуля (тогда, правда, получается не совсем формула, а «пустая дизъюнкция», и её можно заменить какой-нибудь всегда ложной формулой типа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land \\lnot p"
    ]
  },
  ") до ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^n"
    ]
  },
  " (если булева функция всегда истинна).\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДлина построенной в доказательстве теоремы ",
      "",
      " формулы зависит от числа единиц: формула будет короткой, если единиц в таблице мало.\nА как написать (сравнительно) короткую формулу, если в таблице мало нулей, а в основном единицы?\n"
    ]
  },
  "\n\n\nИногда полезна двойственная ",
  {
    "name": "em",
    "props": {},
    "children": [
      "конъюнктивная нормальная форма"
    ]
  },
  ",\n",
  "",
  "\n",
  "",
  "\nкоторая представляет собой конъюнкцию ",
  {
    "name": "em",
    "props": {},
    "children": [
      "дизъюнктов"
    ]
  },
  ".\n",
  "",
  "\nКаждый дизъюнкт состоит из литералов, соединённых дизъюнкциями.\nТеорему ",
  "",
  " можно теперь усилить так:\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "dnf-cnf",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "dnf-cnf_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "dnf-cnf_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nВсякая булева функция может быть выражена формулой, находящейся в дизъюнктивной нормальной форме, а также формулой, находящейся в конъюнктивной нормальной форме.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервая часть утверждения уже доказана.\nВторая часть аналогична первой, надо только для каждой строки с нулём написать подходящий дизъюнкт.\n\n\nМожно также представить функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot \\varphi"
        ]
      },
      " в дизъюнктивной нормальной форме, а затем воспользоваться законами Де Моргана,\n",
      "",
      "\nчтобы внести отрицание внутрь.\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Проведите второй вариант рассуждения подробно."
    ]
  },
  "\n\n\nВообще говоря, определение нормальной формы не требует, чтобы в каждом конъюнкте (или дизъюнкте) встречались все переменные.\n(Повторять переменную больше одного раза смысла нет; если, например, переменная и её отрицание входят в одну конъюнкцию, то эта конъюнкция всегда ложна и её можно выбросить.)\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Приведите пример булевой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "~аргументов, у которой любая дизъюнктивная или конъюнктивная нормальная форма содержит лишь члены длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n(Указание: рассмотрите функцию, которая меняет своё значение при изменении значения любой переменной.)\n"
    ]
  },
  "\n\n\nЗаметим, что при доказательстве теоремы ",
  "",
  " мы обошлись без импликации.\nЭто и не удивительно, так как она выражается через дизъюнкцию и отрицание:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\to q) \\ \\leftrightarrow \\ (\\lnot p \\lor q)\n"
    ]
  },
  "\n(проверьте!).\nМы могли бы обойтись только конъюнкцией и отрицанием, так как ",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\lor q) \\ \\leftrightarrow \\ \\lnot(\\lnot p \\land \\lnot q),\n"
    ]
  },
  "\nили только дизъюнкцией и отрицанием, так как ",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p\\land q) \\ \\leftrightarrow \\ \\lnot(\\lnot p \\lor \\lnot q)\n"
    ]
  },
  "\n(обе эквивалентности вытекают из законов Де Моргана; их легко проверить и непосредственно).\nКак говорят, система связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land, \\lnot"
    ]
  },
  ", а также система связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor, \\lnot"
    ]
  },
  " являются ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полными"
    ]
  },
  ".\n",
  "",
  "\n(По определению это означает, что с их помощью можно записать любую булеву функцию.)\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "Докажите, что система связок ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot, \\to"
        ]
      },
      " полна.\n(Указание: как записать через них дизъюнкцию?)\n"
    ]
  },
  "\n\n\nА вот без отрицания обойтись нельзя.\nСистема связок ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land, \\lor,\\to"
    ]
  },
  " неполна — и по очень простой причине: если все переменные истинны, то любая их комбинация, содержащая только указанные связки, истинна.\n(Как говорят, все эти связки «сохраняют единицу».)\n",
  "",
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nЛюбая формула, составленная только с помощью связок ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      ", задаёт монотонную булеву функцию ",
      "",
      "\n",
      "",
      "\n(в том смысле, что от увеличения значения любого из аргументов значение функции может только возрасти — или остаться прежним).\nПокажите, что верно и обратное: любая монотонная булева функция либо постоянна (всюду истинна или всюду ложна), либо может быть выражена формулой, содержащей только ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi\\to\\psi"
        ]
      },
      " — тавтология.\nПокажите, что найдётся формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\tau"
        ]
      },
      ", которая включает в себя только общие для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " переменные, для которой формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\varphi\\to\\tau)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\tau\\to\\psi)"
        ]
      },
      " являются тавтологиями.\n(Более общий вариант этого утверждения, в котором рассматриваются формулы с кванторами, называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "леммой Крейга"
        ]
      },
      ".)\n",
      "",
      "\n",
      "",
      "\n"
    ]
  },
  "\n\n\nВ принципе мы не обязаны ограничиваться четырьмя рассмотренными связками.\nЛюбая булева функция может играть роль связки.\nНапример, можно рассмотреть связку ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p \\texttt{ notand } q)"
    ]
  },
  ",\n",
  "",
  "\nзадаваемую эквивалентностью\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n(p \\texttt{ notand } q) \\ \\leftrightarrow \\ \\lnot(p\\land q)\n"
    ]
  },
  "\n(словами: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p\\texttt{ notand }q)"
    ]
  },
  " ложно, лишь если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинны).\nЧерез неё выражается отрицание (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p \\texttt{ notand }p"
    ]
  },
  "), после чего можно выразить конъюнкцию, а затем, как мы знаем, и вообще любую функцию.\n(Знакомые с цифровыми логическими схемами малого уровня интеграции хорошо знакомы с этим утверждением: достаточно большой запас схем И-НЕ позволяет реализовать любую требуемую зависимость выхода от входов.)\n\n\nДругая интересная полная система связок — сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ", конъюнкция и константа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " (которую можно считать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  "-арной связкой, задающей функцию от нуля аргументов).\nПредставленные в этой системе булевы функции становятся полиномами с коэффициентами в кольце вычетов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\nИдея рассматривать булевы функции как полиномы (оказавшаяся неожиданно плодотворной в последние годы) была высказана в 1927~г. российским математиком Иваном Ивановичем Жегалкиным.\n",
  "",
  "\n\n\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "мономом"
    ]
  },
  "\n",
  "",
  "\nконъюнкцию любого набора переменных или константу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " (которую естественно рассматривать как конъюнкцию нуля переменных).\nНазвание это естественно, так как при наших соглашениях (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " обозначает истину, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " — ложь) конъюнкция соответствует умножению.\n\n\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полиномом"
    ]
  },
  "\n",
  "",
  "\nсумму таких мономов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " (это значит, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0\\oplus0 =0"
    ]
  },
  ", ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0\\oplus 1=1\\oplus 0=1"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1\\oplus1=0"
    ]
  },
  ").\nЯсно, что два повторяющихся монома можно сократить (ведь сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  "), так что будем рассматривать только полиномы без повторяющихся мономов.\nПри этом, естественно, порядок членов в мономе (как и порядок мономов в полиноме) роли не играет, их можно переставлять.\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "о полиномах Жегалкина",
      "key": "polynomials-boolean-functions",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "polynomials-boolean-functions_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "polynomials-boolean-functions_link"
            },
            "children": []
          },
          " (",
          "о полиномах Жегалкина",
          ")",
          ". "
        ]
      },
      "",
      "\nВсякая булева функция однозначно представляется таким полиномом."
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nСуществование искомого полинома следует из теоремы ",
      "",
      ", так как конъюнкция есть умножение, отрицание — прибавление единицы, а дизъюнкцию можно через них выразить (получится ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p+q+pq"
        ]
      },
      ").\nНадо только заметить, что степени не нужны: переменные принимают значения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", так что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x^n"
        ]
      },
      " можно заменить на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      ".\n\n\nМожно также сослаться на известное из алгебры утверждение о том, что всякая функция с аргументами из конечного поля (в данном случае это двухэлементное поле вычетов по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") задаётся полиномом.\n(Так получается новое доказательство теоремы ",
      "",
      ".)\n\n\nДалее можно заметить, что полиномов столько же, сколько булевых функций, а именно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^n} "
        ]
      },
      ".\nВ самом деле, булева функция может принимать любое из двух значений в каждой из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " точек булева куба ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}^n"
        ]
      },
      ", а многочлен может включать или не включать любой из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " мономов.\n(Мономов ровно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      ", потому что каждый моном включает или не включает любую из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменных.)\nПоэтому избытка полиномов нет, и если любая функция представима полиномом, то единственным образом.\n\n\nМожно и не ссылаться на сведения из алгебры и теорему ",
      "",
      ", а дать явную конструкцию.\nЭто удобно сделать индукцией по ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\nПусть мы уже умеем представлять любую булеву функцию от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n-1"
        ]
      },
      " аргументов с помощью полинома.\nТогда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p_1,\\dots,p_n)"
        ]
      },
      " можно представить как\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\varphi(p_1,\\dots,p_n) =\n\\varphi(0, p_2,\\dots,p_{n})\n+[\\varphi(0,p_2,\\dots,p_{n})+\n\\varphi(1,p_2,\\dots,p_{n})]p_1\n"
        ]
      },
      "\n(проверьте).\nОстаётся заметить, что правую часть можно представить полиномом по предположению индукции.\n\n\nДля единственности также есть другое доказательство: пусть два многочлена (имеющие степень ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      " по каждой переменной) равны при всех значениях переменных.\nТогда их сумма (или разность —\nвычисления происходят по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") является ненулевым многочленом (содержит какие-то мономы), но тождественно равна нулю.\nТак не бывает, и это легко доказать по индукции.\nВ самом деле, любой многочлен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A(p_1,\\dots,p_n)"
        ]
      },
      " можно представить в виде\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\nA(p_1,\\dots,p_n)=B(p_2,\\dots,p_n)+p_1C(p_2,\\dots,p_n),\n"
        ]
      },
      "\nгде ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " — многочлены от меньшего числа переменных.\nПодставляя сначала ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1=0"
        ]
      },
      ", а затем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1=1"
        ]
      },
      ", убеждаемся,\nчто многочлены ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " равны нулю во всех точках, и потому (согласно предположению индукции) равны нулю как многочлены (не содержат мономов).\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " — произвольное поле.\n",
      "",
      "\nНазовём ",
      {
        "name": "em",
        "props": {},
        "children": [
          "мультилинейной"
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\nфункцией полином от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменных с коэффициентами из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ", в котором все показатели степеней равны либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\n(Таким образом, каждый моном в ней есть произведение коэффициента и некоторого набора переменных без повторений.) Будем рассматривать ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}=\\{0,1\\} "
        ]
      },
      " как подмножество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\nДокажите, что всякая булева функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Bbb{B}^n\\to\\Bbb{B} "
        ]
      },
      " однозначно продолжается до мультилинейной функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F^n\\to F"
        ]
      },
      ", и коэффициенты мультилинейной функции можно считать целыми числами.\n"
    ]
  },
  "\n\n\nЕсли рассматривать произвольные булевы функции в качестве связок, возникает вопрос: в каком случае набор булевых функций образует полный базис? (Это значит, что любая булева функция представляется в виде композиции функций из набора,  —е записывается в виде формулы, где связками служат функции набора.) Подобные вопросы вызывали в своё время большой интерес и были хорошо изучены.\nНачальным этапом явилось такое утверждение:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "критерий Поста",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "критерий Поста",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\nНабор булевых функций является полным тогда и только тогда, когда он не содержится целиком ни в одном из пяти следующих « предполных классов»:\n",
      "",
      "\n\n\n",
      {
        "name": "list",
        "props": {},
        "children": [
          {
            "name": "item",
            "props": {},
            "children": [
              "монотонные функции;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "функции, сохраняющие нуль;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "функции, сохраняющие единицу;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "линейные функции;"
            ]
          },
          "\n",
          {
            "name": "item",
            "props": {},
            "children": [
              "самодвойственные функции."
            ]
          },
          "\n"
        ]
      },
      "\n\n\n(Функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "монотонна"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли она монотонно неубывает по каждому из своих аргументов.\nФункция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "сохраняет нуль/единицу"
        ]
      },
      ",\n",
      "",
      "\nесли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(0,\\dots,0)=0"
        ]
      },
      " (соответственно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(1,\\dots,1)=1"
        ]
      },
      ").\nФункция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "линейна"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли она представима многочленом, в котором все мономы содержат не более одной переменной.\nНаконец, функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " называется ",
      {
        "name": "em",
        "props": {},
        "children": [
          "самодвойственной"
        ]
      },
      ",\n",
      "",
      "\n",
      "",
      "\nесли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(1-p_1,\\dots,1-p_n)=1-f(p_1,\\dots,p_n)"
        ]
      },
      ".)\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nЕсли набор содержится в одном из классов, то и все композиции также не выходят за пределы этого класса (легко проверить для каждого из классов в отдельности) и поэтому набор не является полным.\nДокажем обратное утверждение.\nПусть для каждого класса выбрана какая-то функция, в нём не лежащая.\nУбедимся, что с помощью комбинаций выбранных функций можно получить все булевы функции.\n\n\nУ нас есть функция, не сохраняющая нуль.\nПодставим вместо всех аргументов одну и ту же переменную.\nПолучится функция от одного аргумента, отображающая нуль в единицу, то есть либо константа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", либо отрицание.\nСделав то же самое с функцией, не сохраняющей единицу, получим либо константу нуль, либо отрицание.\nТаким образом, у нас либо есть отрицание, либо обе константы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\n\n\nЕсли есть обе константы, то всё равно можно получить отрицание.\nВозьмём немонотонную функцию.\nЛегко понять, что она должна менять значение с единицы на нуль при изменении какого-то одного аргумента с нуля на единицу (в самом деле, будем увеличивать аргументы по одному, в какой-то момент значение функции уменьшится.)\nЗафиксировав значения остальных аргументов (ведь мы считаем, что константы есть), получаем отрицание.\n\n\nИмея отрицание и несамодвойственную функцию, легко получить константы (если их не было).\nВ самом деле, несамодвойственность означает, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(x_1,\\dots,x_n)=f(1-x_1,\\dots,1-x_n)"
        ]
      },
      "\nдля каких-то значений ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n\\in\\{0,1\\} "
        ]
      },
      ".\nВместо нулевых значений переменных ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n"
        ]
      },
      " подставим ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ",\nвместо единиц подставим ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p"
        ]
      },
      ", получится одна из констант.\nВторая получится отрицанием.\n\n\nТеперь у нас есть константы, отрицание и нелинейная функция ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f(p_1,\\dots,p_n)"
        ]
      },
      ".\nНелинейность означает, что в её представлении в виде многочлена есть моном, состоящий более чем из одной переменной.\nПусть, например, этот моном содержит переменные ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_2"
        ]
      },
      ".\nСгруппируем члены по четырём группам и получим выражение\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\np_1p_2 A(p_3,\\dots)+p_1B(p_3,\\dots)+p_2C(p_3,\\dots)+D(p_3,\\dots).\n"
        ]
      },
      "\nПри этом многочлен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A(p_3,\\dots)"
        ]
      },
      " заведомо отличен от нуля, поэтому можно так подставить константы вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_3,\\dots,p_n"
        ]
      },
      ", чтобы первое слагаемое не обратилось в нуль.\nТогда получим либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2 + p_1+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_2+d"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1+p_2+d"
        ]
      },
      ".\nСвободный член ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "d"
        ]
      },
      " можно менять, если нужно (у нас есть отрицание), так что получается либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2"
        ]
      },
      "\n(конъюнкция, и всё доказано), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1=p_1(p_2+1)= p_1\\land\\lnot p_2"
        ]
      },
      " (убираем отрицание, получаем конъюнкцию, всё доказано), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_2"
        ]
      },
      " (аналогично), либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2+p_1+p_2= (1+p_1)(1+p_2)-1=\\lnot(\\lnot p_1\\land\\lnot p_2)=p_1\\lor p_2"
        ]
      },
      " (дизъюнкция, всё доказано).\n",
      " ᐅ"
    ]
  },
  "\n",
  "\n\n",
  "\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Схемы из функциональных элементов"
    ]
  },
  "\n",
  "",
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img1.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img1.png"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img2.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img2.png"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img3.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img3.png"
    },
    "children": []
  },
  "\n",
  {
    "name": "resource",
    "props": {
      "path": "/img4.png",
      "src": "/data/books/data/vereshagin-shen-firstord/1/3/img4.png"
    },
    "children": []
  },
  "\n\nФормулы представляют собой способ записи композиции функций.\nНапример, если мы сначала применяем функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  ", а потом функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "g"
    ]
  },
  ", это можно записать формулой ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "g(f(x))"
    ]
  },
  ".\nНо есть и другой способ: можно изобразить каждую функцию в виде прямоугольника с « входом» и « выходом» и соединить выход функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  " со входом функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "g"
    ]
  },
  " (рис. ",
  {
    "name": "label",
    "props": {
      "ref": "scheme-1"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "scheme-1_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n",
  {
    "name": "image",
    "props": {
      "src": "/img1.png",
      "key": "scheme-1",
      "height": 0.5
    },
    "children": [
      {
        "name": "area",
        "props": {
          "inline": true
        },
        "children": [
          "Рис. ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "scheme-1_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "image",
                  "key": "scheme-1_counter"
                },
                "children": []
              }
            ]
          },
          ". ",
          "Два способа изобразить композицию ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "g\\circ f"
            ]
          },
          ".\n"
        ]
      }
    ]
  },
  "\n\n\nТакое представление отнюдь не является чисто теоретическим.\nУже больше полувека электронная промышленность выпускает микросхемы, которые выполняют логические операции.\nТакая микросхема имеет электрические контакты, напряжение на которых кодирует логические значения ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  " и ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  ".\nКонкретное напряжение зависит от типа схемы, но обычно это несколько вольт, и высокий потенциал (относительно заземления) считается единицей, а низкий нулём.\n\n\nОдной из типичных схем является схема И-НЕ, она имеет два входа и один выход.\nСигнал на выходе является отрицанием конъюнкции сигналов на входе.\nДругими словами, на выходе появляется высокий потенциал (сигнал ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ") тогда и только тогда, когда на одном из входов потенциал низкий (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  ").\nИз такой схемы легко получить схему НЕ (изменяющую уровень сигнала на противоположный), соединив проводом два входа.\nПри этом на оба входа поступает один и тот же сигнал, и операция И его не меняет (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\land p=p"
    ]
  },
  "), а НЕ меняет на противоположный.\nВзяв два элемента И-НЕ и используя второй из них в качестве элемента НЕ, инвертирующего сигнал с выхода первого элемента, получаем схему, которая реализует функцию И.\nА если поставить два элемента НЕ перед каждым из входов элемента И-НЕ, получим схему, реализующую функцию ИЛИ: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot (\\lnot p\\land\\lnot q) \\leftrightarrow (p\\lor q)"
    ]
  },
  ".\n\n\nТеорема ",
  {
    "name": "label",
    "props": {
      "ref": "completeness-connectives"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "completeness-connectives_link"
        },
        "children": []
      }
    ]
  },
  " о полноте системы связок ",
  "",
  "\nтеперь гарантирует, что любую булеву функцию можно реализовать в виде схемы.\nНадо иметь в виду, однако, что предлагаемая в её доказательстве конструкция (дизъюнктивная нормальная форма)\n",
  "",
  "\nимеет скорее теоретический интерес, поскольку приводит к схемам очень большого размера даже для простых функций (если число аргументов велико).\nНапример, схема, сравнивающая два ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "16"
    ]
  },
  "-битных числа, должна иметь ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "32"
    ]
  },
  " входа и поэтому в её реализации с помощью дизъюнктивной нормальной формы будет порядка ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{32} "
    ]
  },
  "\nэлементов— что мало реально. (Между тем такую схему можно построить гораздо проще, из нескольких сотен элементов.)\n\n\nПоэтому вопрос о том, сколько элементов нужно для реализации той или иной функции, представляет большой интерес— как практический, так и философский.\n(Одна из центральных проблем математики и информатики, так называемая « проблема перебора», ",
  "",
  "\nможет быть сформулирована в этих терминах.)\n\n\nМы сейчас дадим более формальное определение схемы и реализуемой ей булевой функции.\nНо прежде всего ответим на такой вопрос— почему мы вообще говорим о схемах? Ведь можно записать композицию булевых функций в виде формулы, не будет ли это то же самое?\n\n\nОказывается, не совсем, и разницу легко увидеть на примере (рис. ",
  {
    "name": "label",
    "props": {
      "ref": "scheme-2"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "scheme-2_link"
        },
        "children": []
      }
    ]
  },
  ").\n\n\n",
  {
    "name": "image",
    "props": {
      "src": "/img2.png",
      "key": "scheme-2",
      "height": 0.5
    },
    "children": [
      {
        "name": "area",
        "props": {
          "inline": true
        },
        "children": [
          "Рис. ",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "scheme-2_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "image",
                  "key": "scheme-2_counter"
                },
                "children": []
              }
            ]
          },
          ". ",
          "Элемент входит в формулу дважды."
        ]
      }
    ]
  },
  "\n\nЗдесь один и тот же элемент схемы (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  ") приходится указывать в формуле дважды, поскольку его выход используется в качестве входа двух других элементов.\nСхемы, в которых такого ветвления нет (на практике ветвление вполне возможно, хотя и ограничено « нагрузочной способностью выхода», как говорят инженеры), как раз и соответствуют формулам.\nНо в общем случае полученная из данной схемы формула может быть длинной, даже если схема содержит небольшое число элементов, поскольку число копий может расти экспоненциально с ростом глубины схемы.\n\n\nХотя идея построения схемы из функциональных элементов, реализующих булевы функции, достаточно наглядна, дадим более формальное определение.\nФиксируем некоторый набор булевых функций ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ".\nПусть имеется ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " булевых (принимающих значения ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ")\nпеременных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x_1,\\dots,x_n"
    ]
  },
  ", называемых ",
  {
    "name": "em",
    "props": {},
    "children": [
      "входами"
    ]
  },
  ".\n",
  "",
  "\nПусть также имеется некоторое число булевых переменных ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_1,\\dots,y_m"
    ]
  },
  ", называемых ",
  {
    "name": "em",
    "props": {},
    "children": [
      "проводниками"
    ]
  },
  ".\n",
  "",
  "\nПусть для каждого проводника схемы задана булева функция из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ", выражающая его значение через другие проводники и входы.\nПри этом требуется, чтобы не было циклов (цикл образуется, когда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_i"
    ]
  },
  " зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_j"
    ]
  },
  ", которое зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_k"
    ]
  },
  ", dots, которое зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_i"
    ]
  },
  ").\nПусть, кроме того, среди проводников выделен один, называемый ",
  {
    "name": "em",
    "props": {},
    "children": [
      "выходом"
    ]
  },
  ".\n",
  "",
  "\nВ таком случае говорят, что задана ",
  {
    "name": "em",
    "props": {},
    "children": [
      "схема из функциональных элементов в базисе ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      }
    ]
  },
  "\n",
  "",
  "\nс ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " входами.\nЧисло ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "m"
    ]
  },
  " называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "размером"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nсхемы.\n(С точки зрения инженера размер— это число использованных элементов, а базис ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "— это ассортимент доступных ему элементов.)\n\n\nОтсутствие циклов гарантирует, что есть проводник, зависящий только от входов (иначе можно было бы найти цикл: возьмём какой-то проводник, затем возьмём тот проводник, от которого он зависит и т.д.).\nЗначение этого проводника, таким образом, однозначно определяется сигналами на входах.  Среди оставшихся проводников также нет цикла, поэтому можно найти один из них, зависящий только от уже известных, и определить его значение.\nПеренумеровав проводники в таком порядке, мы можем записать последовательность присваиваний\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{aligned}\n    y_1&:= f_1(\\dots);\\\\\n    y_2&:= f_2(\\dots);\\\\\n       \\dots\\\\\n    y_m&:= f_m(\\dots),\\\\\n\\end{aligned}\n"
    ]
  },
  "\nв правых частях которых стоят функции из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ", применённые ко входам и уже найденным значениям.\nПри этом можно считать, что результат схемы есть ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_m"
    ]
  },
  "\n(как только результат получен, дальнейшие присваивания уже не нужны).\nТакая программа определяет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y_m"
    ]
  },
  " при известных значениях входов, и тем самым ",
  {
    "name": "em",
    "props": {},
    "children": [
      "вычисляет"
    ]
  },
  "\n",
  "",
  "\nнекоторую булеву функцию.\n\n\nТеперь набор булевых функций ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " можно назвать ",
  {
    "name": "em",
    "props": {},
    "children": [
      "полным"
    ]
  },
  ", ",
  "",
  "\nесли любая булева функция может быть задана схемой из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "-элементов (существует программа, её вычисляющая, при этом в правых частях присваиваний стоят функции из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ").\nЯсно, что это определение полноты равносильно прежнему, то есть возможности записать булеву функцию в виде формулы со связками из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " (как мы говорили, разница только в том, что один и тот же элемент будет фигурировать в формуле многократно).\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Сложностью"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nбулевой функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  " относительно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " называют минимальный размер схемы из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "-элементов, вычисляющей функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "f"
    ]
  },
  ".\nЕго обозначают ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}_B(f)"
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "size-invariant",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "size-invariant_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "size-invariant_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_2"
        ]
      },
      "— два полных набора булевых функций.\nТогда соответствующие меры сложности отличаются не более чем на постоянный множитель:\nнайдётся такое число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ", что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{size}_{B_1}(f)\\le C\\text{size}_{B_2}(f)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{size}_{B_2}(f)\\le C\\text{size}_{B_1}(f)"
        ]
      },
      "\nдля любой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nУтверждение почти очевидно: поскольку наборы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_2"
        ]
      },
      " полны, то каждая функция одного из наборов может быть вычислена какой-то схемой, составленной из элементов другого набора.\nТеперь можно взять в качестве ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " наибольший размер таких схем, и неравенства будут выполняться: каждую строку программы можно заменить на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " (или меньше) строк с использованием функций другого набора.\n",
      " ᐅ"
    ]
  },
  "\n\nЧто можно сказать о сложности произвольной булевой функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "\nаргументов? Следующая теорема показывает, что она экспоненциально зависит от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " (для «наугад взятой» функции).\n",
  "",
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "generic-size",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "generic-size_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "generic-size_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ") Пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c>2"
        ]
      },
      ".\nТогда сложность любой булевой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов не превосходит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c^n"
        ]
      },
      " для всех достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ") Пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c<2"
        ]
      },
      ".\nТогда сложность большинства булевых функций ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c^n"
        ]
      },
      " для всех достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПрежде всего заметим, что по предыдущей теореме не имеет значения, какой полный базис выбрать (изменение значения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      " более существенно, чем умножение сложности на константу).\n\nПервое утверждение теоремы очевидно: размер схемы, реализующей дизъюнктивную нормальную форму ",
      "",
      "\nс ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " переменными, есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n2^n)"
        ]
      },
      ", поскольку имеется не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " конъюнктов размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ". (Напомним смысл ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O"
        ]
      },
      "-обозначений: ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n2^n)"
        ]
      },
      " означает, что существует верхняя оценка вида ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Cn2^n"
        ]
      },
      " для некоторой константы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ".) Осталось заметить, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n2^n)<c^n"
        ]
      },
      " при достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " (напомним, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c>2"
        ]
      },
      ").\n\nЧтобы доказать второе утверждение, оценим число различных схем (скажем, в базисе И, ИЛИ, НЕ) размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументами.\nКаждая такая схема может быть описана последовательностью из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N"
        ]
      },
      " присваиваний, выражающих одну из переменных через предыдущие.\nДля каждого присваивания есть не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3(N+n)^2"
        ]
      },
      " вариантов (три типа операций— конъюнкция, дизъюнкция, отрицание, и каждый из не более чем двух аргументов выбирается среди не более чем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N+n"
        ]
      },
      " вариантов).\nОтсюда легко получить оценку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{O(N\\log N)} "
        ]
      },
      " на число всех функций сложности не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N"
        ]
      },
      " (считая ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "N\\ge n"
        ]
      },
      ").\n\nВсего булевых функций с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументами имеется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^n} "
        ]
      },
      ".\nИз сравнения этих формул видно, что что при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c<2"
        ]
      },
      " и при достаточно больших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " булевы функции сложности меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c^n"
        ]
      },
      " составляют меньшинство, так как ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{O(c^n\\log c^n)} "
        ]
      },
      " много меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^n} "
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПроведите вторую часть рассуждения более подробно и покажите, что при некотором ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varepsilon>0} "
        ]
      },
      " сложность большинства булевых функций с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументами не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon2^n/n"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\nВерхнюю оценку теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "generic-size"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "generic-size_link"
        },
        "children": []
      }
    ]
  },
  " можно усилить и показать, что сложность любой булевой функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " аргументов не превосходит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(2^n/n)"
    ]
  },
  ".\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ") Покажите, что можно построить схему размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^m)"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^m"
        ]
      },
      " выходами, реализующую все ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^m"
        ]
      },
      " возможных конъюнктов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "m"
        ]
      },
      " (для каждого— свой выход). (Указание:\nтакую схему можно построить индуктивно.)\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ") Покажите, что можно построить схему размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^{2^m})"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^m} "
        ]
      },
      " выходами, реализующую все ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{2^m} "
        ]
      },
      "\nбулевых функций ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "m"
        ]
      },
      " аргументов. (Указание: эту схему также можно построить индуктивно.)\n\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "в"
        ]
      },
      ") Пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(x_1,\\dots,x_k,y_1,\\dots,y_l)"
        ]
      },
      "—\nбулева функция, аргументы которой разбиты на две группы.\nПокажите, что её можно записать в виде дизъюнкции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^k"
        ]
      },
      " членов, каждый из которых имеет вид ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C(x_1,\\dots,x_k)\\land D(y_1,\\dots,y_l)"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      "— конъюнкт, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "D"
        ]
      },
      "— произвольная булева функция.\nВывести отсюда упомянутую выше оценку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^n/n)"
        ]
      },
      ". (Указание: разумно положить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k={n-\\log n+c} "
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "l={\\log n-c} "
        ]
      },
      ".\nСм. также ",
      {
        "name": "label",
        "props": {
          "ref": "gindikin"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "gindikin_link"
            },
            "children": []
          }
        ]
      },
      " и ",
      {
        "name": "label",
        "props": {
          "ref": "cyber"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "cyber_link"
            },
            "children": []
          }
        ]
      },
      ".)\n"
    ]
  },
  "\n\n\nТеорема ",
  {
    "name": "label",
    "props": {
      "ref": "generic-size"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "generic-size_link"
        },
        "children": []
      }
    ]
  },
  ", однако, ничего не говорит о сложности конкретных булевых функций.\nСитуация здесь такова.\nЕсть разнообразные методы и приёмы получения верхних оценок.\nНо про нижние оценки неизвестно практически ничего.\nПро многие функции мы подозреваем, что их сложность велика (экспоненциально зависит от числа входов), но доказать это пока не удаётся.\nВесьма нетривиальные идеи позволяют доказывать экспоненциальные нижние оценки для некоторых специальных классов схем, например, схем из монотонных элементов или схем ограниченной глубины (использующих элементы И и ИЛИ с произвольным числом входов).\nПолучение экспоненциальных оценок для более общих схем— один из возможных подходов к знаменитой ",
  {
    "name": "em",
    "props": {},
    "children": [
      "проблеме перебора"
    ]
  },
  ", ",
  "",
  "\nцентральной проблеме теории сложности вычислений.\n\n\nМы не будем углубляться в эту теорию, а приведём лишь несколько верхних оценок для конкретных задач.\nПри этом мы не претендуем на полноту, а хотим лишь показать несколько интересных идей и приёмов.\n\n\nРассмотрим функцию сравнения ",
  "",
  "\n",
  "",
  "\nдвух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-битовых чисел.\nОна имеет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  " аргументов (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " для одного числа и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " для другого); её значение равно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ", если первое число больше второго, и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " в противном случае.\n\n\nОбозначим эту функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{Comp}_n"
    ]
  },
  ".\n",
  "",
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "recursive-comparing",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "recursive-comparing_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "recursive-comparing_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      "— полный набор функций.\nСуществует такая константа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ", что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{size}_B(\\text{Comp}_n)\\le Cn"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nЗаметим, что поскольку в формулировке теоремы оценка размера проводится с точностью до константы, то выбор конкретного базиса не имеет значения.\nДругими словами, мы можем предполагать, что любое конечное число необходимых нам функций в этом базисе есть.\n\n\nСхема сравнения чисел будет рекурсивной (чтобы сравнить два числа, мы отдельно сравниваем их левые и правые половины, а затем объединяем результаты).\nПри этом, как часто бывает, надо усилить утверждение, чтобы индукция прошла.\nА именно, мы будем строить схему с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2n"
        ]
      },
      " входами ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n,y_1,\\dots,y_n"
        ]
      },
      " и двумя выходами, которая указывает, какой из трёх случаев ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x<y"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x=y"
        ]
      },
      " или ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x>y"
        ]
      },
      " имеет место. (Здесь ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x,y"
        ]
      },
      "— числа, записываемое в двоичной системе как ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1\\dots x_n"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_1,\\dots,y_n"
        ]
      },
      ".) Два выходных бита кодируют четыре возможности, а нужно только три, так что есть некоторый запас.\nДля определённости можно считать, что первый выходной бит истинен, если числа равны, а второй— если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x<y"
        ]
      },
      ".\nТогда возможны три варианта сигналов на выходе: ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "10"
        ]
      },
      " (равенство), ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "01"
        ]
      },
      "\n(при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x<y"
        ]
      },
      ") и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "00"
        ]
      },
      " (при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x>y)"
        ]
      },
      ".\n\n\nОбъясним теперь, как собрать, скажем, схему сравнения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "16"
        ]
      },
      "-разрядных чисел.\nСоберём отдельно схему сравнения старших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      " разрядов и младших ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      " разрядов.\nКаждая из них даст ответ в форме двух битов.\nТеперь из этих четырёх битов надо собрать два. (Если в старших разрядах неравенство, то оно определяет результат сравнения; если старшие разряды равны, то результат сравнения определяется младшими разрядами.) Написанная в скобках фраза определяет булеву функцию с четырьмя битами на входе и двумя битами на выходе, и может быть реализована некоторой схемой фиксированного размера.\nТаким образом, если через ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(n)"
        ]
      },
      " обозначить размер схемы, сравнивающей ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовые числа, то получаем оценку\n",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2n)\\le 2T(n)+c"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      "— некоторая константа, зависящая от выбора базиса.\nОтсюда следует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2^k)\\le c'2^k"
        ]
      },
      " при некотором ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c'"
        ]
      },
      ".\nВ самом деле, для достаточно большого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c'"
        ]
      },
      " можно доказать по индукции, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2^k) \\le c'2^k - c"
        ]
      },
      "\n(мы должны усилить неравенство, вычтя из правой части ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      ", чтобы индуктивный шаг прошёл; база индукции остается верной, если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c'"
        ]
      },
      " достаточно велико).\n\n\nТу же самую оценку можно объяснить и наглядно.\nНаша схема имеет вид иерархического дерева.\nНа каждом уровне из двух двухбитовых сигналов получается один.\nОстаётся вспомнить, что в полном двоичном дереве число внутренних вершин (которое определяет размер схемы)\nна единицу меньше числа листьев. (В турнире по олимпийской системе число игр на единицу меньше числа команд, так как после каждой игры одна команда выбывает.)\n\n\nВсе внутренние вершины и все листья (где сравниваются два бита) представляют собой схемы ограниченного размера, откуда и вытекает оценка ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T(2^k)\\le c'2^k"
        ]
      },
      ".\n\n\nОсталось лишь сказать, что делать, если размер чисел (который мы обозначали через ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ") не есть точная степень двойки.\nВ этом случае можно увеличить размер до ближайшей сверху степени двойки (не более чем в два раза) и подать на старшие разряды входов нули.\nОба действия приводят к увеличению размера схемы не более чем в константу раз.\n",
      " ᐅ"
    ]
  },
  "\n\n\nПерейдём к сложению двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных чисел.\n",
  "",
  "\n(Строго говоря, тут возникает не булева функция, а функция ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Bbb{B}^n\\times\\Bbb{B}^n\\to\\Bbb{B}^{n+1} "
    ]
  },
  ", но все наши определения очевидно переносятся на этот случай.)\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "sequential-addition",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "sequential-addition_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "sequential-addition_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ", осуществляющая сложение двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНапомним смысл обозначения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ": нам надо построить схему сложения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел, имеющую размер не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Cn"
        ]
      },
      " для некоторого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " и для всех ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ".\n\n\nВспомним, как складывают числа в столбик:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{rrrrr}\n    &        0 &        1 &        1 & \\\\\n    &        1 &        0 &        0 &1\\\\\n    &        1 &        0 &        1 &1\\\\\n\\hline 1   &        0 &        1 &        0 &0\\\\\n\\end{array}\n"
        ]
      },
      "\nВерхняя строка— биты переноса, нижняя— результат.\nЗаметим, что каждый из битов переноса или результата определяется тремя другими битами (бит результата равен сумме двух  битов слагаемых и бита переноса по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ", а бит переноса равен ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", если хотя бы два из этих трёх битов равны ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ").\nПоэтому можно составить схему, которая вычисляет эти биты справа налево и имеет размер ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\nЗаметим, что теорему ",
  {
    "name": "label",
    "props": {
      "ref": "recursive-comparing"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "recursive-comparing_link"
        },
        "children": []
      }
    ]
  },
  " легко вывести из теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "sequential-addition"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "sequential-addition_link"
        },
        "children": []
      }
    ]
  },
  ": чтобы сравнить числа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y"
    ]
  },
  ", сложим число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(2^n-1)-x"
    ]
  },
  " (то есть число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  ", в котором все единицы заменены нулями и наоборот) и число ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y"
    ]
  },
  ".\nЕсли в старшем разряде появится единица, то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y>x"
    ]
  },
  ", а если нет, то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "y\\le x"
    ]
  },
  ".\nОстаётся заметить, что и сложение, и обращение битов в числе ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "x"
    ]
  },
  "\nтребуют схем линейного размера.\nТаким образом, сравнение чисел сводится к вычислению бита переноса.\nВерно и обратное:\nвычисление бита переноса сводится к сравнению двух чисел (обратим в одном из слагаемых все биты).\n\n\nТем не менее конструкция, использованная при доказательстве теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "recursive-comparing"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "recursive-comparing_link"
        },
        "children": []
      }
    ]
  },
  ", имеет некоторые преимущества.\nНазовём ",
  {
    "name": "em",
    "props": {},
    "children": [
      "глубиной"
    ]
  },
  "\n  ",
  "",
  "\n  ",
  "",
  "\nсхемы максимальное число элементов на пути от входа к выходу.\nЕсли представить себе, что сигнал на выходе элемента появляется не сразу после подачи сигналов на входы, а с некоторой задержкой, то глубина схемы определяет суммарную задержку.\nЛегко понять, что рекурсивная схема сравнения имела глубину ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  " (число уровней пропорционально логарифму размера входа), в то время как построенная только что схема сложения имеет глубину,   ",
  "",
  "\nпропорциональную ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " (биты переноса вычисляются последовательно, справа налево).\nНо можно соединить эти два результата:\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "carry-save-adder",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "carry-save-adder_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "carry-save-adder_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема сложения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nКак мы видели, проблема в том, что биты переноса вычисляются последовательно, а не параллельно.\nЕсли удастся их все вычислить схемой размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", дальнейшее очевидно.\n\nВычисление битов переноса равносильно сравнению, так что для доказательства теоремы достаточно научиться сравнивать параллельно все « суффиксы» двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1\\dots x_n"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_1\\dots y_n"
        ]
      },
      ", —е для каждого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "i"
        ]
      },
      " сравнить числа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_ix_{i+1}\\dots x_n"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_iy_{i+1}\\dots y_n"
        ]
      },
      ".\n\nВспомним, что мы делали при сравнении чисел (скажем, длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      ").\nНа нижнем уровне мы сравнивали биты:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{cccccccc}\nx_1 & x_2 & x_3 & x_4 & x_5 & x_6 & x_7 & x_8 \\\\\ny_1 & y_2 & y_3 & y_4 & y_5 & y_6 & y_7 & y_8\n\\end{array}\n"
        ]
      },
      "\nНа следующем уровне мы сравнивали двузначные числа\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{cccc}\nx_1 x_2 & x_3 x_4 & x_5 x_6 & x_7 x_8 \\\\\ny_1 y_2 & y_3 y_4 & y_5 y_6 & y_7 y_8\n\\end{array}\n"
        ]
      },
      "\nзатем четырёхзначные\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{cc}\nx_1  x_2   x_3  x_4 & x_5   x_6   x_7   x_8 \\\\\n{y_1} {y_2} {y_3} {y_4} &\n{y_5} {y_6} {y_7} {y_8}\n\\end{array}\n"
        ]
      },
      "\nи, наконец, восьмизначные:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{array}{c}\nx_1  x_2   x_3  x_4  x_5   x_6   x_7   x_8 \\\\\n{y_1} {y_2} {y_3} {y_4}\n{y_5} {y_6} {y_7} {y_8}\n\\end{array}\n"
        ]
      },
      "\nТаким образом, для суффиксов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "8"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "4"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      "\nрезультаты сравнения уже есть.\nДля суффикса длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "6"
        ]
      },
      " результат можно получить, комбинируя результат сравнения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_3x_4 ? y_3y_4"
        ]
      },
      "\nи ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_5x_6x_7x_8 ? y_5y_6y_7y_8"
        ]
      },
      ".\nПосле этого у нас есть информация о суффиксах всех чётных длин, и соединяя её с информацией с первого этапа, получаем сведения про все суффиксы.\nНапример, для сравнения суффиксов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "7"
        ]
      },
      ", то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_2\\dots x_8"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_2\\dots y_8"
        ]
      },
      ", мы соединяем результаты сравнения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_2"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_2"
        ]
      },
      " с результатами сравнения суффиксов длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "6"
        ]
      },
      ", то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_3\\dots x_8"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y_3\\dots y_8"
        ]
      },
      ".\n\nВ общем случае картина такая: после «сужающегося дерева» мы строим «расширяющееся»; за ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      " шагов до конца мы знаем результаты сравнения всех суффиксов, длины которых кратны ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^k"
        ]
      },
      ".\nЭто дерево имеет размер ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубину ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", что завершает доказательство.\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПокажите, что вычитание двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовых чисел по модулю ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      "\nвыполняется схемой размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n(Указание: вычитание легко сводится к сложению, если заменить нули на единицы и наоборот.)\n"
    ]
  },
  "\n\nТеперь займёмся умножением.\nСхема умножения двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных   ",
  "",
  "\nчисел имеет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  " входов (по ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " для каждого множителя) и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  "\nвыходов для произведения.\n\n\nПосмотрим, какие оценки даёт обычный способ умножения чисел столбиком.\nВ нём умножение двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных чисел сводится к сложению ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " копий первого числа (частично заменённых на нули в зависимости от цифр второго числа) со сдвигами.\n\n\nПолучение этих копий требует схемы размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n^2)"
    ]
  },
  " (общее число цифр в копиях) и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(1)"
    ]
  },
  ".\nСложение двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2n"
    ]
  },
  "-разрядных чисел мы можем выполнить с помощью схемы размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n)"
    ]
  },
  " и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  ", так что необходимые ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n-1"
    ]
  },
  " сложений можно выполнить схемой размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n^2)"
    ]
  },
  " и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log^2 n)"
    ]
  },
  " (если складывать сначала попарно, потом результаты снова попарно и т.д.).\nОказывается, этот результат можно улучшить.\nНаиболее экономные способы основаны на преобразовании Фурье (о них можно прочесть в книге ",
  {
    "name": "label",
    "props": {
      "ref": "aho-hopcroft-ullman"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "aho-hopcroft-ullman_link"
        },
        "children": []
      }
    ]
  },
  ").\nС их помощью, например, можно построить схему умножения ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-битовых чисел, имеющую размер ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n\\log^c n"
    ]
  },
  ".\n\n\nЭти методы далеко выходят за рамки нашего обсуждения, но два улучшения мы приведём.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "fast-multiplication",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "fast-multiplication_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "fast-multiplication_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема умножения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nКак мы уже говорили, умножение двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел сводится к сложению ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " таких чисел, и остаётся выполнить такое сложение схемой размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\nКлючевым моментом здесь является сведение сложения трёх чисел к сложению двух с помощью простой схемы размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      ".\nВ самом деле, пусть есть три числа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "y"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "z"
        ]
      },
      ".\nЕсли мы будем складывать отдельно в каждом разряде, то в разряде может накопиться любая сумма от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      ", то есть в двоичной записи от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "00"
        ]
      },
      " до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "11"
        ]
      },
      ".\nСформируем из младших битов этих двухбитовых сумм число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u"
        ]
      },
      ", а из старших (сдвинутых влево)— число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "v"
        ]
      },
      ".\nТогда, очевидно, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x+y+z=u+v"
        ]
      },
      ".\nПолучение цифр числа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "v"
        ]
      },
      " происходит параллельно во всех разрядах и требует размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      ".\n\nТеперь, если надо сложить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " чисел, можно разбить их на тройки и из каждых трёх чисел получить по два.\nВ следующий круг, таким образом, выйдут ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(2/3)n"
        ]
      },
      " чисел (примерно— граничные эффекты большой роли не играют).\nИх снова можно сгруппировать по тройкам и т.д. С каждым уровнем число слагаемых убывает в полтора раза, так что глубина схемы будет логарифмической.\nКаждое преобразование трёх слагаемых в два требует схемы размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      "\nи уменьшает число слагаемых на единицу, так что потребуется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "\nтаких преобразований.\nИтак, эта конструкция имеет общий размер ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " и глубину ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\nНадо только отметить, что в конце у нас получается не одно число, а два, и их напоследок надо сложить— что мы умеем делать с глубиной ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " и размером ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДокажите, что схема, вычисляющая булеву функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      " от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "\nаргументов, у которой ни один аргумент не является фиктивным, имеет размер не менее ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "cn"
        ]
      },
      " и глубину не менее ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c\\log n"
        ]
      },
      ", где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c>0"
        ]
      },
      "— некоторая константа, зависящая от выбранного набора элементов. (Аргумент функции называют ",
      {
        "name": "em",
        "props": {},
        "children": [
          "фиктивным"
        ]
      },
      ", ",
      "",
      "\n",
      "",
      "\nесли от него значение функции не зависит.)\n"
    ]
  },
  "\n\n\nЭта задача показывает, что если по ходу умножения двух ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-разрядных чисел мы суммируем ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " слагаемых размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  ", то оценки ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n^2)"
    ]
  },
  " для размера и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  " для глубины, полученные при доказательстве теоремы ",
  {
    "name": "label",
    "props": {
      "ref": "fast-multiplication"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "fast-multiplication_link"
        },
        "children": []
      }
    ]
  },
  ", существенно улучшить нельзя.\n\n\nОднако никто не обязывает нас следовать традиционному способу умножения столбиком— отказавшись от него, мы можем уменьшить размер схемы.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "recursive-multiplication",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "recursive-multiplication_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "recursive-multiplication_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема умножения двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^{\\log_2 3})"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log^2 n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНачнём с такого замечания.\nВычисляя произведение двух комплексных чисел\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(a+bi)(c+di)=(ac-bd)+(ad+bc)i\n"
        ]
      },
      "\nобычным способом, мы делаем четыре умножения.\nНо можно обойтись и тремя с помощью трюка: вычислить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "ac"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "bd"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)(c+d)"
        ]
      },
      ", а потом найти ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "ad+bc"
        ]
      },
      " как разность ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)(c+d)-ac-bd"
        ]
      },
      ".\n\nАналогичный фокус можно проделать и для целых чисел.\nРазобьём ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2n"
        ]
      },
      "-битовое число на две ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-битовые части, то есть представим его в виде ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "a2^n+b"
        ]
      },
      ".\nТеперь запишем произведение двух таких чисел:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(a2^n+b)(c2^n+d)=ac2^{2n}+(ad+bc)2^n+bd.\n"
        ]
      },
      "\nТеперь видно, что достаточно найти три произведения, а именно, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "ac"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "bd"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)(c+d)"
        ]
      },
      ", чтобы определить все три слагаемых в правой части равенства.\nПолучается, что умножение двух ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2n"
        ]
      },
      "-разрядных чисел сводится к трём умножениям ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных и к нескольким сложениям и вычитаниям. (На самом деле при умножении ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a+b)"
        ]
      },
      " на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(c+d)"
        ]
      },
      "\nсомножители могут быть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(n+1)"
        ]
      },
      "-разрядными, но это не страшно, так как обработка лишнего разряда сводится к нескольким сложениям.)\n\nДля размера схемы это даёт рекурсивную оценку\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\nS(2n)\\le 3S(n)+O(n)\n"
        ]
      },
      "\n, из которой следует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S(n)=O(n^{\\log_2 3})"
        ]
      },
      ".\nВ самом деле, для умножения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "-разрядных чисел требуется дерево рекурсивных вызовов глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log_2 n"
        ]
      },
      " и степени ветвления ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      ".\nЗаметим, что размер схемы в вершине пропорционален числу складываемых битов.\nПри переходе от одного уровня к следующему (более близкому к корню) размер слагаемых растёт вдвое, а число вершин уменьшается втрое, поэтому общее число элементов на этом уровне уменьшается в полтора раза.\nТаким образом, при движении по уровням от листьев к корню получается убывающая геометрическая прогрессия со знаменателем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2/3"
        ]
      },
      ", сумма которой всего лишь втрое превосходит её первый член.\nОстаётся заметить, что число листьев равно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3^{\\log_2 n}=n^{\\log_2 3} "
        ]
      },
      ".\n\nОценка глубины также очевидна: на каждом уровне мы имеем схему сложения глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", а число уровней есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\nНа этом мы завершаем знакомство со схемами из функциональных элементов, выполняющими арифметические операции.\nО них можно прочесть в главе 29 учебника Кормена, ",
  "",
  "\nЛейзерсона ",
  "",
  "\nи Ривеста ",
  {
    "name": "label",
    "props": {
      "ref": "cormen-leiserson-rivest"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "cormen-leiserson-rivest_link"
        },
        "children": []
      }
    ]
  },
  "\n",
  "",
  "\nи в книге Ахо, ",
  "",
  "\nХопкрофта ",
  "",
  "\nи Ульмана ",
  {
    "name": "label",
    "props": {
      "ref": "aho-hopcroft-ullman"
    },
    "children": [
      {
        "name": "use",
        "props": {
          "ref": "aho-hopcroft-ullman_link"
        },
        "children": []
      }
    ]
  },
  ".\n",
  "",
  "\n\n\nРассмотрим теперь функцию «голосования» ",
  "",
  "\n",
  "",
  " (majority).\n",
  "",
  "\nОна имеет нечётное число аргументов, и значение её равно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  " в зависимости от того, какое из двух значений чаще встречается среди входов.\n\n\n",
  {
    "name": "area",
    "props": {
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nДля функции голосования существует схема размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n\\log\\log n)"
        ]
      },
      ".\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНа самом деле можно даже вычислить общее число единиц среди входов.\nЭто делается рекурсивно: считаем отдельно для каждой половины, потом складываем.\nПолучается логарифмическое число уровней.\nНа верхнем уровне надо складывать числа размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log n"
        ]
      },
      ", на следующем— размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{(\\log n -1)} "
        ]
      },
      " и так до самого низа, где складываются однобитовые числа (то есть биты входа).\nКакой средний размер складываемых чисел? Половина вершин в дереве приходится на нижний уровень (числа длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      "), четверть— на следующий (числа длины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ") и т.д. Вспоминая, что ряд ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\sum (k/2^k)"
        ]
      },
      " сходится, видим, что средний размер складываемых чисел есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      " и общий размер схемы есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      ".\nА общая глубина есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n \\log\\log n)"
        ]
      },
      ", так как на каждом из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log n"
        ]
      },
      "\nуровней стоит схема глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log\\log n)"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\nЗаметим, что хотя функция голосования монотонна, построенная схема её вычисления содержит немонотонные элементы (поскольку операция сложения не монотонна).\nМы уже говорили, что всякую монотонную функцию можно составить из конъюнкций и дизъюнкций.\nДля функции голосования есть очевидный способ это сделать: написать дизъюнкцию всех конъюнкций размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(n+1)/2"
    ]
  },
  " (напомним, что число входов ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " предполагается нечётным).\nОднако при этом получится схема экспоненциального по ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " размера.\n\n\n",
  {
    "name": "area",
    "props": {
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nСуществует схема размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^c)"
        ]
      },
      " и глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      ", составленная только из элементов И и ИЛИ (с двумя входами), вычисляющая функцию голосования.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nДля начала заметим, что ограничение на размер является следствием ограничения на глубину, так как элементы И и ИЛИ имеют только два входа и число элементов в схеме глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "d"
        ]
      },
      " есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(2^d)"
        ]
      },
      ".\n\nСхема будет строиться из элементов большинства с тремя входами.\n(Каждый из них можно собрать из конъюнкций и дизъюнкций по формуле ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(a\\land b)\\lor (a\\land c)\\lor (b\\land c)"
        ]
      },
      ".)\nВыход схемы будет большинством из трёх значений, каждое из которых есть большинство из трёх значений и т.д. (рис. ",
      {
        "name": "label",
        "props": {
          "ref": "majority-scheme"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "majority-scheme_link"
            },
            "children": []
          }
        ]
      },
      ").\n\n",
      {
        "name": "image",
        "props": {
          "src": "/img3.png",
          "key": "majority-scheme",
          "height": 0.5
        },
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true
            },
            "children": [
              "Рис. ",
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "majority-scheme_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "image",
                      "key": "majority-scheme_counter"
                    },
                    "children": []
                  }
                ]
              },
              ". ",
              "Дерево из элементов ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "3"
                ]
              },
              "-большинства.\n"
            ]
          }
        ]
      },
      "\n\nПродолжая эту конструкцию на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      " уровнях, мы получим схему с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3^k"
        ]
      },
      " входами. (Отметим, что эта схема не будет вычислять большинство среди своих входов— по той же причине, по которой результат непрямого голосования может отличаться от мнения большинства.) Но мы сделаем вот какую странную вещь: возьмём ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      "\nравным ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c\\log n"
        ]
      },
      " при достаточно большом коэффициенте пропорциональности ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      " (число входов такой схемы будет полиномиально зависеть от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      ") и напишем на входах случайно выбранные переменные из данного нам набора ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n"
        ]
      },
      ".\n(Переменные, записываемые на разных входах, выбираются независимо.) Оказывается, что с ненулевой вероятностью эта схема будет вычислять функцию большинства среди ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_1,\\dots,x_n"
        ]
      },
      ", если константа ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c"
        ]
      },
      "\nдостаточно велика.\nСледовательно, искомая схема существует.\n\n\nОбратите внимание: нам удастся доказать существование интересующей нас схемы, не предъявив её явно. (Такое использование вероятностных методов в комбинаторных рассуждениях часто бывает полезно.)\n\n\nИтак, почему же схема с положительной вероятностью вычисляет функцию большинства? Это доказывается так: рассмотрим какой-то один набор значений на входах и докажем, что на этом конкретном наборе случайная схема выдаёт правильный ответ с вероятностью, очень близкой к единице (равной ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-\\varepsilon"
        ]
      },
      " при очень малом ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon"
        ]
      },
      ").\n\n\nЕсли число ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon"
        ]
      },
      " настолько мало, что остаётся меньшим единицы даже после умножения на число возможных входов (",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      "), то получаем требуемое (каждое из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " событий имеет вероятность не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-\\varepsilon"
        ]
      },
      ", значит их пересечение имеет вероятность не меньше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-2^n\\varepsilon>0"
        ]
      },
      ").\n\n\nИтак, осталось оценить вероятность того, что случайная схема даст правильный ответ на данном входе.\nПусть доля единиц среди всех входов равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ".\nТогда на каждый входной провод схемы подаётся единица с вероятностью ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " и нуль с вероятностью ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1-p"
        ]
      },
      "\n(выбор случайной переменной даёт единицу с вероятностью ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      "), причём сигналы на всех входах независимы.\n\n\nЕсли на трёх входах элемента ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-большинства сигналы независимы, и вероятность появления единицы на каждом входе есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ", то вероятность появления единицы на выходе есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(p)=3p^2(1-p)+p^3=3p^2-2p^3"
        ]
      },
      ".\nНа следующих уровнях вероятность появления единицы будет равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(\\varphi(p)),\\varphi(\\varphi(\\varphi(p))),\\dots"
        ]
      },
      " График функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi(x)"
        ]
      },
      " на отрезке ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "[0,1]"
        ]
      },
      "\n(рис. ",
      {
        "name": "label",
        "props": {
          "ref": "iterations-majority"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "iterations-majority_link"
            },
            "children": []
          }
        ]
      },
      ") показывает, что при итерациях функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " дисбаланс (отклонение от середины) нарастает и последовательность стремится к краю отрезка.\nНадо только оценить число шагов.\n\n",
      {
        "name": "image",
        "props": {
          "src": "/img4.png",
          "key": "iterations-majority",
          "height": 0.5
        },
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true
            },
            "children": [
              "Рис. ",
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "iterations-majority_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "image",
                      "key": "iterations-majority_counter"
                    },
                    "children": []
                  }
                ]
              },
              ". ",
              "Итерируемая функция ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "\\varphi"
                ]
              },
              ".\n"
            ]
          }
        ]
      },
      "\n\nЕсли вначале единицы составляют большинство из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " аргументов (напомним, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " нечётно), то их как минимум ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(n+1)/2"
        ]
      },
      ", так что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\ge (n+1)/2n=1/2+1/(2n)"
        ]
      },
      ".\nТаким образом, начальный дисбаланс составляет как минимум ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2n"
        ]
      },
      ".\nА в конце нам нужно приблизиться к краю отрезка на расстояние ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{-n} "
        ]
      },
      ".\n\n\nИтак, нам осталось доказать такую лемму (относящуюся скорее к математическому анализу):\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма"
        ]
      },
      ".\nПусть последовательность ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_k\\in[0,1]"
        ]
      },
      " задана рекуррентной формулой ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_{k+1}=\\varphi(x_k)"
        ]
      },
      ", где\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\varphi(x)=3x^2-2x^3.\n"
        ]
      },
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_0\\ge1/2+1/(2n)"
        ]
      },
      ".\nТогда последовательность ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_k"
        ]
      },
      " монотонно возрастает и приближается к ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      " на расстояние ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{-n} "
        ]
      },
      " за ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " шагов. [Симметричное утверждение верно и при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x_0\\le 1/2-1/(2n)"
        ]
      },
      ".]\n\nИдея доказательства: посмотрим на функцию вблизи точки ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2"
        ]
      },
      " и у краёв отрезка.\nВ точке ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2"
        ]
      },
      " производная больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ", поэтому удаление от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2"
        ]
      },
      " растёт как геометрическая прогрессия, и точка перейдёт какую-то фиксированную границу (например, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0{,}51"
        ]
      },
      ") не позднее чем за ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " шагов.\nЗатем потребуется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      " шагов, чтобы дойти, скажем, до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0{,}99"
        ]
      },
      ".\nВ единице первая производная функции равна нулю, поэтому расстояние до единицы каждый раз примерно возводится в квадрат, и потому для достижения погрешности ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{-n} "
        ]
      },
      " потребуется ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)"
        ]
      },
      " шагов (как в методе Ньютона отыскания корня).\nВсего получается ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(\\log n)+O(1)+O(\\log n)"
        ]
      },
      " шагов, что и требовалось.\n",
      " ᐅ"
    ]
  },
  "\n\n\nНа самом деле справедливо гораздо более сильное утверждение:\nсуществует схема размера ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n\\log n)"
    ]
  },
  " и глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log n)"
    ]
  },
  ", состоящая только из элементов И и ИЛИ, которая имеет ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " входов и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " выходов и осуществляет сортировку последовательности ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  " нулей и единиц (это означает, что на выходе столько же единиц, сколько на входе, причём выходная последовательность всегда невозрастающая).\nЯсно, что средний бит выхода в такой ситуации реализует функцию большинства.\n\n\nПри кажущейся простоте формулировки единственная известная конструкция такой схемы (сортирующая сеть AKS, придуманная Айтаи, ",
  "",
  "\nКомлошом ",
  "",
  "\nи Сцемереди ",
  "",
  "\nв 1983 году)\nвесьма сложна, и появление какой-то более простой конструкции (с логарифмической глубиной!) было бы замечательным достижением.\nНо разрешив большую глубину, мы сильно упрощаем задачу: для глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(\\log^2 n)"
    ]
  },
  " уже есть несколько сравнительно простых конструкций, а для глубины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n)"
    ]
  },
  " годится совсем простая сеть.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПостройте сортирующую сеть глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n)"
        ]
      },
      " с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(n^2)"
        ]
      },
      " элементов И и ИЛИ.  (Указание.\nДва элемента И и ИЛИ вместе образуют сортирующую сеть для двух входов.\nВспомнив сортировку пузырьком, придумайте, как из таких сетей собрать искомую, на каждом шаге группируя переменные в пары.\nОбратите внимание, что доказательство оценки на глубину не вполне тривиально.)\n"
    ]
  },
  "\n\n\nМногие нетривиальные результаты теории алгоритмов можно переформулировать в терминах сложности каких-то булевых функций.\nНапример, есть вероятностный алгоритм проверки простоты ",
  "",
  "\nбольшого числа (применяемый в системах шифрования для проверки простоты чисел из нескольких тысяч цифр).\nИспользуя этот алгоритм, можно доказать такой факт: существует схема проверки простоты ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-битового числа (на вход подаются ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "\nцифр, на выходе появляется единица, если число простое, и нуль, если число составное), размер которой ограничен полиномом от ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  ".\n\n\nВернёмся к общим утверждениям о схемах и формулах.\nМы уже говорили, что с точки зрения измерения размера схемы и формулы—\nэто разные вещи (схемы экономичнее, так как в них одинаковые подформулы учитываются только один раз).\nОказывается, что размер формулы можно связать с глубиной схемы.\n",
  "",
  "\n",
  "",
  "\n\n\nБудем называть ",
  {
    "name": "em",
    "props": {},
    "children": [
      "размером"
    ]
  },
  "\n",
  "",
  "\nформулы число логических связок в ней.\nМы предполагаем, что формула использует конъюнкции, дизъюнкции и отрицания, и в схемах будем использовать такие же элементы.\nНапомним, что размером схемы ",
  "",
  "\n",
  "",
  "\nмы называли число элементов, а сложностью ",
  "",
  "\n",
  "",
  "\nбулевой функции— минимальный размер схемы, её вычисляющей.\nСложность функции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "h"
    ]
  },
  " обозначалась ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}(h)"
    ]
  },
  " (точнее ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}_B(h)"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "— набор разрешённых функциональных элементов, но сейчас мы договорились использовать конъюнкции, дизъюнкции и отрицания и опускаем индекс ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ").\n\n\nМинимальный размер формулы, выражающей функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "h"
    ]
  },
  ", будем обозначать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{fsize}(h)"
    ]
  },
  ".\nОчевидно, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{size}(h)\\le\\text{fsize}(h)"
    ]
  },
  ".\nБолее интересно, однако, следующее утверждение, связывающее размер схемы с глубиной формулы.\nОбозначим через ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{depth}(h)"
    ]
  },
  "\nминимальную глубину схемы, вычисляющей функцию ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "h"
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "formula-size-depth",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "formula-size-depth_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "formula-size-depth_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nИмеют место оценки ",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\text{fsize}(h)\\le c_1^{\\text{depth}(h)} \\quad\\text{и}\\quad \\text{depth}(h)\\le c_2\\log\\text{fsize}(h)\n"
        ]
      },
      " (для некоторых констант ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "c_2"
        ]
      },
      " и для всех ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      ").\nДругими словами, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{depth} "
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log\\text{fsize} "
        ]
      },
      " отличаются не более чем в константу раз.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nПервая оценка очевидна: если мы скопируем повторяющиеся фрагменты схемы, чтобы развернуть её в дерево, то глубина не изменится.\nЕсли она равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      ", то в полученном дереве будет не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^k-1"
        ]
      },
      " элементов и соответствующая формула имеет размер не более ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{2^k-1} "
        ]
      },
      ". (Напомним, что элементами являются конъюнкции, дизъюнкции и отрицания, и потому ветвление не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2"
        ]
      },
      ".)\n\n\nТо же самое можно сказать индуктивно.\nПусть глубина схемы равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      ".\nВыход схемы является выходом некоторого элемента.\nТогда на его входы подаются булевы функции глубины не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k-1"
        ]
      },
      ".\nПо предположению индукции их можно записать формулами размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{k-1}-1"
        ]
      },
      ".\nТаких формул максимум две, так что общий размер не превосходит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2(2^{k-1}-1)+1=2^k-1"
        ]
      },
      ".\n\n\nВторая оценка сложнее.\nЕсли мы будем преобразовывать формулу в схему естественным образом (введя вспомогательную переменную для каждой подформулы), то глубина получившейся схемы может быть близка к размеру формулы, а не к его логарифму.\nНапример, если формула имеет вид ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\ldots((p_1\\land p_2)\\land p_3)\\land\\dots p_n)"
        ]
      },
      ", то у нас получится цепочка элементов И, у которых каждый следующий подвешен к левому входу предыдущего, и глубина равна ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{n-1} "
        ]
      },
      ".\nКонечно, если использовать ассоциативность конъюнкции, скобки можно переставить и получить более сбалансированное дерево глубины примерно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\log n"
        ]
      },
      ", как и требуется.\nНо как выполнить такое преобразование в случае произвольной формулы?\n\n\nОбозначим данную нам формулу через ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\nВыберем у неё некоторую подформулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " (как именно, мы объясним позже).\nРассмотрим формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0"
        ]
      },
      ", которая получится, если вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " подставить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      "\n(ложь), а также формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_1"
        ]
      },
      ", которая получится, если подставить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\nЛегко понять, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " равносильна формуле ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "((F_0 \\land\\lnot G)\\lor (F_1\\land G))"
        ]
      },
      ".\nЕсли теперь удастся заменить формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0, F_1, G"
        ]
      },
      " схемами глубины не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k"
        ]
      },
      ", то для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " получится схема глубины не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "k+3"
        ]
      },
      ".\n\n\nТакое преобразование полезно, если все три формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_1, F_0, G"
        ]
      },
      "\nимеют заметно меньший размер, чем исходная формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма"
        ]
      },
      ".\nУ любой формулы достаточно большого размера ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      "\nесть подформула размера от ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n/4"
        ]
      },
      " до ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3n/4"
        ]
      },
      ".\n\n\nДоказательство.\nКаждая формула есть конъюнкция двух подформул, дизъюнкция двух подформул или отрицание подформулы.\nНачав со всей формулы, будем переходить к её подформулам, на каждом шаге выбирая из двух подформул наибольшую.\nТогда на каждом шаге размер убывает не более чем в два раза, и потому мы не можем миновать промежуток ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "[n/4, 3n/4]"
        ]
      },
      ", концы которого отличаются втрое. (На самом деле тут есть небольшая неточность: размер формулы может убывать чуть быстрее, чем вдвое, так как размер формулы на единицу больше суммы размеров частей, но у нас есть запас, поскольку концы промежутка отличаются втрое, а не вдвое.) Лемма доказана.\n\n\nВыбирая подформулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " с помощью этой леммы, мы гарантируем, что размер всех трёх формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0,F_1,G"
        ]
      },
      " не превосходит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3/4"
        ]
      },
      "\nразмера исходной формулы (подстановка нуля или единицы может только уменьшить размер формулы— некоторые части можно будет выбросить).\n\n\nПрименим ко всем трём формулам ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_0"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F_1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "G"
        ]
      },
      " тот же приём, выделим в них подформулы среднего размера и так далее, пока мы не спустимся до формул малого размера, которые можно записать в виде схем как угодно.\nВ итоге получится дерево с логарифмическим числом уровней, на каждом из которых стоят схемы глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      ", а в листьях находятся схемы глубины ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "O(1)"
        ]
      },
      ".\n\n\nДругими словами, индукцией по длине формулы, выражающей функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      ", мы доказываем, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{depth}(h)=O(\\log\\text{fsize}(h))"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nОпределим глубину формулы как максимальное число вложенных пар скобок; для единообразия будем окружать отрицание скобками и писать ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\lnot A)"
        ]
      },
      " вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ".\nПокажите, что при этом не получится ничего нового: минимальная глубина формулы, записывающей некоторую функцию ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      ", совпадает с минимальной глубиной схемы, вычисляющей ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "f"
        ]
      },
      ".\n"
    ]
  },
  "\n\n\nОпределение формульной сложности ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{fsize}(h)"
    ]
  },
  " зависит от выбора базиса.\nОказывается, что здесь (в отличие от схемной сложности) выбор базиса может изменить ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\text{fsize}(h)"
    ]
  },
  " более чем в константу раз.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nОбъясните, почему доказательство теоремы ",
      {
        "name": "label",
        "props": {
          "ref": "size-invariant"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "size-invariant_link"
            },
            "children": []
          }
        ]
      },
      "\nне переносится на случай формул.\n"
    ]
  },
  "\n\n\nТак происходит с функцией ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "{p_1\\oplus p_2\\oplus\\ldots\\oplus p_n} "
    ]
  },
  " (знак ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\oplus"
    ]
  },
  " обозначает сложение по\n",
  "",
  "\nмодулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ").\nЭта функция имеет формульную сложность ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "O(n)"
    ]
  },
  ", если сложение по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  " входит в базис.\nОднако в базисе И, ИЛИ, НЕ она имеет большую сложность, как доказала Б.А.Субботовская.\n",
  "",
  "\nИдея доказательства такова: если заменить случайно выбранную переменную в формуле с конъюнкциями и дизъюнкциями на случайно выбранное значение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "0"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "1"
    ]
  },
  ", то формула упростится (не только эта переменная пропадёт, но с некоторой вероятностью пропадут и другие).\nЕсли делать так многократно, то от формулы останется небольшая часть— с другой стороны, эта часть всё равно должна реализовывать сложение оставшихся аргументов по модулю ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2"
    ]
  },
  ".\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДокажите, что функция большинства может быть вычислена не только схемой, но и формулой полиномиального размера, содержащей только связки И и ИЛИ.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДокажите, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{fsize}_1(h)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{fsize}_2(h)"
        ]
      },
      " для одной булевой функции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      " и двух полных базисов полиномиально связаны: существует полином ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      " (зависящий от выбора базисов), для которого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\text{fsize}_2 (h) \\le P(\\text{fsize}_1(h))"
        ]
      },
      " при всех ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "h"
        ]
      },
      ".\n(Указание: использовать теорему ",
      {
        "name": "label",
        "props": {
          "ref": "formula-size-depth"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "formula-size-depth_link"
            },
            "children": []
          }
        ]
      },
      ".)\n"
    ]
  },
  "\n",
  "\n",
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "key": "propositional-calculus",
      "level": 2
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "end": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "end": "table"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "use": "chapter"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "section"
        },
        "children": []
      },
      {
        "name": "counter",
        "props": {
          "start": "table"
        },
        "children": []
      },
      ". ",
      "Исчисление высказываний"
    ]
  },
  "\n",
  "",
  "\nНапомним, что тавтологии ",
  "",
  "\n— это пропозициональные формулы, ",
  "",
  "\nистинные при всех значениях переменных.\nОказывается, что все тавтологии можно получить из некоторого набора «аксиом» с помощью «правил вывода», которые имеют чисто синтаксический характер и никак не апеллируют к смыслу формулы, её истинности и т.д.\nЭту задачу решает так называемое ",
  {
    "name": "em",
    "props": {},
    "children": [
      "исчисление высказываний"
    ]
  },
  ".\n",
  "",
  "\nВ этой главе мы перечислим аксиомы и правила вывода этого исчисления, и приведём несколько доказательств ",
  {
    "name": "em",
    "props": {},
    "children": [
      "теоремы о полноте"
    ]
  },
  "\n",
  "",
  "\n(которая утверждает, что всякая тавтология ",
  "",
  "\nвыводима в исчислении высказываний).\n\n\n",
  "\n",
  {
    "name": "header",
    "props": {
      "key": "propositional-calculus-axioms",
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Исчисление высказываний (ИВ)"
    ]
  },
  "\n\nКаковы бы ни были формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A,B,C"
    ]
  },
  ", следующие формулы называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "аксиомами исчисления высказываний"
    ]
  },
  ":\n",
  "",
  "\n",
  "",
  "\n",
  "",
  "\n\n",
  {
    "name": "counter",
    "props": {
      "init": "axioms"
    },
    "children": []
  },
  "\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to(B\\to A)"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(A\\to(B\\to C))\\to((A\\to B)\\to (A \\to C))"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(A\\land B)\\to A"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(A\\land B)\\to B"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to(B\\to(A\\land B))"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to (A\\lor B)"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B\\to(A\\lor B)"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(A\\to C) \\to ( (B\\to C) \\to ((A\\lor B)\\to C))"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\neg A\\to(A\\to B)"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(A\\to B)\\to ((A\\to \\lnot B)\\to\\lnot A)"
    ]
  },
  ";\n\n(",
  {
    "name": "counter",
    "props": {
      "use": "axioms"
    },
    "children": []
  },
  ") ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\lor \\neg A"
    ]
  },
  ".\n\n\nКак говорят, мы имеем здесь одиннадцать «схем аксиом»; из каждой схемы можно получить различные конкретные аксиомы, заменяя входящие в неё буквы на пропозициональные формулы.\n\n\nЕдинственным правилом вывода исчисления высказываний является правило со средневековым названием «modus ponens» (MP).\n",
  "",
  "\n",
  "",
  "\nЭто правило разрешает получить (вывести) из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(A\\to B)"
    ]
  },
  " формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ".\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Выводом"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nв исчислении высказываний называется конечная последовательность формул, каждая из которых есть аксиома или получается из предыдущих по правилу modus ponens.\n\nВот пример вывода (в нём первая формула является частным случаем схемы (1), вторая— схемы (2), а последняя получается из двух предыдущих по правилу modus ponens):\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{align*}\n   &(p\\to(q\\to p)),\\\\\n   &(p\\to(q\\to p))\\to((p\\to q)\\to(p\\to p)),\\\\\n   &((p\\to q)\\to(p\\to p)).\n\\end{align*}\n"
    ]
  },
  "\n\nПропозициональная формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " называется ",
  {
    "name": "em",
    "props": {},
    "children": [
      "выводимой"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\n",
  "",
  "\nв исчислении высказываний, или ",
  {
    "name": "em",
    "props": {},
    "children": [
      "теоремой"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nисчисления высказываний, если существует вывод, в котором последняя формула равна ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ".\nТакой вывод называют выводом формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ". (В принципе можно было бы и не требовать, чтобы формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " была последней — все дальнейшие формулы можно просто вычеркнуть.)\n\nКак мы уже говорили, в исчислении высказываний выводятся все тавтологии и только они.\nОбычно это утверждение разбивают на две части: простую и сложную.\nНачнём с простой:\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "о корректности ИВ",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "о корректности ИВ",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nВсякая теорема исчисления высказываний есть тавтология.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНесложно проверить, что все аксиомы— тавтологии.\nДля примера проделаем это для самой длинной аксиомы (точнее, схемы аксиом)—\nдля второй.\nВ каком случае формула\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(A\\to(B\\to C))\\to((A\\to B)\\to (A\\to C))\n"
        ]
      },
      "\n(где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A,B,C"
        ]
      },
      " — некоторые формулы) могла бы быть ложной?\nДля этого посылка ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to(B\\to C)"
        ]
      },
      " должна быть истинной, а заключение ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)\\to (A\\to C)"
        ]
      },
      " — ложным.\nЧтобы заключение было ложным, формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to B"
        ]
      },
      " должна быть истинной, а формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to C"
        ]
      },
      " — ложной.\nПоследнее означает, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " истинна, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " ложна.\nТаким образом, мы знаем, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to(B\\to C))"
        ]
      },
      " истинны.\nОтсюда следует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(B\\to C)"
        ]
      },
      " истинны, и потому ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " истинна — противоречие.\nЗначит, наша формула не бывает ложной.\n\n\nКорректность правила MP также ясна: если формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " всегда истинны, то по определению импликации формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " также всегда истинна.\nТаким образом, все формулы, входящие в выводы (все теоремы) являются тавтологиями.\n",
      " ᐅ"
    ]
  },
  "\n\n\nГораздо сложнее доказать обратное утверждение.\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "о полноте ИВ",
      "key": "propositional-completeness",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "propositional-completeness_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "propositional-completeness_link"
            },
            "children": []
          },
          " (",
          "о полноте ИВ",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nВсякая тавтология есть теорема исчисления высказываний.\n"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nМы предложим несколько альтернативных доказательств этой теоремы.\nНо прежде всего мы должны приобрести некоторый опыт построения выводов и использования аксиом.\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма 1"
        ]
      },
      ". Какова бы ни была формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "D"
        ]
      },
      ", формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{(D\\to D)} "
        ]
      },
      " является теоремой.\n\n\nДокажем лемму, предъявив вывод формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(D\\to D)"
        ]
      },
      " в исчислении высказываний.\n\n\n",
      {
        "name": "list",
        "props": {
          "order": true
        },
        "children": [
          {
            "name": "item",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "({D\\to((D\\to D)\\to D))}\\to{((D\\to(D \\to D))\\to(D\\to D))} "
                ]
              },
              "\\relax [аксиома 2 при ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "A=D"
                ]
              },
              ", ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "B=(D\\to D)"
                ]
              },
              ", ",
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "C=D"
                ]
              },
              "];"
            ]
          },
          "\n\n",
          {
            "name": "item",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "D\\to((D\\to D)\\to D)"
                ]
              },
              " [аксиома 1];"
            ]
          },
          "\n\n",
          {
            "name": "item",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(D\\to(D\\to D))\\to(D\\to D)"
                ]
              },
              " [из 1 и 2 по правилу MP];"
            ]
          },
          "\n\n",
          {
            "name": "item",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "D\\to(D\\to D)"
                ]
              },
              " [аксиома 1];"
            ]
          },
          "\n\n",
          {
            "name": "item",
            "props": {},
            "children": [
              {
                "name": "math",
                "props": {
                  "block": false
                },
                "children": [
                  "(D\\to D)"
                ]
              },
              " [из 3 и 4 по правилу MP]."
            ]
          },
          "\n"
        ]
      },
      "\n\n\nКак видно, вывод даже такой простой тавтологии, как ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(D\\to D)"
        ]
      },
      ", требует некоторой изобретательности.\nМы облегчим себе жизнь, доказав некоторое общее утверждение о выводимости.\n\n\nЧасто мы рассуждаем так: предполагаем, что выполнено какое-то утверждение ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ", и выводим различные следствия.\nПосле того как другое утверждение ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " доказано, мы вспоминаем, что использовали предположение ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ", и заключаем, что мы доказали утверждение ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to B"
        ]
      },
      ".\nСледующая лемма, называемая иногда «леммой о дедукции», показывает, что этот подход правомерен и для исчисления высказываний.\n\n\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " — некоторое множество формул.\n",
      {
        "name": "em",
        "props": {},
        "children": [
          "Выводом из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\Gamma"
            ]
          },
          " "
        ]
      },
      "\n",
      "",
      "\nназывается конечная последовательность формул, каждая из которых является аксиомой, принадлежит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " или получается из предыдущих по правилу MP.\n(Другими словами, мы как бы добавляем формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " к аксиомам исчисления высказываний — именно как формулы, а не как схемы аксиом.)\nФормула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "выводима из"
        ]
      },
      " ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ", ",
      "",
      "\nесли существует вывод из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ", в котором она является последней формулой.\nВ этом случае мы пишем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash A"
        ]
      },
      ".\nЕсли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " пусто, то речь идёт о выводимости в исчислении высказываний, и вместо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varnothing\\vdash A"
        ]
      },
      " пишут просто ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\vdash A"
        ]
      },
      ".\n\n\n",
      {
        "name": "format.pre",
        "props": {
          "key": "deduction-lemma"
        },
        "children": [
          "Лемма 2 (о дедукции)"
        ]
      },
      ".\n",
      "",
      "\n",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash A\\to B"
        ]
      },
      " тогда и только тогда, когда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\cup\\{A\\}\\vdash B"
        ]
      },
      ".\n\n\nВ одну сторону утверждение почти очевидно: пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash (A\\to B)"
        ]
      },
      ".\nТогда и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma, A\\vdash(A\\to B)"
        ]
      },
      ". (Для краткости мы опускаем фигурные скобки и заменяем знак объединения запятой.)\nСогласно определению, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma, A\\vdash A"
        ]
      },
      ", откуда по MP получаем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma, A\\vdash B"
        ]
      },
      ".\n\n\nПусть теперь ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma,A\\vdash B"
        ]
      },
      ".\nНам надо построить вывод формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to B"
        ]
      },
      " из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ".\nВозьмём вывод ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_1,C_2,\\ldots,C_n"
        ]
      },
      "\nформулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B=C_n"
        ]
      },
      " из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma, A"
        ]
      },
      ".\nПрипишем ко всем формулам этого вывода слева посылку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ":\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(A\\to C_1), (A\\to C_2),\\dots,(A\\to C_n).\n"
        ]
      },
      "\nЭта последовательность оканчивается на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B)"
        ]
      },
      ".\nСама по себе она не будет выводом из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ", но из неё можно получить такой вывод, добавив недостающие формулы, и тем самым доказать лемму о дедукции.\n\n\nБудем добавлять эти формулы, двигаясь слева направо.\nПусть мы подошли к формуле ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to C_i)"
        ]
      },
      ".\nПо предположению формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_i"
        ]
      },
      " либо совпадает с ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ", либо принадлежит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ", либо является аксиомой, либо получается из двух предыдущих по правилу MP.\nРассмотрим все эти случаи по очереди.\n\n\n(1) Если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_i"
        ]
      },
      " есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ", то очередная формула имеет вид ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to A)"
        ]
      },
      ".\nПо лемме 1 она выводима, так что перед ней мы добавляем её вывод.\n\n\n(2) Пусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_i"
        ]
      },
      " принадлежит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ".\nТогда мы вставляем формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_i"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_i\\to(A\\to C_i)"
        ]
      },
      " (аксиома 1).\nПрименение правила MP к этим формулам даёт ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to C_i)"
        ]
      },
      ", что и требовалось.\n\n\n(3) Те же формулы можно добавить, если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_i"
        ]
      },
      " является аксиомой исчисления высказываний.\n\n\n(4) Пусть, наконец, формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_i"
        ]
      },
      " получается из двух предыдущих формул по правилу MP.\nЭто значит, что в исходном выводе ей предшествовали формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C_j"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(C_j\\to C_i)"
        ]
      },
      ".\nТогда в новой последовательности (с добавленной посылкой ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ") уже были формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to C_j)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to(C_j\\to C_i))"
        ]
      },
      ".\nПоэтому мы можем продолжить наш ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      "-вывод, написав формулы\n\n\n",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "((A\\to(C_j\\to C_i))\\to((A\\to C_j)\\to (A\\to C_i))"
        ]
      },
      " (аксиома 2);\n\n",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "((A\\to C_j)\\to (A\\to C_i))"
        ]
      },
      " (modus ponens);\n\n",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to C_i)"
        ]
      },
      " (modus ponens).\n\n\nИтак, во всех четырёх случаях мы научились дополнять последовательность до вывода из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ", так что лемма о дедукции доказана.\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nДокажите, что для любых формул ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A,B,C"
            ]
          },
          " формула\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n(A\\to B)\\to((B\\to C)\\to (A\\to C))\n"
            ]
          },
          "\nвыводима в исчислении высказываний.\n(Указание: используйте лемму о дедукции и тот факт, что ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "{A\\to B}, {B\\to C}, A \\vdash C"
            ]
          },
          ".)\n"
        ]
      },
      "\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nДокажите, что если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\Gamma_1\\vdash A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\Gamma_2,A\\vdash B"
            ]
          },
          ", то ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\Gamma_1\\cup\\Gamma_2\\vdash B"
            ]
          },
          ".\n(Это свойство иногда называют «правилом сечения» (cut);\n",
          "",
          "\n",
          "",
          "\nговорят, что формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " «отсекается» или «высекается».\nСходные правила играют центральную роль в теории доказательств, где формулируется и доказывается «теорема об устранении сечения» для различных логических систем.)\n"
        ]
      },
      "\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nДобавим к исчислению высказываний, помимо правила MP, ещё одно правило, называемое ",
          {
            "name": "em",
            "props": {},
            "children": [
              "правилом подстановки"
            ]
          },
          ".\n",
          "",
          "\n",
          "",
          "\nОно разрешает заменить в выведенной формуле все переменные на произвольные формулы (естественно, вхождения одной переменной должны заменяться на одну и ту же формулу).\nПокажите, что после добавления такого правила класс выводимых формул не изменится, но лемма о дедукции перестанет быть верной.\n"
        ]
      },
      "\n\n\nЗаметим, что мы пока что использовали только две первые аксиомы исчисления высказываний.\nВидно, кстати, что они специально подобраны так, чтобы прошло доказательство леммы о дедукции.\n\n\nДругие аксиомы описывают свойства логических связок.\nАксиомы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "4"
        ]
      },
      " говорят, какие следствия можно вывести из конъюнкции (",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\land B \\vdash A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\land B \\vdash B"
        ]
      },
      ").\nНапротив, аксиома 5 говорит, как можно вывести конъюнкцию.\nИз неё легко следует такое правило: если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash B"
        ]
      },
      ", то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash(A\\land B)"
        ]
      },
      " (применяем эту аксиому и дважды правило MP).\nЧасто подобные правила записывают так:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\frac{\\Gamma\\vdash A \\qquad \\Gamma\\vdash B}{\\Gamma\\vdash A\\land B}\n"
        ]
      },
      "\n(над чертой пишут «посылки» правила, а снизу— его «заключение», вытекающее из посылок).\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nДокажите, что формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to{(B\\to C)})\\to ({(A\\land B)}\\to C)"
            ]
          },
          ", так же как и обратная к ней формула (в которой посылка и заключение переставлены), являются теоремами исчисления высказываний.\nДокажите аналогичное утверждение про формулы ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "{(A\\land B)}\\to{(B\\land A)} "
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "((A\\land B)\\land C)\\to (A\\land{(B\\land C)})"
            ]
          },
          ".\n"
        ]
      },
      "\n\n\nАксиомы 6—7 позволяют утверждать, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\vdash A\\lor B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B\\vdash A\\lor B"
        ]
      },
      ".\nАксиома 8 обеспечивает такое правило:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\frac{\\Gamma, A \\vdash C \\qquad \\Gamma,B\\vdash C}{\\Gamma, A\\lor B\\vdash C}\n"
        ]
      },
      "\nОно соответствует такой схеме рассуждения: «Предположим, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\lor B"
        ]
      },
      ".\nРазберём два случая.\nЕсли выполнено ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ", то ⟨...⟩ и потому ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ".\nЕсли выполнено ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ", то ⟨...⟩ и потому ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ".\nВ обоих случаях верно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ".\nЗначит, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\lor B"
        ]
      },
      " влечёт ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ".»\n\n\nОбоснование: дважды воспользуемся леммой о дедукции, получив ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash (A\\to C)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash(B\\to C)"
        ]
      },
      ", а затем дважды применим правило MP к этим формулам и аксиоме ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{(A\\to C)}\\to ({(B\\to C)}\\to ({(A\\lor B)}\\to C))"
        ]
      },
      ".\nПолучив формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{(A\\lor B)}\\to C"
        ]
      },
      ", опять применим правило MP к ней и формуле ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\lor B)"
        ]
      },
      ".\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nДокажите, что следующие формулы, а также обратные к ним (меняем местами посылку и заключение) являются теоремами исчисления высказываний:\n",
          {
            "name": "math",
            "props": {
              "block": true
            },
            "children": [
              "\n\\begin{align*}\n((A\\lor B)\\to C)&\\to ((A\\to C)\\land(B\\to C)),\\\\\n((A\\land C)\\lor (B\\land C))&\\to ((A\\lor B)\\land C),\\\\\n((A\\lor C)\\land (B\\lor C))&\\to ((A\\land B)\\lor C).\n\\end{align*}\n"
            ]
          },
          "\n"
        ]
      },
      "\n\nУ нас остались ещё три аксиомы, касающиеся отрицания.\nАксиома 9 гарантирует, что из противоречивого набора посылок можно вывести что угодно: если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash\\lnot A"
        ]
      },
      ", то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash B"
        ]
      },
      " для любого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ".\nАксиома 10, напротив, объясняет, как можно вывести отрицание некоторой формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ": надо допустить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и вывести два противоположных заключения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot B"
        ]
      },
      ".\nТочнее говоря, имеет место такое правило:\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\frac{\\Gamma, A\\vdash B\\qquad \\Gamma, A\\vdash\\lnot B}\n     {\\Gamma \\vdash \\lnot A}\n"
        ]
      },
      "\n(в самом деле, дважды применяем лемму о дедукции, а затем правило MP с аксиомой 10).\n\n\nАксиомы 9 и 10 позволяют вывести некоторые логические законы, связанные с отрицанием.\nДокажем, например, что (для любых формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ") формула\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(A\\to B)\\to(\\lnot B\\to\\lnot A)\n"
        ]
      },
      "\n(«закон контрапозиции») является теоремой исчисления высказываний.\nВ самом деле, по лемме о дедукции достаточно установить, что\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(A\\to B), \\lnot B \\vdash \\lnot A.\n"
        ]
      },
      "\nДля этого, в свою очередь, достаточно вывести из трёх посылок ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to B), \\lnot B, A"
        ]
      },
      " какую-либо формулу и её отрицание (в данном случае формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot B"
        ]
      },
      ").\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nВыведите формулы ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A\\to\\lnot\\lnot A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot\\lnot\\lnot A\\to\\lnot A"
            ]
          },
          " с помощью аналогичных рассуждений.\n"
        ]
      },
      "\n\n\nПоследняя аксиома, называемая «законом исключённого третьего», ",
      "",
      "\n",
      "",
      "\nи иногда читаемая как «третьего не дано»\n(tertium  ",
      "",
      "\nnon datur в латинском оригинале), вызвала в первой половине века большое количество споров.\n(См. раздел ",
      {
        "name": "label",
        "props": {
          "ref": "intuitionism"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "intuitionism_link"
            },
            "children": []
          }
        ]
      },
      " об интуиционистской логике, ",
      "",
      "\nв которой этой аксиомы нет.)\n\n\nИз неё можно вывести закон «снятия двойного отрицания», ",
      "",
      "\n",
      "",
      "\nформулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\lnot A\\to A"
        ]
      },
      ".\nДостаточно показать, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\lor \\lnot A, \\lnot\\lnot A \\vdash A"
        ]
      },
      ".\nПо правилу разбора случаев, достаточно установить, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A, \\lnot\\lnot A \\vdash A"
        ]
      },
      " (это очевидно) и что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A, \\lnot\\lnot A \\vdash A"
        ]
      },
      " (а это верно, так как из двух противоречащих друг другу формул выводится что угодно с помощью аксиомы 9).\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nДокажите, что формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(\\lnot B\\to\\lnot A)\\to(A\\to B)"
            ]
          },
          " является теоремой исчисления высказываний. (Указание: используйте закон исключённого третьего.)\n"
        ]
      },
      "\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nИсключим из числа аксиом исчисления высказываний закон исключённого третьего, заменив его на закон снятия двойного отрицания.\nПокажите, что от этого класс выводимых формул не изменится.\n"
        ]
      },
      "\n\n\n",
      {
        "name": "format.small",
        "props": {},
        "children": [
          {
            "name": "format.b",
            "props": {},
            "children": [
              {
                "name": "area",
                "props": {
                  "inline": true,
                  "key": "_link"
                },
                "children": [
                  {
                    "name": "counter",
                    "props": {
                      "use": "problem"
                    },
                    "children": []
                  }
                ]
              },
              ". "
            ]
          },
          "\nДокажите, что при наличии аксиомы исключённого третьего (11)\nаксиома (10) является лишней — её (точнее следовало бы сказать:\nлюбой частный случай этой схемы аксиом) можно вывести из остальных аксиом.\n"
        ]
      },
      "\n\n\nТеперь уже можно доказать теорему о полноте: всякая тавтология выводима в исчислении высказываний.\nИдея доказательства состоит в разборе случаев.\nПоясним её на примере.\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " — произвольная формула, содержащая переменные ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p,q,r"
        ]
      },
      ".\nПредположим, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " истинна, когда все три переменные истинны.\nТогда, как мы докажем, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p,q,r \\vdash A"
        ]
      },
      ".\nВообще каждой строке таблицы истинности для формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " соответствует утверждение о выводимости.\nНапример, если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      "\nложна, когда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "q"
        ]
      },
      " ложны, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "r"
        ]
      },
      " истинно, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p, \\lnot q, r \\vdash \\lnot A"
        ]
      },
      ".\nЕсли формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " является тавтологией, то окажется, что она выводима из всех восьми возможных вариантов посылок.\nПользуясь законом исключённого третьего, можно постепенно избавляться от посылок.\nНапример, из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p,q,r\\vdash A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p,q,\\lnot r\\vdash A"
        ]
      },
      " можно получить ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p,q,(r\\lor\\lnot r)\\vdash A"
        ]
      },
      ", то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p,q\\vdash A"
        ]
      },
      " (поскольку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(r\\lor\\lnot r)"
        ]
      },
      " является аксиомой).\n\n\nПроведём это рассуждение подробно.\nНачнём с такой леммы:\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма 3"
        ]
      },
      ".\nДля произвольных формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      "\n\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{align*}\nP,Q&\\vdash (P\\land Q);& P,Q&\\vdash (P\\lor Q);\\\\\nP,\\lnot Q&\\vdash \\lnot (P\\land Q);& P,\\lnot Q&\\vdash (P\\lor Q);\\\\\n\\lnot P,Q&\\vdash \\lnot (P\\land Q);& \\lnot P,Q&\\vdash (P\\lor Q);\\\\\n\\lnot P, \\lnot Q;&\\vdash \\lnot (P\\land Q)& \\lnot P, \\lnot Q&\\vdash \\lnot (P\\lor Q);\\\\[1.5ex]\nP,Q&\\vdash (P\\to Q);&&\\\\\nP,\\lnot Q&\\vdash \\lnot (P\\to Q);& P&\\vdash \\lnot (\\lnot P);\\\\\n\\lnot P,Q&\\vdash (P\\to Q);& \\lnot P&\\vdash \\lnot P.\\\\\n\\lnot P, \\lnot Q&\\vdash (P\\to Q);&&\n\n\\end{align*}\n"
        ]
      },
      "\n\nЭта лемма говорит, что если принять в качестве гипотез истинность или ложность формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      ", являющихся частями конъюнкции, дизъюнкции или импликации, то можно будет доказать или опровергнуть всю формулу (в зависимости от того, истинна она или ложна).\nПоследняя часть содержит аналогичное утверждение про отрицание.\n\n\nПосле предпринятой нами тренировки доказать эти утверждения несложно.\nНапример, убедимся, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P\\vdash\\lnot(P\\land Q)"
        ]
      },
      ".\nДля этого достаточно вывести два противоположных утверждения из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P, (P\\land Q)"
        ]
      },
      "; ими будут утверждения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      "\nи ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P"
        ]
      },
      ".\n\n\nПроверим ещё одно утверждение: ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P, \\lnot Q\\vdash\\lnot (P\\lor Q)"
        ]
      },
      ".\nНам надо вывести два противоположных утверждения из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P, \\lnot Q, (P\\lor Q)"
        ]
      },
      ".\nПокажем, что из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P, \\lnot Q, (P\\lor Q)"
        ]
      },
      " следует всё, что угодно.\nПо правилу разбора случаев достаточно убедиться, что из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P, \\lnot Q, P"
        ]
      },
      " и из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P, \\lnot Q, Q"
        ]
      },
      " следует всё, что угодно — но это мы знаем.\n\n\nУтверждения, касающиеся импликации, просты: в самом деле, мы знаем, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q\\vdash (P\\to Q)"
        ]
      },
      " благодаря аксиоме 1, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot P\\vdash (P\\to Q)"
        ]
      },
      " благодаря аксиоме 9.\n\n\nОстальные утверждения леммы столь же просты.\n\n\nТеперь мы можем сформулировать утверждение о разборе случаев для произвольной формулы.\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма 4"
        ]
      },
      ".\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " — произвольная формула, составленная из переменных ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1,\\ldots,p_n"
        ]
      },
      ".\nТогда для каждой строки таблицы истинности формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " имеет место соответствующее утверждение о выводимости: если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon_1,\\dots,\\varepsilon_n, \\varepsilon\\in\\{0,1\\} "
        ]
      },
      ", и значение формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varepsilon"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1=\\varepsilon_1,\\dots,p_n=\\varepsilon_n"
        ]
      },
      ", то\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\lnot_{\\varepsilon_1} p_1,\\dots,\\lnot_{\\varepsilon_n} p_n         \\vdash \\lnot_{\\varepsilon A}\n"
        ]
      },
      ",\nгде ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot_u \\varphi"
        ]
      },
      " обозначает ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u=1"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot \\varphi"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u=0"
        ]
      },
      " (напомним, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      " обозначает истину, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " — ложь).\n\n\nЛемма очевидно доказывается индукцией по построению формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ".\nМы имеем посылки, утверждающие истинность или ложность переменных, и для всех подформул (начиная с переменных и идя ко всей формуле) выводим их или их отрицания с помощью леммы 3.\n\n\nЕсли формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " является тавтологией, то из всех ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^n"
        ]
      },
      " вариантов посылок выводится именно она, а не её отрицание.\nТогда правило разбора случаев и закон исключённого третьего позволяют избавиться от посылок: сгруппируем их в пары, отличающиеся в позиции ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1"
        ]
      },
      " (в одном наборе посылок стоит ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1"
        ]
      },
      ", в другом ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p_1"
        ]
      },
      "), по правилу разбора случаев заменим их на посылку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(p_1\\lor\\lnot p_1)"
        ]
      },
      ", которую можно выбросить (она является аксиомой).\nСделав так для всех пар, получим ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{n-1} "
        ]
      },
      " выводов, в посылках которых нет ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1"
        ]
      },
      "; повторим этот процесс с посылками ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_2"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p_2"
        ]
      },
      " и т.д.\nВ конце концов мы убедимся, что формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      "\nвыводима без посылок, как и утверждает теорема о полноте.\n",
      " ᐅ"
    ]
  },
  "\n",
  "\n\n\n",
  "\n",
  {
    "name": "header",
    "props": {
      "key": "completeness-second-proof",
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Второе доказательство теоремы о полноте"
    ]
  },
  "\n\n\nЭто доказательство, в отличие от предыдущего, обобщается на более сложные случаи (исчисление предикатов, интуиционистское исчисление высказываний).\n",
  "",
  "\n\n\nНачнём с такого определения: множество формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  "\nназывается ",
  {
    "name": "em",
    "props": {},
    "children": [
      "совместным"
    ]
  },
  ", ",
  "",
  "\n",
  "",
  "\nесли существует набор значений переменных, при которых все формулы из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " истинны.\nЗаметим, что формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " является тавтологией тогда и только тогда, когда множество, состоящее из единственной формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot \\varphi"
    ]
  },
  ", не является совместным.\nДля случая одной формулы есть специальный термин: формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\tau"
    ]
  },
  " ",
  {
    "name": "em",
    "props": {},
    "children": [
      "выполнима"
    ]
  },
  ", ",
  "",
  "\n",
  "",
  "\nесли существуют значения переменных, при которых она истинна, то есть если множество ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\{\\tau\\} "
    ]
  },
  " совместно.\nТавтологии — это формулы, отрицания которых не выполнимы.\n\n\nМножество формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " называется ",
  {
    "name": "em",
    "props": {},
    "children": [
      "противоречивым"
    ]
  },
  ", ",
  "",
  "\n",
  "",
  "\nесли из него одновременно выводятся формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  ".\nМы знаем, что в этом случае из него выводятся вообще все формулы.\n(В противном случае ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " называется ",
  {
    "name": "em",
    "props": {},
    "children": [
      "непротиворечивым"
    ]
  },
  ".)\n",
  "",
  "\n",
  "",
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "correctness-second-form",
      "name": "корректность исчисления высказываний, вторая форма",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "correctness-second-form_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "correctness-second-form_link"
            },
            "children": []
          },
          " (",
          "корректность исчисления высказываний, вторая форма",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nВсякое совместное множество формул непротиворечиво.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nВ самом деле, пусть совместное множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " противоречиво.\nТак как оно совместно, существуют значения переменных, при которых все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " истинны.\nС другой стороны, из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " выводится некоторая формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и её отрицание.\nМожет ли так быть?\n\n\nОказывается, что нет.\nМы уже видели, что всякая выводимая формула истинна при всех значениях переменных (является тавтологией).\nСправедливо и несколько более общее утверждение:\nесли ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash A"
        ]
      },
      " и при некоторых значениях переменных все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " истинны, то и формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " истинна при этих значениях переменных.\n(Как и раньше, это легко доказывается индукцией по построению вывода ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ".)\n\n\nВ нашей ситуации это приводит к тому, что на выполняющем наборе значений переменных для ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " должны быть истинны обе формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot B"
        ]
      },
      ", что, разумеется, невозможно.\n",
      " ᐅ"
    ]
  },
  "\n\n\nМы называем это утверждение другой формой теоремы о корректности исчисления высказываний, поскольку из него формально можно вывести, что всякая теорема является тавтологией: если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " — теорема, то множество ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\{\\lnot A\\} "
    ]
  },
  " противоречиво (из него выводятся ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  "), потому несовместно, значит, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  " всегда ложна, поэтому ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " всегда истинна.\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "completeness-second-form",
      "name": "полнота исчисления высказываний, вторая форма",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "completeness-second-form_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "completeness-second-form_link"
            },
            "children": []
          },
          " (",
          "полнота исчисления высказываний, вторая форма",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nВсякое непротиворечивое множество совместно.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНам дано непротиворечивое множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ", а надо найти такие значения переменных, при которых все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      "\nистинны.\n(Вообще говоря, множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " может быть бесконечно и содержать бесконечное число разных переменных.)\n\n\nПусть есть какая-то переменная ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ", встречающаяся в формулах из семейства ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ".\nНам надо решить, сделать ли её истинной или ложной.\nЕсли оказалось так, что из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " выводится формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ", то выбора нет: она обязана быть истинной в тех наборах, где формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " истинны (как мы видели при доказательстве корректности).\nПо тем же причинам, если из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " выводится ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p"
        ]
      },
      ", то в выполняющем наборе переменная ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " обязательно будет ложной.\n\n\nЕсли оказалось так, что для любой переменной ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " либо она сама, либо её отрицание выводятся из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ", то выполняющий набор значений определён однозначно, и надо только проверить, что он действительно будет выполняющим.\nА если для каких-то переменных нельзя вывести ни их, ни их отрицание, то мы пополним наш набор ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " так, чтобы они, как теперь модно говорить, «определились».\n\n\nПроведём это рассуждение подробно.\nРассмотрим все переменные, входящие в какие-либо формулы из множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      "; обозначим множество этих переменных через ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "V"
        ]
      },
      ".\nЗафиксируем это множество и до конца доказательства теоремы о полноте будем рассматривать только формулы с переменными из множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "V"
        ]
      },
      ", не оговаривая этого особо.\n\n\nНазовём непротиворечивое множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "полным"
        ]
      },
      ", ",
      "",
      "\n",
      "",
      "\nесли для любой формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " имеет место либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash F"
        ]
      },
      ", либо ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash \\lnot F"
        ]
      },
      " (одновременно этого быть не может, так как ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " непротиворечиво).\n\n\nУтверждение теоремы о полноте очевидно следует из двух лемм:\n\n\n",
      {
        "name": "format.pre",
        "props": {
          "key": "completeness-second-proof-lemma-1"
        },
        "children": [
          "Лемма 1."
        ]
      },
      "\nВсякое непротиворечивое множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      "\nсодержится в непротиворечивом полном множестве ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Delta"
        ]
      },
      ".\n\n\n",
      {
        "name": "format.pre",
        "props": {
          "key": "completeness-second-proof-lemma-2"
        },
        "children": [
          "Лемма 2."
        ]
      },
      "\nДля всякого непротиворечивого полного множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Delta"
        ]
      },
      " существует набор значений переменных (из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "V"
        ]
      },
      ", напомним), при котором все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Delta"
        ]
      },
      " истинны.\n\n\nДоказательство леммы 1.\nОсновную роль здесь играет такое утверждение: если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " — непротиворечивое множество, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " —\nпроизвольная формула, то хотя бы одно из множеств ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\cup\\{A\\} "
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\cup\\{\\lnot A\\} "
        ]
      },
      " непротиворечиво.\nВ самом деле, если оба множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\cup\\{A\\} "
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\cup\\{\\lnot A\\} "
        ]
      },
      " противоречивы, то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash\\lnot A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash\\lnot\\lnot A"
        ]
      },
      ", но множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " предполагалось непротиворечивым.\n\nЕсли множество переменных ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "V"
        ]
      },
      " конечно или счётно, то доказательство леммы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      " легко завершить: множество всех формул тогда счётно, и просматривая их по очереди, мы можем добавлять к ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " либо саму формулу, либо её отрицание, сохраняя непротиворечивость.\nПолучится, очевидно, полное множество.\nЧуть менее очевидна его непротиворечивость: оно было непротиворечиво на каждом шаге, но почему предельное множество (объединение возрастающей последовательности)\nбудет непротиворечиво? Дело в том, что в выводе двух противоречащих друг другу формул может быть задействовано только конечное число формул из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " (по определению выводимости: вывод есть конечная последовательность формул).\nПоэтому все эти формулы должны появиться на некотором конечном шаге конструкции, а это невозможно (на всех шагах множество непротиворечиво).\n\n\nДля случая произвольного набора переменных ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "V"
        ]
      },
      " рассуждение можно завершить ссылкой на лемму Цорна:\n",
      "",
      "\n",
      "",
      "\nрассмотрим частично упорядоченное множество, элементами которого будут непротиворечивые множества формул, а порядком — отношение «быть подмножеством».\nРассуждение предыдущего абзаца показывает, что всякая цепь в этом множестве имеет верхнюю границу (объединение линейно упорядоченного по включению семейства непротиворечивых множеств является непротиворечивым множеством).\nСледовательно, для любого непротиворечивого множества найдётся содержащее его максимальное непротиворечивое множество.\nА оно обязано быть полным (иначе его можно расширить, добавив ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " или ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot A"
        ]
      },
      ").\n\n\nЛемма 1 доказана.\n\n\nДоказательство леммы 2.\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " — непротиворечивое полное множество.\nТогда для каждой переменной (из множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "V"
        ]
      },
      ") ровно одна из формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot p"
        ]
      },
      " выводима из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ".\nЕсли первая, будем считать переменную ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " истинной, если вторая —\nложной.\nТем самым появляется некоторый набор ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\nu"
        ]
      },
      " значений переменных, и надо только проверить, что любая формула из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " при таких значениях переменных истинна.\nЭто делается так: индукцией по построению формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " мы доказываем, что\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{align*}\nA \\text{ истинна на наборе } \\nu & \\Rightarrow \\Gamma\\vdash A,\\\\\nA \\text{ ложна на наборе } \\nu &\\Rightarrow \\Gamma\\vdash \\lnot A.\n\\end{align*}\n"
        ]
      },
      "\nБазис индукции (когда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " — переменная) обеспечивается определением истинности переменных.\nДля шага индукции используется та же лемма, что и при доказательстве полноты с помощью разбора случаев.\nПусть, например, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " имеет вид ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(B\\land C)"
        ]
      },
      ".\nТогда есть четыре возможности для истинности ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      ".\nВ одном из них (когда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " истинны на ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\nu"
        ]
      },
      ") по предположению индукции мы имеем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash C"
        ]
      },
      ", откуда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash (B\\land C)"
        ]
      },
      ", то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash A"
        ]
      },
      ".\nВ другом (",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " истинна, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "C"
        ]
      },
      " ложна) предположение индукции даёт ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash \\lnot C"
        ]
      },
      ", откуда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash\\lnot(B\\land C)"
        ]
      },
      ", то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma\\vdash\\lnot A"
        ]
      },
      ".\nАналогично разбираются и все остальные случаи и логические связки.\nЛемма 2 доказана, и тем самым завершено доказательство теоремы ",
      {
        "name": "label",
        "props": {
          "ref": "completeness-second-form"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "completeness-second-form_link"
            },
            "children": []
          }
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\nМы доказали, что всякое непротиворечивое множество формул совместно.\nОтсюда легко следует, что всякая тавтология является теоремой.\nВ самом деле, если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varphi"
    ]
  },
  " — тавтология, множество ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\{\\lnot\\varphi\\} "
    ]
  },
  " несовместно, поэтому из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot \\varphi"
    ]
  },
  "\nвыводится противоречие, поэтому ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\vdash \\lnot\\lnot\\varphi"
    ]
  },
  ", и по закону снятия двойного отрицания ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\vdash\\varphi"
    ]
  },
  ".\n\n\nКроме того, теорема о полноте во второй формулировке имеет такое очевидное следствие:\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "propositional-compactness",
      "name": "теорема компактности для исчисления высказываний",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "propositional-compactness_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "propositional-compactness_link"
            },
            "children": []
          },
          " (",
          "теорема компактности для исчисления высказываний",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " — множество формул, всякое конечное подмножество которого совместно.\nТогда и всё множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " совместно.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nКак мы знаем, несовместность равносильна противоречивости, а вывод противоречия по определению может использовать лишь конечное число формул.\n",
      " ᐅ"
    ]
  },
  "\n\n\nПоскольку в формулировке теоремы компактности нет упоминания об исчислении высказываний (речь идёт лишь об истинности формул, а не о выводимости), возникает вопрос, нельзя ли её доказать непосредственно.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nДайте прямое доказательство теоремы компактности для случая, когда переменных в множестве ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "V"
        ]
      },
      " конечное число. (Указание: любое несовместное множество имеет несовместное подмножество мощности не больше ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "2^{|V|} "
        ]
      },
      ".)\n"
    ]
  },
  "\n\n\nДля случая счётного числа переменных можно воспользоваться компактностью (в топологическом смысле слова) канторовского пространства.\n",
  "",
  "\nЕго элементами являются бесконечные последовательности нулей и единиц.\nЕсли две последовательности отличаются в ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "n"
    ]
  },
  "-й позиции, а все предыдущие члены совпадают, то расстояние между ними считается равным ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "2^{-n} "
    ]
  },
  ".\nЭто метрическое пространство компактно.\n\n\nПусть ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "V"
    ]
  },
  " содержит счётное число переменных.\nПоследовательность значений переменных будем рассматривать как точку канторовского пространства; формуле соответствует область, состоящая из точек, где формула истинна.\nПоскольку формула содержит лишь конечное число переменных, эта область является замкнутым и открытым множеством одновременно.\nПусть имеется множество формул, любое конечное подмножество которого совместно.\nЭто значит, что соответствующие формулам подмножества канторовского пространства образуют, как говорят, центрированную систему ",
  "",
  "\n(любое конечное их число имеет общую точку).\nА в компактном пространстве любое центрированное семейство замкнутых множеств имеет общую точку (иначе их дополнения образуют открытое покрытие, у которого нет конечного подпокрытия).\nЭта их общая точка и будет набором значений, на котором все формулы истинны.\n\n\nТо же самое рассуждение годится и для несчётного множества переменных, но тогда возникает несчётное произведение двухточечных пространств, которое является топологическим пространством (но не метрическим); надо заметить, что это пространство компактно по теореме Тихонова, ",
  "",
  "\n",
  "",
  "\nпосле чего наше рассуждение проходит.\n\n\nДля счётного набора переменных теорема компактности связана с так называемой ",
  {
    "name": "em",
    "props": {},
    "children": [
      "леммой Кёнига"
    ]
  },
  ".\n",
  "",
  "\nКонечные последовательности нулей и единиц (включая пустую последовательность) мы называем двоичными словами.\nДвоичным деревом ",
  "",
  "\nмы называем множество двоичных слов, которое вместе со всяким словом содержит все его начала (начальные отрезки).\nБесконечной ветвью двоичного дерева ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "T"
    ]
  },
  " мы называем бесконечную последовательность нулей и единиц, любое конечное начало которой принадлежит ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "T"
    ]
  },
  ".\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "лемма Кёнига",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "лемма Кёнига",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\n",
      "",
      "\nЛюбое бесконечное дерево имеет бесконечную ветвь.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nГоворя о бесконечности дерева, мы имеем в виду, что соответствующее множество бесконечно.\nОтсюда следует, что оно содержит слова сколь угодно большой длины.\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1,p_2,\\dots"
        ]
      },
      " — счётное множество переменных, которые принимают значения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "0"
        ]
      },
      " или ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1"
        ]
      },
      ".\nДля каждого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "n"
        ]
      },
      " рассмотрим формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi_n"
        ]
      },
      ", которая утверждает, что слово ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p_1p_2\\dots p_n"
        ]
      },
      " принадлежит дереву ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T"
        ]
      },
      " (это возможно, так как любая булева функция выразима формулой).\nПоскольку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "T"
        ]
      },
      " — дерево, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi_i"
        ]
      },
      " влечёт ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi_j"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "j<i"
        ]
      },
      ".\nЛюбое конечное множество формул вида ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi_i"
        ]
      },
      " равносильно, таким образом, одной формуле с максимальным ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "i"
        ]
      },
      " и потому совместно.\nСледовательно, и множество всех формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi_i"
        ]
      },
      " совместно, и выполняющий набор определяет бесконечную ветвь.\n",
      " ᐅ"
    ]
  },
  "\n\n\n(Конечно, мы «бьём из пушек по воробьям»: достаточно индукцией по ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "i"
    ]
  },
  " строить слово длины ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "i"
    ]
  },
  ", которое имеет бесконечное число продолжений в дереве ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "T"
    ]
  },
  ".)\n\n\nОбычно утверждение леммы Кёнига формулируют так: если колония бактерий, возникшая из одной бактерии, никогда не вымирает полностью, то существует бесконечная последовательность бактерий, каждая следующая из которых получается при делении предыдущей. [Аналогичная формулировка про людей осложняется возможностью клонирования, наличием двух полов и проблемами политкорректности.]\n",
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Поиск контрпримера и исчисление секвенций"
    ]
  },
  "\n\n\nВ этом разделе мы построим другой вариант исчисления высказываний — так называемое ",
  {
    "name": "em",
    "props": {},
    "children": [
      "исчисление секвенций"
    ]
  },
  ".\n",
  "",
  "\nТакого рода исчисления изучаются в теории доказательств.\nОни оказываются более удобными для анализа синтаксической структуры выводов.\nИх называют исчислениями генценовского типа ",
  "",
  "\n(по имени Генцена, ",
  "",
  "\nкоторый начал их изучать).\nРанее приведённый вариант исчисления высказываний называют исчислением гильбертовского типа ",
  "",
  "\n(по имени Гильберта, ",
  "",
  "\nкоторый использовал подобные исчисления в своей программе формального построения математики).\n\n\nДля начала мы вообще не будем говорить ничего об аксиомах и правилах вывода, а рассмотрим задачу поиска контрпримера.\nПусть дана некоторая формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ", про которую мы подозреваем, что она не является тавтологией, и хотим найти значения переменных, при которых она ложна.\nКак это делать? Естественно посмотреть на структуру формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ".\nНапример, если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " имеет вид ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B\\to C"
    ]
  },
  ", то надо найти значения переменных, при которых формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " истинна, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "C"
    ]
  },
  " ложна.\nЕсли ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " имеет вид ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B\\lor C"
    ]
  },
  ", то надо найти значения переменных, при которых обе формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "C"
    ]
  },
  " ложны.\nЕсли ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " имеет вид ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B\\land C"
    ]
  },
  ", то надо найти либо значения переменных, при которых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " ложна, либо значения переменных, при которых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "C"
    ]
  },
  " ложна.\nТем самым задача поиска контрпримера для формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " сводится к одной или нескольким задачам такого же или более общего вида (надо обеспечить истинность или ложность одной или нескольких формул).\n\n\nВведём необходимую терминологию и обозначения.\nБудем называть ",
  {
    "name": "em",
    "props": {},
    "children": [
      "секвенцией"
    ]
  },
  "\n",
  "",
  "\nвыражение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma\\vdash\\Delta"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Delta"
    ]
  },
  " — некоторые конечные множества формул.\n(Пока что знак ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\vdash"
    ]
  },
  " не имеет ничего общего с выводимостью, а только разделяет два множества формул.)\nС каждой секвенцией ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma\\vdash\\Delta"
    ]
  },
  " будем связывать задачу поиска таких значений переменных, при которых все формулы из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " истинны, а все формулы из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Delta"
    ]
  },
  " ложны.\nТакой набор значений мы по некоторым причинам будем называть ",
  {
    "name": "em",
    "props": {},
    "children": [
      "контрпримером"
    ]
  },
  "\n",
  "",
  "\nк секвенции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma\\vdash\\Delta"
    ]
  },
  ".\nЛегко проверить, что контрпримеры к секвенции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma\\vdash\\Delta"
    ]
  },
  " —\nэто контрпримеры к формуле\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\land \\Gamma\\to\\lor\\Delta,\n"
    ]
  },
  "\n(",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\land\\Gamma"
    ]
  },
  " обозначает конъюнкцию формул из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lor\\Delta"
    ]
  },
  " — дизъюнкцию формул из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Delta"
    ]
  },
  "), то есть те наборы значений, при которых эта формула ложна.\nПри этом конъюнкцию пустого множества формул мы считаем тождественно истинной, а дизъюнкцию — тождественно ложной.\n\n\nНаша исходная задача поиска контрпримера к формуле ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " может быть теперь сформулирована как задача поиска контрпримера к секвенции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\vdash A"
    ]
  },
  ".\n(Мы позволяем себе писать так для краткости; полностью следовало бы написать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varnothing\\vdash\\{A\\} "
    ]
  },
  ".)\n\n\nЗадачу поиска контрпримера к секвенции можно решать с помощью следующих правил.\nВ каждом из приведенных правил нижний заказ на контрпример выполним, если и только если выполним один из верхних заказов, т.е. нижняя секвенция имеет контрпример тогда и только тогда, когда хотя бы одна из верхних секвенций имеет контрпример.\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{align*}\n\\frac{\\Gamma\\vdash A,\\Delta\\qquad \\Gamma\\vdash B,\\Delta}\n{\\Gamma\\vdash A\\wedge B,\\Delta}\n        \\qquad&\\qquad \\frac{A,B,\\Gamma\\vdash\\Delta}\n{A\\wedge B,\\Gamma\\vdash\\Delta}\n        \\\\[0.7ex]\n\\frac{\\Gamma\\vdash A, B,\\Delta}\n{\\Gamma\\vdash A\\vee B,\\Delta}\n        \\qquad&\\qquad \\frac{A,\\Gamma\\vdash \\Delta\\qquad B,\\Gamma\\vdash \\Delta}\n{A\\vee B,\\Gamma\\vdash \\Delta}\n        \\\\[0.7ex]\n\\frac{\\Gamma,A\\vdash  B,\\Delta}\n{\\Gamma\\vdash A\\to B,\\Delta}\n        \\qquad&\\qquad \\frac{\\Gamma\\vdash A,\\Delta\\qquad \\Gamma,B\\vdash\\Delta}\n{A\\to B,\\Gamma\\vdash \\Delta}\n        \\\\[0.7ex]\n\\frac{A,\\Gamma\\vdash \\Delta}\n{\\Gamma\\vdash \\neg A,\\Delta}\n        \\qquad&\\qquad \\frac{\\Gamma\\vdash A,\\Delta}\n{\\neg A,\\Gamma\\vdash \\Delta}\n\\end{align*}\n"
    ]
  },
  "\n\nКаждое из правил соответствует анализу одной из формул нижней секвенции.\nПравила разделены на группы в зависимости от главной связки анализируемой формулы, и согласованы с таблицами истинности для этой связки (что легко проверить).\nЗапятая в правилах используется как сокращение: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma,A"
    ]
  },
  " обозначает ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma\\cup\\{A\\} "
    ]
  },
  " и т.д.\n\n\nКак пользоваться этими правилами?\nВозьмём секвенцию, к которой мы ищем контрпример.\nВыберем в ней одну из формул слева или справа, посмотрим на главную связку и применим соответствующее правило (написав одну или две секвенции над исходной).\nЗатем к каждой из них снова применим одно из правил и т.д.\nПостепенно будет расти «дерево поиска контрпримера», причём исходная секвенция будет иметь контрпример тогда и только тогда, когда одна из верхних секвенций (стоящих в «листьях») этого дерева имеет контрпример.\n\n\nКогда этот процесс обрывается?\nЭто происходит в том случае, если все формулы в оставшихся секвенциях представляют собой переменные, тогда ни одно из наших правил поиска контрпримера не применимо.\nНо к этому моменту всё становится ясным: если в левой и правой части секвенции есть общая переменная, то к ней нет контрпримера (одна и та же переменная не может быть одновременно истинной и ложной).\nЕсли же левая и правая часть такой секвенции не пересекаются, то контрпример есть.\n\n\nВот как это делается с секвенцией ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "{\\vdash(p\\to q)}\\to q"
    ]
  },
  ":\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\frac{\\mathstrut\\vdash p,q\\;\\qquad q\\vdash q}\n{\\frac{\\displaystyle \\mathstrut(p\\to q)\\vdash q}\n{\\displaystyle \\mathstrut\\vdash (p\\to q)\\to q} }\n"
    ]
  },
  "\nКонтрпример найден: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " ложны (он является контрпримером к секвенции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\vdash p,q"
    ]
  },
  ").\n\n\nНапротив, поиск контрпримера к секвенции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "{\\vdash((p\\to q)\\to p)}\\to p"
    ]
  },
  "\nне даёт результата:\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\frac{\\frac{\n\\frac{\\displaystyle \\mathstrut p\\vdash p,q}\n     {\\displaystyle \\mathstrut\\vdash p,p\\to q}\\qquad \\displaystyle      \\mathstrut p\\vdash p}\n{\\displaystyle \\mathstrut (p\\to q)\\to p\\vdash p} }\n{\\mathstrut\\vdash((p\\to q)\\to p)\\to p}\n"
    ]
  },
  "\nЗдесь обе секвенции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\vdash p,q"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\vdash p"
    ]
  },
  " не имеют контрпримеров.\nСледовательно, формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\to q)\\to p)\\to p"
    ]
  },
  " является тавтологией.\n\n\nПостроенный алгоритм можно одновременно рассматривать как доказательство полноты некоторого «исчисления секвенций».\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Аксиомами"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nисчисления секвенций будем называть секвенции, в левых и правых частях которых встречаются только переменные, причём некоторая переменная встречается в обеих частях.\n\n\n",
  {
    "name": "em",
    "props": {},
    "children": [
      "Правилами вывода"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\nв исчислении секвенций являются правила нашей таблицы.\nКаждое из этих правил объявляет выводимой нижнюю секвенцию, если выводимы все верхние. (Процесс вывода естественно представлять в виде дерева, как в наших примерах, но можно развернуть и в последовательность секвенций.)\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "корректность и полнота исчисления секвенций",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "корректность и полнота исчисления секвенций",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nСеквенция выводима тогда и только тогда, когда она не имеет контрпримера.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nАксиомы не имеют контрпримера.\nЕсли все верхние секвенции какого-то правила вывода не имеют контрпримера, то и нижняя секвенция не имеет контрпримера. (Именно так мы подбирали правила: контрпример к нижней секвенции будет контрпримером к одной из верхних.)\nСледовательно, все выводимые секвенции не имеют контрпримера.\n\n\nОбратно, пусть секвенция не имеет контрпримера.\nТогда описанный процесс поиска контрпримера обрывается на аксиомах и тем самым даёт её вывод.\n",
      " ᐅ"
    ]
  },
  "\n\n\nВ частности, если формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " является тавтологией, то секвенция ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "{\\vdash A} "
    ]
  },
  " выводима в исчислении секвенций.\nЭто обстоятельство можно использовать для ещё одного доказательства полноты исчисления высказываний (в стандартной, гильбертовской форме).\nВ самом деле, для каждой секвенции ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma\\vdash\\Delta"
    ]
  },
  " рассмотрим ",
  {
    "name": "em",
    "props": {},
    "children": [
      "представляющую её формулу"
    ]
  },
  ", ",
  "",
  "\n",
  "",
  "\nто есть формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "{\\land \\Gamma} \\to {\\lor\\Delta} "
    ]
  },
  " (в левой и правой частях стоят конъюнкция и дизъюнкция формул из ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Delta"
    ]
  },
  " соответственно).\nТеперь индукцией по построению вывода в исчислении секвенций надо доказать такой факт: если секвенция выводима в исчислении секвенций, то представляющая её формула выводима в (обычном) исчислении высказываний.\n\n\nЭто требует довольно хлопотной проверки, впрочем.\nСначала надо проверить, что конъюнкция и дизъюнкция доказуемо ассоциативны, и потому всё равно, как расставлять скобки в формуле, представляющей секвенцию.\nЗатем полезно убедиться, что правила, связанные с отрицанием (два последних правила таблицы) можно применять в обе стороны, не меняя выводимости соответствующей формулы.\nДругими словами, надо проверить, что формулы\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n \\Gamma\\to(\\Delta\\lor A) \\quad \\text{и} \\quad  (\\Gamma\\land\\lnot A)\\to\\Delta,\n"
    ]
  },
  "\nа также формулы\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\Gamma\\to(\\Delta\\lor \\lnot A) \\quad \\text{и} \\quad  (\\Gamma\\land A)\\to\\Delta\n"
    ]
  },
  "\nвыводимы одновременно (здесь ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Delta"
    ]
  },
  " можно считать формулами, а не множествами формул, расставив скобки надлежащим образом).\nПосле этого мы можем переносить формулы из одной части в другую (меняя их на противоположные), и потому можем считать одно из множеств ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Gamma"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\Delta"
    ]
  },
  " пустым, если это нам удобно.\nТеперь ссылка на лемму о дедукции и уже известные нам свойства выводимости завершает рассуждение.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПровести это рассуждение подробно.\n"
    ]
  },
  "\n\n\nЕстественно возникает вопрос — чем уж так интересно исчисление секвенций?\nКакая, собственно говоря, разница — иметь дело с секвенциями или с формулами, раз всякую секвенцию можно представить формулой?\nПринципиальное различие тут в следующем.\nПравила вывода в исчислении секвенций таковы, что в их верхнюю часть входят только подформулы формул, встречающихся в нижней части.\nПоэтому в выводе какой-то секвенции не может встретиться ничего принципиально нового, чего не было в самой секвенции.\nВ гильбертовском исчислении это далеко не так: мы можем вывести формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to B"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ", при этом формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " может быть совершенно произвольной.\nЭто же различие объясняет, почему поиск вывода снизу вверх (как можно теперь называть то, что раньше называлось поиском контрпримера — мы находим либо контрпример, либо вывод) для исчисления секвенций происходит сравнительно однозначно (мы можем по-разному выбирать расчленяемую формулу, но и только), в то время как искать вывод в обычном исчислении высказываний, начав с интересующей нас формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  " и смотря, из чего бы она могла получиться, не удаётся (если только не перебирать все формулы подряд).\n\n\nЗаметим, что добавление к исчислению секвенций уже упоминавшегося правила сечения\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\frac{\\Gamma\\vdash \\Delta,A \\qquad \\Gamma, A\\vdash \\Delta}\n     {\\Gamma \\vdash \\Delta}\n"
    ]
  },
  "\nнарушает свойство «подформульности», так как формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " может быть никак не связана с нижней секвенцией.\nОтметим, что добавление правила сечения не нарушает корректности, как легко проверить, и не может нарушить полноты.\n\n\nЗадачи о поиске вывода и анализе его структуры, хотя и были одно время модными в связи с «искусственным интеллектом», представляют большой интерес, и про них есть целая наука, в которой исчисления генценовского типа играют центральную роль.\nМы рассмотрели один из вариантов исчисления секвенций для классического исчисления высказываний; бывают исчисления для интуиционистских и модальных логик, для исчисления предикатов и т.д.\nИсходной мотивацией для рассмотрения такого рода исчислений было желание доказать непротиворечивость арифметики.\nСогласно знаменитой второй теореме Гёделя ",
  "",
  " о неполноте ",
  "",
  "\nбез дополнительных аксиом этого сделать нельзя, но если принять схему аксиом для трансфинитной индукции по ординалу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\varepsilon_0"
    ]
  },
  ", это удаётся сделать, как показал Генцен.\n",
  "",
  "\n",
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "key": "intuitionism",
      "level": 3
    },
    "children": [
      {
        "name": "counter",
        "props": {
          "last": "chapter"
        },
        "children": []
      },
      ".",
      {
        "name": "counter",
        "props": {
          "use": "section"
        },
        "children": []
      },
      ". ",
      "Интуиционистская пропозициональная логика"
    ]
  },
  "\n\n\nИсключим из числа аксиом закон исключённого третьего ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "{A\\lor\\lnot A} "
    ]
  },
  ".\nПолученное исчисление называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "интуиционистским исчислением высказываний"
    ]
  },
  ".\n",
  "",
  "\n",
  "",
  "\n(Обычное исчисление высказываний называют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "классическим"
    ]
  },
  ", ",
  "",
  "\n",
  "",
  "\nчтобы избежать путаницы при его сравнении с интуиционистским.\nВообще математические рассуждения, опирающиеся на аксиому исключённого третьего, называют «классическими», а избегающие её — «интуиционистскими».)\n\n\nКонечно, немедленно возникают естественные вопросы.\nПочему именно эта аксиома вызывает сомнения?\nВообще-то аксиом много, и можно было бы исключить любую и смотреть, что получится без неё — но ясно, что скорее всего получится что-то странное.\nКак понять, какие формулы останутся теоремами без закона исключённого третьего?\nРаньше у исчисления высказываний была «сверхзадача» — вывести все тавтологии и только их, а теперь?\n\n\nИнтуиционистская логика возникла как попытка (сделанная Гейтингом)\n",
  "",
  "\nформализовать (хотя бы частично) методы рассуждений, практикуемые в «интуиционистской математике».\nГолландский математик Брауэр ",
  "",
  "\nшироко известен как автор классической (во всех смыслах) теоремы Брауэра о неподвижной точке ",
  "",
  "\n(она утверждает, что любое непрерывное отображение многомерного шара ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "D^n"
    ]
  },
  " в себя имеет неподвижную точку).\nНо одновременно он создал целую школу в области оснований математики — математический интуиционизм.\nОтчего, спрашивал Брауэр, в теории множеств возникли парадоксы?\nМожно считать, что это оттого, что мы стали рассуждать о каких-то уж очень абстрактных объектах, которые существуют лишь в нашей (порой противоречивой) фантазии, так что следует проявлять осторожность и не подходить к опасной черте.\nНо Брауэр пошел дальше, говоря, что противоречия лишь симптом болезни, а надо устранить её причину.\nПричину он видел в том, что математические рассуждения и понятия утратили интуитивный смысл, и нужно вернуться к основам и пересмотреть смысл самих логических связок.\n\n\nЧто мы имеем в виду (или должны иметь в виду), говоря о том, что мы установили, что «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "»?\nЭто значит, по Брауэру, что либо мы установили ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ", либо установили ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ".\nКогда мы устанавливаем, что «",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "», это значит, что мы установили и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ", и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ". «Если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  "» означает, что мы располагаем каким-то общим рассуждением, которое позволит нам установить ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ", как только кто-то установит нам ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ".\nОтрицание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " означает, что мы располагаем рассуждением, которое приводит к противоречию предположение, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " установлено.\n(Как с точки зрения интуиционизма, так и с классической точки зрения, ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  " во всех смыслах эквивалентно ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to\\perp"
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\perp"
    ]
  },
  " — заведомо ложное утверждение.\nМожно было бы вообще не использовать отрицания, а иметь константу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\perp"
    ]
  },
  " — это не очень привычно, но технически удобно.)\n\n\nИнтуиционизм отвергает идею о том, что все высказывания делятся на истинные и ложные (пусть неизвестным нам образом).\nС этой точки зрения закон исключённого третьего совершенно безоснователен: ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\lor \\lnot A"
    ]
  },
  " означает, что для произвольного утверждения ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " мы можем установить либо ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ", либо его отрицание (то есть объяснить, почему ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " в принципе не может быть установлено) — а почему, собственно?\n\n\nОбычно, говоря об интуиционизме, приводят следующий пример рассуждения, неприемлемого с точки зрения интуиционизма.\nДокажем, что существуют иррациональные числа ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\alpha"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\beta"
    ]
  },
  ", для которых ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\alpha^\\beta"
    ]
  },
  " рационально.\nВ самом деле, рассмотрим два случая.\nЕсли ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\sqrt{2}^{\\sqrt{2} } "
    ]
  },
  " рационально, то можно положить ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\alpha=\\beta=\\sqrt{2} "
    ]
  },
  ".\nЕсли же ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\sqrt{2}^{\\sqrt{2} } "
    ]
  },
  " иррационально, то положим ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\alpha=\\sqrt{2}^{\\sqrt{2} } "
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\beta=\\sqrt{2} "
    ]
  },
  "; легко проверить, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\alpha^{\\beta}=2"
    ]
  },
  ".\nИнтуиционист скажет, что это рассуждение некорректно: доказать существование чего-то означает построить этот объект, а мы так и не построили чисел ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\alpha"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\beta"
    ]
  },
  ", поскольку не установили, какой из двух случаев имеет место. (Заметим в скобках, что специалисты по алгебраической теории чисел знают, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\sqrt{2}^{\\sqrt{2} } "
    ]
  },
  "\nиррационально и даже трансцендентно.\nКроме того, не нужно быть специалистом, чтобы заметить, что можно положить ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\alpha=\\sqrt{2} "
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\beta=2\\log_2 3"
    ]
  },
  ".) Этот пример можно критиковать и с другой точки зрения, говоря, что само понятие действительного числа не является интуитивно ясным и требует обоснования.\n\n\nВообще интуиция — дело тонкое: если долго рассуждать, скажем, о действительных числах, то начинает казаться, что они в каком-то смысле существуют независимо от наших рассуждений.\nИменно поэтому психологически оправдан вопрос о том, скажем, как обстоят дела с континуум-гипотезой «на самом деле»: существует ли несчётное множество действительных чисел, не равномощное всем действительным числам, или не существует?\n\n\nМы не будем говорить о философских предпосылках интуиционизма подробно.\nВкратце упрощённая история вопроса такова.\nБрауэр ",
  "",
  "\nнаметил планы переустройства математики на интуиционистских принципах и отстаивал их настолько горячо, что однажды Гильберт ",
  "",
  "\nв раздражении заметил: отменить закон исключённого третьего — это всё равно что отнять у астрономов телескоп или запретить боксёрам пользоваться кулаками.\nНо, продолжал он, никто не может изгнать математиков из рая, который создал Кантор.\n",
  "",
  "\n\n\nВ планы Брауэра ",
  "",
  " не входила формализация интуиционистской логики и математики, скорее наоборот.\nТем не менее анализ принципов интуиционизма пошёл именно по этому пути, когда Гейтинг ",
  "",
  "\nстал изучать пропозициональную логику без закона исключённого третьего.\nРазличные спорные интуиционистские принципы стали предметом изучения с точки зрения формальной логики; были построены интуиционистские варианты формальной арифметики, теории множеств, логики предикатов, а также генценовские варианты интуиционистских систем.\nБыли предложены различные интерпретации интуиционистской логики.\nКолмогоров ",
  "",
  "\nпредложил трактовать её как «логику задач», Клини ",
  "",
  "\nпредложил понятие «реализуемости», использующее теорию алгоритмов для толкования формул; были предложены топологические модели для интуиционистской логики и т.д.\nВ СССР знамя Брауэра подхватила школа Маркова, ",
  "",
  "\nнаписав на нём, впрочем,  слово «конструктивизм» вместо идеологически сомнительного «интуиционионизма» и более последовательно ограничиваясь конечными объектами.\nКрипке ",
  "",
  "\nв 1960-е годы предложил некоторую семантику (определение истинности), согласованную с интуиционистским исчислением высказываний и весьма естественную (даже странно, что её не придумали раньше); замечательным образом оказалось, что она в некотором смысле близка к методу форсинга, который примерно в это же время придумал Коэн, ",
  "",
  "\nчтобы доказать независимость аксиомы выбора и континуум-гипотезы в теории множеств.\n\n\nВозвращаясь к интуиционистскому исчислению высказываний, приведём несколько выводимых формул.\n\n\n",
  {
    "name": "list",
    "props": {},
    "children": [
      {
        "name": "item",
        "props": {},
        "children": [
          "Чтобы понять смысл формулы ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to B)\\to (\\lnot B\\to\\lnot A)"
            ]
          },
          ", вспомним, что отрицание ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot X"
            ]
          },
          " можно толковать как ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(X\\to\\perp)"
            ]
          },
          ", где ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\perp"
            ]
          },
          " — заведомо ложное утверждение.\nЭта формула говорит, что если из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " следует ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          ", а из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          " следует заведомо ложное утверждение, то из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " следует заведомо ложное утверждение (частный случай транзитивности отношения следования).\nВывод её не использует закона исключённого третьего.\nВ самом деле, по лемме о дедукции ",
          "",
          "\n(доказательство которой остаётся тем же и для интуиционистского исчисления высказываний) достаточно доказать, что из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to B)"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot B"
            ]
          },
          "\nвыводится ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot A"
            ]
          },
          ".\nДля этого, в свою очередь, достаточно доказать, что из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to B)"
            ]
          },
          ", ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot B"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " выводятся две противоречащие друг другу формулы (что очевидно: это формулы ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          "\nи ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot B"
            ]
          },
          ")."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Чтобы вывести формулу ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(A\\to\\lnot\\lnot A)"
            ]
          },
          ", надо показать, что из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          "\nвыводится ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot\\lnot A"
            ]
          },
          ", для чего достаточно из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot A"
            ]
          },
          "\nвывести две противоречащие друг другу формулы (что тривиально —\nгодятся сами формулы ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot A"
            ]
          },
          ")."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(\\lnot\\lnot\\lnot A\\to \\lnot A)"
            ]
          },
          " получается из двух предыдущих: положим ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          " равным ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot\\lnot A"
            ]
          },
          " в первой из них."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(\\lnot A\\to \\lnot\\lnot\\lnot A)"
            ]
          },
          ", с другой стороны, есть частный случай второй формулы, так что три отрицания равносильны одному."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Коммутативность и ассоциативность операций ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\land"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lor"
            ]
          },
          ", так же как и два свойства дистрибутивности, не опирались на закон исключённого третьего."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "По-прежнему ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "((A\\lor B)\\to C)"
            ]
          },
          " равносильно ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "((A\\to C)\\land (B\\to C))"
            ]
          },
          " (импликации в обе стороны, связывающие эти формулы, выводимы в интуиционистском исчислении высказываний)."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Взяв ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\perp"
            ]
          },
          " в качестве ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "C"
            ]
          },
          " в предыдущих формулах, мы видим, что один из законов Де Моргана, ",
          "",
          "\n",
          "",
          "\n",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "{\\lnot (A\\lor B)\\leftrightarrow \\lnot A \\land \\lnot B} "
            ]
          },
          ", не опирается на закон исключённого третьего (что легко проверить и непосредственно)."
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "Формулу ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot\\lnot (A\\lor \\lnot A)"
            ]
          },
          " сохранившийся закон Де Моргана позволяет переписать в виде ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\lnot (\\lnot A \\land \\lnot\\lnot A)"
            ]
          },
          ", и нужно лишь вывести из ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "(\\lnot A \\land \\lnot\\lnot A)"
            ]
          },
          " две противоположные формулы, что очевидно."
        ]
      },
      "\n"
    ]
  },
  "\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПровести подробно доказательство выводимости в интуиционистском исчислении высказываний всех перечисленных формул.\n"
    ]
  },
  "\n\nС другой стороны, многие законы классической логики перестают быть выводимыми без закона исключённого третьего.\nТаковы, например, формулы\n",
  {
    "name": "math",
    "props": {
      "block": true
    },
    "children": [
      "\n\\begin{align*}\n&\\lnot\\lnot p \\to p,\\\\\n& p \\lor \\lnot p,\\\\\n&\\lnot p \\lor \\lnot\\lnot p,\\\\\n&(\\lnot q\\to \\lnot p) \\to (p\\to q),\\\\\n&\\lnot (p\\land q) \\to (\\lnot p\\lor\\lnot q),\\\\\n&((p\\lor q)\\to p) \\lor ((p \\lor q)\\to q).\n\\end{align*}\n"
    ]
  },
  "\nМы пишем здесь переменные ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  ", а не произвольные формулы, поскольку результат подстановки некоторых формул вместо ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " может быть выводимой формулой.\nНапример, если вместо ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " в первую из перечисленных формул подставить формулу ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  ", то получится выводимая формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot\\lnot\\lnot A \\to \\lnot A"
    ]
  },
  ".\n\n\nДовольно ясно, что эти формулы не согласуются с интуиционистским подходом.\nНапример, в предпоследней формуле говорится, что если мы опровергли предположение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(p \\land q)"
    ]
  },
  ", то мы можем указать на одно из предположений ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " и предъявить его опровержение.\nВряд ли такой переход можно считать обоснованным с интуиционистской точки зрения.\nНо, разумеется, формальный вопрос о выводимости требует формального ответа.\n\n\nНачнём с закона исключённого третьего.\n\n\n",
  {
    "name": "area",
    "props": {
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          ". "
        ]
      },
      "\nФормула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\lor\\lnot p"
        ]
      },
      " не выводима в интуиционистской логике.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nВ классической логике каждая пропозициональная переменная может принимать два значения — истина (",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "И"
        ]
      },
      ") и ложь (Л).\nВ зависимости от значений переменных каждой формуле также приписывается значение ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "И"
        ]
      },
      "или ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Л"
        ]
      },
      ".\nРасширим множество истинностных значений, добавив новое значение ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Н"
        ]
      },
      " (если угодно, можно считать это сокращением слова «неизвестно»).\nМы отождествляли ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "И"
        ]
      },
      " с единицей, а ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Л"
        ]
      },
      " — с нулём, так что логично отождествить ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Н"
        ]
      },
      " с числом ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "1/2"
        ]
      },
      ".\n",
      "",
      "\n",
      "",
      "\n\n\nМы докажем, что интуиционистски выводимые формулы всегда принимают значение ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "И"
        ]
      },
      ", а формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\lor\\lnot p"
        ]
      },
      " не такова, и потому не выводима.\n\n\nЧтобы определить значения формул в трёхзначной логике, нужно задать таблицы истинности для всех пропозициональных связок.\nКонъюнкцию определим как минимум из двух значений (так что, например, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\mathbf{Л}\\land \\mathbf{Н} = \\mathbf{Л} "
        ]
      },
      ", а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\mathbf{И}\\land \\mathbf{Н} = \\mathbf{Н} "
        ]
      },
      "), а дизъюнкцию — как максимум.\nОтрицание действует так: ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\neg\\mathbf{И}=\\mathbf{Л} "
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\neg\\mathbf{Л}=\\mathbf{И} "
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\neg\\mathbf{Н}=\\mathbf{Л} "
        ]
      },
      ". (Последнее может показаться странным: почему бы не считать, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\mathbf{Н}=\\mathbf{Н} "
        ]
      },
      "?\nОказывается, так нельзя — например, потому, что тогда формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot (p\\land\\lnot p)"
        ]
      },
      ", которая выводима в интуиционистской логике, будет иметь значение ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\mathbf{Н} "
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p=\\mathbf{Н} "
        ]
      },
      ".)\n\n\nСложнее всего определение истинности для импликации.\nМы полагаем, что\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(\\mathbf{И}\\to x)=x \\quad\\text{и}\\quad (\\mathbf{Л}\\to x)=\\mathbf{И}\n"
        ]
      },
      "\nдля любого истинностного значения ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "x"
        ]
      },
      ", а также что\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(\\mathbf{Н}\\to\\mathbf{Л})=\\mathbf{Л}, \\quad (\\mathbf{Н}\\to\\mathbf{Н})=\\mathbf{И}\\text{ и }(\\mathbf{Н}\\to\\mathbf{И})=\\mathbf{И}.\n"
        ]
      },
      "\n\nНазовем формулу ",
      {
        "name": "em",
        "props": {},
        "children": [
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "3"
            ]
          },
          "-тавтологией"
        ]
      },
      ", ",
      "",
      "\nесли она принимает значение ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "И"
        ]
      },
      " при любых значениях переменных из множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\{\\mathbf{И}, \\mathbf{Л}, \\mathbf{Н}\\} "
        ]
      },
      ".\nТеперь надо проверить две вещи: (1) все аксиомы интуиционистского исчисления являются ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-тавтологиями; (2)\nесли посылка импликации и вся импликация являются ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-тавтологиями, то и заключение тоже является ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-тавтологией.\nВторое сразу ясно из определения импликации, а первое надо аккуратно проверять, составив таблицы для всех аксиом.\nМы не будем этого подробно делать, поскольку это чисто механическая проверка и поскольку чуть позже мы сможем вывести это из более общего утверждения.\n\n\nСледовательно, всякая интуиционистски выводимая формула является ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-тавтологией.\nТеперь заметим, что формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p\\lor\\lnot p"
        ]
      },
      "\nпринимает значение ",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "Н"
        ]
      },
      " при ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p=\\mathbf{Н} "
        ]
      },
      " и потому не является ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-тавтологией — значит, невыводима.\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПокажите, что всякая ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-тавтология является тавтологией в обычном смысле.\n"
    ]
  },
  "\n\n\nИспользованный нами приём годится не всегда.\nНапример, интуиционистски невыводимая формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot p \\lor\\lnot\\lnot p"
    ]
  },
  "\nявляется ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "3"
    ]
  },
  "-тавтологией, поскольку (согласно нашему определению) формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot p"
    ]
  },
  " может принимать только значения ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  "и ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  ".\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nКакие из перечисленных нами интуиционистски невыводимых формул являются ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "3"
        ]
      },
      "-тавтологиями?\n"
    ]
  },
  "\n\n\nБолее общий способ установить недоказуемость (невыводимость)\nразличных формул доставляют ",
  {
    "name": "em",
    "props": {},
    "children": [
      "шкалы Крипке"
    ]
  },
  "\n",
  "",
  "\n",
  "",
  "\n(или ",
  {
    "name": "em",
    "props": {},
    "children": [
      "модели Крипке"
    ]
  },
  ", ",
  "",
  "\nкак ещё говорят).\n\n\nЧтобы задать шкалу Крипке, нужно:\n",
  {
    "name": "list",
    "props": {},
    "children": [
      {
        "name": "item",
        "props": {},
        "children": [
          "указать частично упорядоченное множество ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "\\langle W,\\le\\rangle"
            ]
          },
          ", называемое множеством ",
          {
            "name": "em",
            "props": {},
            "children": [
              "миров"
            ]
          },
          ";\n",
          ""
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          "для каждого мира указать, какие из пропозициональных переменных считаются ",
          {
            "name": "em",
            "props": {},
            "children": [
              "истинными"
            ]
          },
          "\n",
          "",
          "\n",
          "",
          "\nв этом мире (остальные переменные считаются ",
          {
            "name": "em",
            "props": {},
            "children": [
              "ложными"
            ]
          },
          "\n",
          "",
          "\n",
          "",
          "\nв этом мире).\nЕсли переменная ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "x"
            ]
          },
          " истинна в мире ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w"
            ]
          },
          ", мы пишем ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash x"
            ]
          },
          "."
        ]
      },
      "\n"
    ]
  },
  "\nПри этом требуется, чтобы было выполнено следующее: если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "u\\le v"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "u\\Vdash x"
    ]
  },
  ", то ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "v\\Vdash x"
    ]
  },
  " (область истинности любой переменной наследственна вверх).\n\n\nКогда шкала задана, можно определить истинность любой формулы (в данном мире) индукцией по построению формулы.\nМы пишем ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w\\Vdash A"
    ]
  },
  ", если в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  " истинна формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  ".\nВот индуктивное определение:\n\n\n",
  {
    "name": "list",
    "props": {},
    "children": [
      {
        "name": "item",
        "props": {},
        "children": [
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash  A\\land B"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash A"
            ]
          },
          " и ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash B"
            ]
          },
          ";"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash  A\\lor B"
            ]
          },
          ", если ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash A"
            ]
          },
          " или ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash B"
            ]
          },
          ";"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash  A\\to B"
            ]
          },
          ", если в любом мире ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "u\\ge w"
            ]
          },
          ", в котором истинна формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          ", истинна также и формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "B"
            ]
          },
          ";"
        ]
      },
      "\n",
      {
        "name": "item",
        "props": {},
        "children": [
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "w\\Vdash\\neg  A"
            ]
          },
          ", если ни в каком мире ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "u\\ge w"
            ]
          },
          " формула ",
          {
            "name": "math",
            "props": {
              "block": false
            },
            "children": [
              "A"
            ]
          },
          " не является истинной."
        ]
      },
      "\n"
    ]
  },
  "\n\n\nФормула, не являющаяся истинной (в данном мире), называется ложной (в нём).\n\n\nОпределение истинности для отрицания, как мы видим, согласовано с пониманием ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  " как ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\to{\\perp} "
    ]
  },
  ", где ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\perp"
    ]
  },
  " — тождественно ложная (во всех мирах) формула.\n\n\nИменно определение импликации (и отрицания) использует порядок на множестве миров.\nЕсли формула содержит лишь конъюнкции и дизъюнкции, то её истинность по существу определяется отдельно в каждом мире.\n\n\nИндукцией по построению формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " легко проверить, что если она истинна в каком-то мире, то истинна и во всех б'ольших мирах.\nВ самом деле, пересечение и объединение двух наследственных вверх множеств также обладает этим свойством, так что для случая конъюнкции и дизъюнкции можно сослаться на предположение индукции.\nА для импликации даже и этого не нужно, достаточно посмотреть на определение.\n\n\nФилософский смысл шкал Крипке иногда объясняют так.\nБудем считать, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "W"
    ]
  },
  " есть множество возможных состояний цивилизации (миров);\nнеравенство ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w\\le u"
    ]
  },
  " означает, что мир ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "u"
    ]
  },
  " может получиться из мира ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  " в результате развития цивилизации.\nУтверждение ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w\\Vdash A"
    ]
  },
  " означает, что в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  " установлено, что высказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " истинно.\n(При этом оно останется истинным и при дальнейшем развитии цивилизации.)\nИстинность ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot A"
    ]
  },
  " в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  " означает, что ни при каком развитии цивилизации из состояния ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  " высказывание ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " не станет истинным.\n\n\nОпределение истинности отрицания в шкалах Крипке предвосхитил Пушкин, ",
  "",
  "\nкогда писал «нет правды на земле.\nНо правды нет и выше",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\ldots"
    ]
  },
  "» (Моцарт и Сальери).\n",
  "",
  "\n",
  "",
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nВо что превращается определение истинности в шкале Крипке, если в ней только один мир? если в ней никакие два мира не сравнимы?\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "корректность интуиционистского исчисления высказываний относительно шкал Крипке",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "_link"
            },
            "children": []
          },
          " (",
          "корректность интуиционистского исчисления высказываний относительно шкал Крипке",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nФормула, выводимая в интуиционистском исчислении высказываний, истинна во всех мирах всех шкал Крипке.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНадо проверить, что все аксиомы истинны во всех мирах, а также что правило modus ponens ",
      "",
      "\n",
      "",
      "\nсохраняет это свойство.\nВторое очевидно: если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to B"
        ]
      },
      " истинна во всех мирах и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      "\nистинна во всех мирах, то по определению истинности импликации ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " будет истинна во всех мирах.\n\n\nОсталось проверить истинность всех аксиом.\nЧтобы установить, что импликация ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi\\to\\psi"
        ]
      },
      " истинна во всех мирах, надо проверить, что в тех мирах, где истинна формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      ", истинна и формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      ".\nДля первой аксиомы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to (B\\to A)"
        ]
      },
      ":\nесли формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " истинна в некотором мире, то в силу монотонности она истинна и выше, так что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B\\to A"
        ]
      },
      " также истинна.\n\n\nПерейдём ко второй аксиоме ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\to(B\\to C))\\to((A\\to B)\\to (A\\to C))"
        ]
      },
      ".\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u\\Vdash A\\to(B\\to C)"
        ]
      },
      ".\nМы должны доказать, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "u\\Vdash (A\\to B)\\to(A\\to C)"
        ]
      },
      ".\nЭто означает, что если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "v\\ge u"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "v\\Vdash A\\to B"
        ]
      },
      ", то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "v\\Vdash A\\to C"
        ]
      },
      ".\nПоследнее, в свою очередь, значит, что если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\ge v"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\Vdash A"
        ]
      },
      ", то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\Vdash C"
        ]
      },
      ".\nНо в силу монотонности мы знаем, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{w\\Vdash A\\to(B\\to C)} "
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\Vdash A\\to B"
        ]
      },
      ".\nПоэтому из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\Vdash A"
        ]
      },
      " следует ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\Vdash B"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\Vdash (B\\to C)"
        ]
      },
      ", и, наконец, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "w\\Vdash C"
        ]
      },
      ", что и требовалось.\n\n\nОстальные аксиомы проверяются ещё проще.\n",
      " ᐅ"
    ]
  },
  "\n\n\nТаким образом, чтобы доказать, что некоторая формула не выводима в интуиционистском исчислении высказываний, достаточно предъявить шкалу Крипке, в одном из миров которой она ложна.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПокажите, что в этом случае есть шкала, в которой среди миров есть наименьший и в нём формула ложна.\n"
    ]
  },
  "\n\n\nДля формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\lor \\lnot p"
    ]
  },
  " такая шкала строится легко.\nВозьмём два мира, первый меньше второго.\nПусть ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " истинна только во втором мире.\nТогда ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot p"
    ]
  },
  " не будет истинна нигде, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p\\lor \\lnot p"
    ]
  },
  " будет истинна только во втором мире.\n\n\nНа самом деле это доказательство в сущности совпадает с приведённым выше (с трёхзначной логикой).\nВ самом деле, в этой шкале для формулы есть три возможности: она истинна в обоих мирах, она истинна только во втором мире, или она не истинна ни в одном из миров.\nЭти три возможности соответствуют трём значениям ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "И"
    ]
  },
  ", ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Н"
    ]
  },
  " и ",
  {
    "name": "format.b",
    "props": {},
    "children": [
      "Л"
    ]
  },
  " в рассмотренной нами трёхзначной интерпретации.\nЛегко проверить, что таблицы операций как раз соответствуют определению истинности в модели Крипке.\n\n\nТеперь мы можем установить, что все перечисленные выше формулы невыводимы в интуиционистском исчислении высказываний.\nДля формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot\\lnot p \\to p"
    ]
  },
  " годится та же шкала (",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " истинно только в большем мире).\nОна же годится для формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "(\\lnot q\\to\\lnot p)\\to (p\\to q)"
    ]
  },
  ", если ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " истинно в обоих мирах, а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " — только в большем.\nДля трёх оставшихся формул можно рассмотреть шкалы с тремя мирами: начальным миром ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "u"
    ]
  },
  ", из которого можно попасть в ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "v\\ge u"
    ]
  },
  " и в ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w\\ge u"
    ]
  },
  "; миры ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "v"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  " не сравнимы.\nЕсли формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " истинна только в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "v"
    ]
  },
  ", то формула ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot p"
    ]
  },
  " истинна только в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  ", a ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot\\lnot p"
    ]
  },
  " истинна только в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "v"
    ]
  },
  ", так что в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "u"
    ]
  },
  " обе формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot p"
    ]
  },
  " и ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot\\lnot p"
    ]
  },
  " ложны и дизъюнкция ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot p \\lor \\lnot\\lnot p"
    ]
  },
  " ложна.\nЧтобы построить контрмодель для формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "\\lnot(p\\land q)\\to \\lnot p\\lor \\lnot q"
    ]
  },
  ", будем считать, что ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "p"
    ]
  },
  " истинна только в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "v"
    ]
  },
  ", а ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "q"
    ]
  },
  " истинна только в мире ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "w"
    ]
  },
  ".\nТа же шкала годится и для формулы ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "((p\\lor q)\\to p)\\lor((p\\lor q)\\to q)"
    ]
  },
  ".\n\n\nОказывается, что этот приём универсален, как показывает следующая теорема.\n\n\n",
  {
    "name": "area",
    "props": {
      "name": "полноты интуиционистского исчисления высказываний относительно шкал Крипке",
      "key": "kripke-completeness",
      "kind": "theorem"
    },
    "children": [
      {
        "name": "format.b",
        "props": {
          "inline": true,
          "key": "kripke-completeness_name"
        },
        "children": [
          "Теорема ",
          {
            "name": "counter",
            "props": {
              "use": "theorem",
              "key": "kripke-completeness_link"
            },
            "children": []
          },
          " (",
          "полноты интуиционистского исчисления высказываний относительно шкал Крипке",
          ")",
          ". "
        ]
      },
      "\n",
      "",
      "\nДля любой невыводимой в интуиционистском исчислении формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " можно подобрать шкалу Крипке, в которой ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      "\nложна в некотором мире.\n"
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {},
    "children": [
      "ᐊ ",
      "\nНапомним схему доказательства полноты классического исчисления высказываний, приведённого в разделе ",
      {
        "name": "label",
        "props": {
          "ref": "completeness-second-proof"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "completeness-second-proof_link"
            },
            "children": []
          }
        ]
      },
      ".\nПусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " невыводима.\nМы хотим найти значения переменных, при которых формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " ложна, то есть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      " истинна.\nСамо по себе требование истинности ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      " не определяет значения переменных однозначно.\nЧтобы избавиться от произвола, мы расширяем непротиворечивое множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\{\\lnot\\varphi\\} "
        ]
      },
      " до полного множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      " и объявляем истинными те переменные, которые входят в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\Gamma"
        ]
      },
      ".\n\n\nДля интуиционистского случая в этой схеме требуются некоторые изменения.\nРаньше ложность формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " была равносильна истинности формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      ".\nВ шкалах Крипке это уже не так, и мы будем отдельно говорить об истинных и ложных (не истинных) формулах.\n\n\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " — конечные множества пропозициональных формул.\nБудем говорить, что пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "совместна"
        ]
      },
      ", ",
      "",
      "\n",
      "",
      "\nесли существует шкала Крипке и её мир, в котором все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      "\nистинны, а все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " ложны.\nБудем говорить, что пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      " ",
      {
        "name": "em",
        "props": {},
        "children": [
          "противоречива"
        ]
      },
      ", ",
      "",
      "\n",
      "",
      "\nесли в интуиционистском исчислении высказываний выводима формула\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n(A_1 \\land A_2 \\land\\ldots\\land A_n) \\to (B_1 \\lor B_2 \\lor\\ldots\\lor B_m),\n"
        ]
      },
      "\nгде ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A_1,\\dots,A_n"
        ]
      },
      " — формулы множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      ", а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B_1,\\dots,B_m"
        ]
      },
      " — формулы множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ".\n(Без ограничения общности можно считать, что перечислены все формулы множеств ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ", поскольку пропущенные формулы можно добавить, не нарушив выводимость.)\n\n\nПример: если одна и та же формула входит в обе части пары, то такая пара противоречива.\n\n\nЛегко проверить, что противоречивая пара не может быть совместна.\nВ самом деле, если в некотором мире все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " истинны, а все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " ложны, то посылка импликации в этом мире истинна, а заключение ложно.\nПоэтому импликация ложна, что противоречит её выводимости (теорема о корректности).\n\n\nМы докажем, что верно и обратное: всякая непротиворечивая пара совместна.\nВ частности, когда ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " состоит из единственной формулы, получается утверждение теоремы о полноте. (Мы предполагаем, как это обычно делается, что конъюнкция пустого множества формул есть тождественно истинная формула, а дизъюнкция — тождественно ложная.\nПоэтому противоречивость пары ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\varnothing,\\{\\varphi\\})"
        ]
      },
      " означает выводимость формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      ".\nЗаметим кстати, что противоречивость пары ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\{\\varphi\\},\\varnothing)"
        ]
      },
      " означает выводимость формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      ".)\n\n\nИтак, пусть имеется непротиворечивая пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      ".\nКак доказать её совместность? Как и в классическом случае, мы устраним произвол, расширив ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ".\nОсновным средством здесь является такая лемма.\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма 1"
        ]
      },
      ".\nПусть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      " — непротиворечивая пара, а ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\tau"
        ]
      },
      " — произвольная формула.\nТогда хотя бы одна из пар ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\cup\\{\\tau\\},B)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B\\cup\\{\\tau\\})"
        ]
      },
      " непротиворечива.\n\n\nДоказательство леммы 1.\nПусть обе пары с добавленным ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\tau"
        ]
      },
      "\nпротиворечивы.\nНадо доказать, что противоречива исходная пара.\nДругими словами, надо показать, что если в интуиционистском исчислении высказываний выводимы формулы\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\n\\begin{align*}\n(A \\land \\tau)&\\to B,\\\\\nA            &\\to(B \\lor \\tau),\n\\end{align*}\n"
        ]
      },
      "\nто выводима и формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to B"
        ]
      },
      " (для простоты мы отождествляем множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " с конъюнкцией и дизъюнкцией их элементов и считаем ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " формулами).\n\n\nВ самом деле, по лемме о дедукции достаточно доказать, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A \\vdash B"
        ]
      },
      ".\nДля этого достаточно установить, что\n",
      {
        "name": "math",
        "props": {
          "block": true
        },
        "children": [
          "\nA\\vdash (B\\lor \\tau) \\to B,\n"
        ]
      },
      "\nпоскольку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(B\\lor\\tau)"
        ]
      },
      " в предположении ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " у нас уже есть.\nДля этого, в свою очередь, достаточно установить, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\vdash (B\\to B)"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\vdash (\\tau\\to B)"
        ]
      },
      ".\nПервое очевидно (и посылка ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " не нужна), второе равносильно выводимости формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land\\tau)\\to B"
        ]
      },
      ", которая нам дана по условию леммы.\nЛемма 1 доказана.\n\n\nПроведённое рассуждение, как говорят, устанавливает ",
      {
        "name": "em",
        "props": {},
        "children": [
          "допустимость"
        ]
      },
      " (в интуиционистской логике) ",
      {
        "name": "em",
        "props": {},
        "children": [
          "правила сечения"
        ]
      },
      ", ",
      "",
      "\n",
      "",
      "\nпозволяющего «иссечь» формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\tau"
        ]
      },
      " из формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A\\land\\tau)\\to B"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to(B\\lor\\tau)"
        ]
      },
      " и получить формулу ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\to B"
        ]
      },
      ".\n\n\nВозвращаясь к доказательству теоремы, рассмотрим произвольную непротиворечивую пару ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      ".\nРассматривая по очереди различные формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\tau"
        ]
      },
      ", мы будем добавлять их к левой или правой части.\nЧтобы этот процесс («пополнение») был конечным, мы ограничимся формулами из некоторого множества.\n\n\nФиксируем некоторое конечное множество формул ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ", которое содержит все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A,B"
        ]
      },
      " и замкнуто относительно перехода к подформулам (если формула входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ", то все её подформулы входят в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ").\nНапример, можно включить в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " все подформулы всех формул из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " и из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      ".\n\n\nПару ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(X,Y)"
        ]
      },
      ", у которой ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "X,Y\\subset F"
        ]
      },
      ", будем называть ",
      {
        "name": "em",
        "props": {},
        "children": [
          "полной"
        ]
      },
      ", ",
      "",
      "\n",
      "",
      "\nесли она непротиворечива и любая формула из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " входит либо в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "X"
        ]
      },
      ", либо в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Y"
        ]
      },
      " (то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "X\\cup Y=F"
        ]
      },
      ").\nЗаметим, что из непротиворечивости следует, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "X\\cap Y=\\varnothing"
        ]
      },
      ", так что полная пара задаёт разбиение ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " на две части.\n(Более точно полные пары следовало бы называть «полными относительно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      "», но у нас множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " фиксировано.)\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма 2"
        ]
      },
      ".\nИсходная пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      " может быть расширена до полной: существует полная пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(X,Y)"
        ]
      },
      ", для которой ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A\\subset X"
        ]
      },
      ", ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B\\subset Y"
        ]
      },
      ".\n\n\nДоказательство очевидно: применяем по очереди лемму 1 ко всем формулам из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ".\n\n\nТочно так же любую непротиворечивую пару, составленную из формул множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ", можно расширить до полной. (Это замечание нам впоследствии понадобится.)\n\n\nДля завершения доказательства теоремы ",
      {
        "name": "label",
        "props": {
          "ref": "kripke-completeness"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "kripke-completeness_link"
            },
            "children": []
          }
        ]
      },
      "\nнам осталось показать, что всякая полная пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      " совместна (существует шкала и мир, в котором формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "A"
        ]
      },
      " истинны, а формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "B"
        ]
      },
      " ложны).\nВ отличие от классического случая построение будет использовать не только пару ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(A,B)"
        ]
      },
      ", но и все полные пары.\n\n\nШкала Крипке строится так.\nМирами будут полные пары ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      " (то есть всевозможные непротиворечивые разбиения множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " на левую и правую части).\nИстинность переменных определяется естественным образом: всякая переменная ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      ", входящая в одну из формул множества ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ", сама принадлежит множеству ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      "\n(замкнутость относительно подформул); если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " входит в левую часть полной пары ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ", то ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "p"
        ]
      },
      " истинна в мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ", если в правую — то ложна. (Впоследствии это свойство мы распространим на все формулы: любая формула из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      " окажется истинной в мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ", а любая формула из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      " — ложной.)\n\n\nОсталось определить порядок на множестве пар.\nСчитаем, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R_1,S_1)\\le(R_2,S_2)"
        ]
      },
      ", если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R_1\\subset R_2"
        ]
      },
      ". (Такое определение не удивительно, если вспомнить, что истинность формул наследуется вверх.)\n\n\n",
      {
        "name": "format.pre",
        "props": {},
        "children": [
          "Лемма 3"
        ]
      },
      ".\nВ построенной шкале в мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      " истинны все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      " и ложны все формулы из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ".\n\n\nДоказательство леммы 3 проводится индукцией по построению формул.\nДля переменных она верна по определению истинности.\nПусть некоторая формула из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " не является переменной.\nТогда она есть конъюнкция, дизъюнкция, импликация или отрицание и для её частей утверждение леммы верно по предположению индукции.\nРассмотрим все случаи по очереди, начав с конъюнкции и дизъюнкции (истинность которых не зависит от других миров).\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land_R"
        ]
      },
      ") Пусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\land\\psi} "
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      ".\nТогда формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " не могут входить в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ", иначе пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      " была бы противоречивой (из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\land\\psi} "
        ]
      },
      "\nвыводится ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      ").\nЗначит, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " входят в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      " (полнота), поэтому они истинны (предположение индукции), и потому ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\land\\psi} "
        ]
      },
      " истинна (определение истинности).\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\land_S"
        ]
      },
      ") Пусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\land\\psi} "
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ".\nМогут ли обе формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " входить в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      "? Нет, так как в этом случае пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      " была бы противоречивой.\nЗначит, хотя бы одна из формул входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ", тогда по предположению индукции она ложна, и потому формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\land\\psi} "
        ]
      },
      " ложна в мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ".\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor_R"
        ]
      },
      ") Если формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\lor\\psi} "
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      ", то формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " не могут одновременно входить в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ", и потому хотя бы одна из них истинна, так что и вся формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\lor\\psi} "
        ]
      },
      " истинна.\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lor_S"
        ]
      },
      ") Если формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\lor\\psi} "
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ", то формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " не могут входить в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      ", поэтому обе они ложны и формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\lor\\psi} "
        ]
      },
      " ложна.\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\to_R"
        ]
      },
      ") Пусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\to\\psi} "
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      ".\nПроверим, что она истинна в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ".\nЭто значит, что в любом мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      ", который выше нашего (то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'\\supset R"
        ]
      },
      ") и в котором истинна формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      ", должна быть истинна и формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      ".\nВ самом деле, если ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " истинна в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      ", то она входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'"
        ]
      },
      " (предположение индукции).\nС другой стороны, и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\to\\psi} "
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'"
        ]
      },
      ", поскольку ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'\\supset R"
        ]
      },
      ".\nТеперь ясно, что формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " не может входить в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S'"
        ]
      },
      ", так как в этом случае пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      " была бы противоречивой (из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi\\to\\psi"
        ]
      },
      " выводится ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      ").\nЗначит, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'"
        ]
      },
      " и потому истинна в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      " по предположению индукции.\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\to_S"
        ]
      },
      ") Это наиболее интересный случай, где нам снова потребуется пополнение.\nПусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\to\\psi} "
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ".\nМы должны доказать, что она ложна в мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ".\nСогласно определению, это означает, что найдётся мир ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      ", для которого ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'\\supset R"
        ]
      },
      " и в котором формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      "\nистинна, а формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi"
        ]
      },
      " ложна (то есть ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi\\in R'"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\psi\\in S'"
        ]
      },
      ", согласно предположению индукции).\nКак найти такой мир? Рассмотрим пару ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "({R\\cup\\{\\varphi\\} },\\{\\psi\\})"
        ]
      },
      ".\nЭта пара непротиворечива.\nВ самом деле, если бы формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{R\\land\\varphi}\\to\\psi"
        ]
      },
      " была бы выводима, то и формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R\\to(\\varphi\\to\\psi)"
        ]
      },
      " была бы выводима (лемма о дедукции), и потому пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      " была бы противоречива.\nТеперь можно расширить непротиворечивую пару ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "({R\\cup\\{\\varphi\\} },\\{\\psi\\})"
        ]
      },
      " до полной пары ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      ", которая и будет искомым миром.\n\n\nОтрицание рассматривается аналогично импликации (как мы говорили, можно вместо отрицания ввести тождественную ложь ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\perp"
        ]
      },
      " и вообще его не рассматривать).\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot_R"
        ]
      },
      ") Пусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot \\varphi"
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      ".\nНадо доказать, что формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " ложна в любом мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      "\nвыше мира ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ".\nФормула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " не может входить в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'"
        ]
      },
      ", так как в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R'"
        ]
      },
      " входит формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      " (напомним, что ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R\\subset R'"
        ]
      },
      "), а из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{\\varphi\\land\\lnot\\varphi} "
        ]
      },
      " выводится любая формула.\nЗначит, ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S'"
        ]
      },
      " и по индуктивному предположению формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " ложна в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      ".\n\n\n(",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot_S)"
        ]
      },
      " Пусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      " входит в ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "S"
        ]
      },
      ".\nТогда пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "({R\\cup \\{\\varphi\\} },\\varnothing)"
        ]
      },
      " непротиворечива (если из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " выводится противоречие, то из ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "R"
        ]
      },
      " выводится ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      ").\nРасширив её до полной, получаем высший мир ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R',S')"
        ]
      },
      ", в котором формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " истинна (по индуктивному предположению).\nСледовательно, формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\varphi"
        ]
      },
      " ложна в мире ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(R,S)"
        ]
      },
      ".\n\n\nЛемма 3 доказана.\nОна завершает доказательство теоремы ",
      {
        "name": "label",
        "props": {
          "ref": "kripke-completeness"
        },
        "children": [
          {
            "name": "use",
            "props": {
              "ref": "kripke-completeness_link"
            },
            "children": []
          }
        ]
      },
      ".\nНапомним ещё раз его схему.\nПусть формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " не выводима в интуиционистском исчислении высказываний.\nТогда пара ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "(\\varnothing,\\{\\varphi\\})"
        ]
      },
      " непротиворечива.\nФиксируем множество ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      " всех подформул формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      ".\nРасширим нашу непротиворечивую пару до полной (относительно ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "F"
        ]
      },
      ").\nЭта полная пара будет одним из миров шкалы Крипке (в которой мирами являются полные пары).\nИменно в этом мире и будет ложной формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      ".\n",
      " ᐅ"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПокажите, что если формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      " ложны в некоторых мирах некоторых шкал Крипке, то можно построить шкалу Крипке и мир в ней, для которого формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "{P\\lor Q} "
        ]
      },
      " будет ложной.\n\n(Указание: соединим шкалы, в которых ложны формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      ", в одну, добавив новый мир, который меньше миров, где ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "P"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "Q"
        ]
      },
      "\nложны.)\n"
    ]
  },
  "\n\n\nИз этой задачи и из теоремы о полноте вытекает такое следствие:\nесли дизъюнкция двух формул выводима в интуиционистском исчислении высказываний, то хотя бы одна из формул тоже выводима.\nЭто свойство выполнено для многих интуиционистских исчислений и соответствует начальной идее: доказать ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A\\lor B"
    ]
  },
  "\nозначает доказать одну из формул ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "A"
    ]
  },
  " или ",
  {
    "name": "math",
    "props": {
      "block": false
    },
    "children": [
      "B"
    ]
  },
  ".\nПодобные свойства можно доказывать и синтаксически, используя генценовские варианты интуиционистских исчислений.\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "а"
        ]
      },
      ")\nПокажите, что формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\lnot(\\varphi\\lor\\lnot\\varphi)"
        ]
      },
      "\nвыводима в интуиционистском исчислении высказываний.\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "б"
        ]
      },
      ")\nПокажите, что если формулы ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\lnot\\varphi"
        ]
      },
      " и ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\lnot(\\varphi\\to\\psi)"
        ]
      },
      "\nвыводимы в интуиционистском исчислении высказываний, то и формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\lnot\\psi"
        ]
      },
      " выводима в интуиционистском исчислении высказываний.\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "в"
        ]
      },
      ")\nДокажите, что если формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\varphi"
        ]
      },
      " выводима в классическом исчислении высказываний, то формула ",
      {
        "name": "math",
        "props": {
          "block": false
        },
        "children": [
          "\\lnot\\lnot\\varphi"
        ]
      },
      " выводима в интуиционистском исчислении высказываний (теорема Гливенко)\n",
      "",
      "\n",
      "",
      "\n(",
      {
        "name": "format.b",
        "props": {},
        "children": [
          "г"
        ]
      },
      ")\nПокажите, что для формул, содержащих лишь конъюнкцию и отрицание, разницы между классическим и интуиционистским исчислениями нет:\nиз классической выводимости следует интуиционистская (теорема Гёделя).\n",
      "",
      "\n",
      "",
      "\n"
    ]
  },
  "\n\n\n",
  {
    "name": "format.small",
    "props": {},
    "children": [
      {
        "name": "format.b",
        "props": {},
        "children": [
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "problem"
                },
                "children": []
              }
            ]
          },
          ". "
        ]
      },
      "\nПокажите, что интуиционистское исчисление высказываний разрешимо:\nсуществует алгоритм, который по произвольной формуле определяет, выводима ли она в интуиционистском исчислении высказываний.\n(Указание: оцените мощность контрмодели Крипке; можно обойтись и без этого, заметив, что и множество выводимых формул, и множество формул, имеющих конечные контрмодели, перечислимы.)\n"
    ]
  },
  "\n",
  "\n",
  "\n\n\n",
  {
    "name": "header",
    "props": {
      "level": 2
    },
    "children": [
      "Литература"
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "aho-hopcroft-ullman"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "aho-hopcroft-ullman_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "aho-hopcroft-ullman_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Ахо, Дж.Ульман, Дж.Хопкрофт. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Построение и анализ\nвычислительных алгоритмов"
            ]
          },
          ", пер. с англ. А.О.Слисенко\nпод редакцией Ю.В.Матиясевича. М.:Мир, 1979.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "boolos-jeffrey"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "boolos-jeffrey_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "boolos-jeffrey_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Дж.Булос, Р.Джеффри. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Вычислимость и логика"
            ]
          },
          ",\nпер. с англ. В.А.Душского и Е.Ю.Ногиной под\nредакцией С.Н.Артёмова.\nМ.:Мир, 1994. 396 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "bourbaki"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "bourbaki_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "bourbaki_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Н.Бурбаки.  ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Начала математики.   Первая часть.  Основные\nструктуры анализа. Книга первая. Теория множеств"
            ]
          },
          ",\nпер. с французского Г.Н.Поварова и\nЮ.А.Шихановича под редакцией В.А.Успенского.\nМ.:Мир, 1965.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "vanderwaerden"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "vanderwaerden_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "vanderwaerden_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "\nБ.Л. ван дер Варден. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Алгебра"
            ]
          },
          ", перевод с немецкого\nА.А.Бельского. Под редакцией Ю.И.Мерзлякова. М.:Наука,\nглавная редакция физико-математической литературы, 1976.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "computable-functions"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "computable-functions_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "computable-functions_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Н.К.Верещагин, А.Шень. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Лекции по математической логике и\nтеории алгоритмов. Часть 3. Вычислимые функции"
            ]
          },
          ". 3-е изд.\nМ.:МЦНМО, 2008.\n176 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "naive-set-theory"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "naive-set-theory_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "naive-set-theory_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Н.К.Верещагин, А.Шень. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Лекции по математической логике и\nтеории алгоритмов. Часть 1. Начала теории множеств"
            ]
          },
          ". 3-изд.\nМ.:МЦНМО, 2008. 128 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "heyting"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "heyting_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "heyting_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Гейтинг. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Интуиционизм. Введение"
            ]
          },
          ", пер. с\nангл. В.А.Янкова под редакцией и с комментариями\nА.А.Маркова. М.:Мир, 1965. 200 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "hilbert-bernays"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "hilbert-bernays_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "hilbert-bernays_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Д.Гильберт, П.Бернайс. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Основания математики.\nЛогические исчисления и формализация арифметики"
            ]
          },
          ", перевод с\nнемецкого Н.М.Нагорного под редакцией С.И.Адяна.\nМ.:Наука, главная редакция физико-математической литературы,\n1979. 560 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "gindikin"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "gindikin_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "gindikin_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.Г.Гиндикин. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Алгебра логики в задачах"
            ]
          },
          ". М.:Наука,\nглавная редакция физико-математической литературы, 1972.\n288 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "gladky-textbook"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "gladky-textbook_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "gladky-textbook_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.В.Гладкий. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ". М.:Российский\nгосударственный гуманитарный университет, 1998. 479 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "davis-nonstandard"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "davis-nonstandard_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "davis-nonstandard_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "М.Дэвис. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Прикладной нестандартный анализ"
            ]
          },
          ", перевод с\nангл. С.Ф.Сопрунова под редакцией и с предисловием\nВ.А.Успенского. М.:Мир, 1980. 236 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n",
  {
    "name": "area",
    "props": {
      "key": "ershov-palyutin"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "ershov-palyutin_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "ershov-palyutin_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Ю.Л.Ершов, Е.А.Палютин. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ". 2-е изд.\nМ.:Наука, главная редакция физико-математической литературы,\n1987. 336 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "keisler-chang"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "keisler-chang_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "keisler-chang_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Г.Кейслер, Ч.Ч.Чэн. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Теория моделей"
            ]
          },
          ",\nперевод с англ. С.С.Гончарова, С.Д.Денисова,\nВ.А.Душского и Д.И.Свириденко. Под редакцией\nЮ.Л.Ершова и А.Д.Тайманова. М.:Мир, 1977. 614 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kurosh"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kurosh_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kurosh_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Г.Курош. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Лекции по общей алгебре"
            ]
          },
          ", 2-е изд.\nМ.:Наука, главная редакция физико-математической литературы,\n1973. 399 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kleene-metamathematics"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kleene-metamathematics_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kleene-metamathematics_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.К.Клини. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в метаматематику"
            ]
          },
          ", перевод с английского\nА.С.Есенина-Вольпина под редакцией В.А.Успенского. М.:Издательство\nиностранной литературы, 1957. 526 с.\n\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kleene-logic"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kleene-logic_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kleene-logic_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.К.Клини. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ", перевод с английского\nЮ.А.Гастева под редакцией Г.Е.Минца. М.:Мир, 1973. 480 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "kleene-vesley"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "kleene-vesley_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "kleene-vesley_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.Клини, Р.Весли. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Основания интуиционистской\nматематики с точки зрения теории рекурсивных функций"
            ]
          },
          ", перевод с\nанглийского Ф.А.Кабакова и Б.А.Кушнера.\nМ.:Наука, главная редакция физико-математической литературы,\n1978. 272 с. (Серия: Математическая логика и основания математики.)\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "cormen-leiserson-rivest"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "cormen-leiserson-rivest_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "cormen-leiserson-rivest_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Т.Кормен, Ч.Лейзерсон, Р.Ривест. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Алгоритмы:\nпостроение и анализ"
            ]
          },
          ", пер. с англ. К.Белова,\nЮ.Боравлёва, Д.Ботина, В.Горелика, Д.Дерягина,\nЮ.Калнишкана, А.Катановой, С.Львовского,\nА.Ромащенко, К.Сонина, К.Трушкина, М.Ушакова,\nА.Шеня, В.Шувалова, М.Юдашкина под ред. А.Шеня,\nВ.Ященко. М.:МЦНМО, 1999. 960 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lavrov-maksimova"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "lavrov-maksimova_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "lavrov-maksimova_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "И.А.Лавров, Л.Л.Максимова. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Задачи по теории\nмножеств, математической логике и теории алгоритмов"
            ]
          },
          ", издание\nвторое. М.:Наука, 1984. 224 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "lyndon"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "lyndon_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "lyndon_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Р.Линдон. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Заметки по логике"
            ]
          },
          ", пер. с английского\nЮ.А.Гастева под редакцией И.М.Яглома. М.:Мир, 1968.\n128 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "manin"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "manin_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "manin_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Ю.И.Манин. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Доказуемое и недоказуемое"
            ]
          },
          ".\nМ.:Советское радио, 1979. 168 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "robinson"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "robinson_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "robinson_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Робинсон. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в теорию моделей и метаматематику\nалгебры"
            ]
          },
          ", пер. с англ. А.Б.Волынского под редакцией\nА.Д.Тайманова. М.:Наука, главная редакция физикод\nматематической литературы, 1967. 376 с. (Серия: Математическая\nлогика и основания математики.)\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "smullyan-informal"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "smullyan-informal_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "smullyan-informal_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Рэймонд М.Смаллиан. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Как же называется эта книга?"
            ]
          },
          ",\nпер. с англ. Ю.А.Данилова. М.:Мир, 1981. 240 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "smullyan-formal"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "smullyan-formal_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "smullyan-formal_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Р.Смальян.\n",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Теория формальных систем"
            ]
          },
          ", перевод с английского\nН.К.Косовского под редакцией Н.А.Шанина. М.:Наука,\nглавная редакция физико-математической литературы, 1981.\n207 с. (Серия: Математическая логика и основания математики.)\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "handbook-sets"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "handbook-sets_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "handbook-sets_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Справочная книга по математической логике в четырёх частях\nпод ред. Дж.Барвайса. Часть II. Теория множеств"
            ]
          },
          ",\nпер. с англ. В.Г.Кановея под редакцией\nВ.Н.Гришина. М.:Наука, 1982. 376 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "handbook-recursion"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "handbook-recursion_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "handbook-recursion_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Справочная книга по математической логике в четырёх частях под\nред. Дж.Барвайса. Часть III. Теория рекурсии"
            ]
          },
          ",\nпер. с английского  С.Г.Дворникова, И.А.Лаврова.\nПод ред. Ю.Л.Ершова.\nМ.:Наука, 1982. 360 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "uspensky-nonstandard"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "uspensky-nonstandard_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "uspensky-nonstandard_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "В.А.Успенский. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Что такое нестандартный анализ?"
            ]
          },
          "\nМ.:Наука, главн. ред. физико-математической литературы,\n1987. 128 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "uspensky-nonstandard-small"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "uspensky-nonstandard-small_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "uspensky-nonstandard-small_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "В.А.Успенский.  ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Нестандартный, или неархимедов, анализ"
            ]
          },
          ".  М.:Знание, 1983. 61 с. (Новое в жизни, науке, технике.\nМатематика, кибернетика, №8.)\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "freudenthal"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "freudenthal_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "freudenthal_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Х.Фрейденталь. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Язык логики"
            ]
          },
          ", перевод с английского Ю.А.Петрова\nпод редакцией Ю.А.Гастева. М.:Наука, главная редакция физикод\nматематической литературы, 1969. 136 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "church"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "church_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "church_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "А.Чёрч. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в математическую логику. I"
            ]
          },
          ",\nперевод с английского В.С.Чернявского под ред.\nВ.А.Успенского. М.:Издательство иностранной литературы,\n1960. 484 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "shoenfield"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "shoenfield_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "shoenfield_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Дж.Шенфилд. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Математическая логика"
            ]
          },
          ",\nперевод с английского И.А.Лаврова и И.А.Мальцева\nпод редакцией Ю.Л.Ершова. М.:Наука, 1975. 528 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "engeler"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "engeler_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "engeler_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "Э.Энгелер. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Метаматематика элементарной математики"
            ]
          },
          ",\nперевод с немецкого Г.Е.Минца под редакцией А.О.Слисенко.\nМ:Мир, 1987. 128 с.\n",
          "",
          "\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "cyber"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "cyber_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "cyber_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "С.В.Яблонский. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Введение в дискретную математику"
            ]
          },
          ",\nиздание второе. М.:Наука, 1986. 384 с.\n"
        ]
      }
    ]
  },
  "\n\n\n",
  {
    "name": "area",
    "props": {
      "key": "keisler-nonstandard"
    },
    "children": [
      {
        "name": "area",
        "props": {},
        "children": [
          "[",
          {
            "name": "area",
            "props": {
              "inline": true,
              "key": "keisler-nonstandard_link"
            },
            "children": [
              {
                "name": "counter",
                "props": {
                  "use": "lit",
                  "key": "keisler-nonstandard_counter"
                },
                "children": []
              }
            ]
          },
          "] ",
          "H.J.Keisler. ",
          {
            "name": "format.i",
            "props": {},
            "children": [
              "Elementary Calculus"
            ]
          },
          ".\nWeber and Sсhmidt, Prindle, 1976.\n"
        ]
      }
    ]
  },
  "\n",
  "\n"
]